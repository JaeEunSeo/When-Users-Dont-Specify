{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Clean up any accidental whitespace in column names\ndf.columns = df.columns.str.strip()\n\n# Use the index-like column as the x-axis (fallback to row number if missing)\nx_col = \"Unnamed: 0\" if \"Unnamed: 0\" in df.columns else None\nx = df[x_col] if x_col else range(len(df))\n\n# Single chart: AveragePrice vs observation index\nplt.figure(figsize=(10, 5))\nplt.plot(x, df[\"AveragePrice\"], marker=\"o\", linewidth=1.8)\n\nplt.title(\"Avocado Average Price (10Avocado.csv)\")\nplt.xlabel(\"Observation\" if not x_col else x_col)\nplt.ylabel(\"AveragePrice ($)\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the plt.plot() function from matplotlib.pyplot directly, rather than through a pandas wrapper or seaborn. The chart visualizes a quantitative variable (AveragePrice) over a sequential index (Observation), which corresponds to a Line chart in the provided taxonomy."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Basic cleaning: drop the index-like column if present\nif \"Unnamed: 0\" in df.columns:\n    df = df.drop(columns=[\"Unnamed: 0\"])\n\n# Sort by volume for an easy \"read the data\" comparison\ndf_sorted = df.sort_values(\"Total Volume\", ascending=False)\n\n# Single chart: Total Volume vs Average Price\nplt.figure(figsize=(9, 5.5))\nplt.scatter(df_sorted[\"Total Volume\"], df_sorted[\"AveragePrice\"], color=\"#2a6fbb\", alpha=0.85)\n\nplt.title(\"Avocado: Average Price vs Total Volume (2015, conventional)\")\nplt.xlabel(\"Total Volume\")\nplt.ylabel(\"Average Price ($)\")\n\n# Light grid for readability\nplt.grid(True, linewidth=0.5, alpha=0.35)\n\n# Keep axes readable (avoid scientific notation if possible)\nplt.ticklabel_format(style=\"plain\", axis=\"x\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The plot is created using standard matplotlib.pyplot functions (specifically plt.scatter) rather than pandas or seaborn wrappers, and it maps two quantitative variables (Total Volume and Average Price) to the X and Y axes."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Single, straightforward chart: relationship between price and total volume\nplt.figure(figsize=(9, 6))\nplt.scatter(df[\"Total Volume\"], df[\"AveragePrice\"], alpha=0.8)\n\nplt.title(\"Avocado Average Price vs Total Volume (10Avocado.csv)\")\nplt.xlabel(\"Total Volume\")\nplt.ylabel(\"Average Price ($)\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization is created using the standard `plt.scatter()` function from matplotlib to represent the relationship between two quantitative variables (Total Volume and Average Price)."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Basic cleanup: drop index-like column if present\nif \"Unnamed: 0\" in df.columns:\n    df = df.drop(columns=[\"Unnamed: 0\"])\n\n# Sort for a clear left-to-right view\ndf = df.sort_index().reset_index(drop=True)\n\n# Single chart: AveragePrice across the 17 records\nplt.figure(figsize=(10, 5))\nplt.plot(df.index, df[\"AveragePrice\"], marker=\"o\", linewidth=2)\n\nplt.title(\"Avocado Average Price (2015, conventional) — 10Avocado.csv\")\nplt.xlabel(\"Record (row order)\")\nplt.ylabel(\"Average Price ($)\")\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard plt.plot() function from matplotlib to render the data directly, rather than using the pandas .plot() wrapper or seaborn. The resulting visualization is a sequence of values plotted against an index and connected by a line, fitting the 'Line chart' taxonomy."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Plot: AveragePrice over row index (proxy for time/order in file)\nplt.figure(figsize=(9, 4.8))\nplt.plot(df[\"Unnamed: 0\"], df[\"AveragePrice\"], marker=\"o\", linewidth=1.8)\nplt.title(\"Average Avocado Price (conventional, 2015) — 10Avocado.csv\")\nplt.xlabel(\"Record index (Unnamed: 0)\")\nplt.ylabel(\"AveragePrice ($)\")\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function 'plt.plot()' to render the data directly, representing a temporal/sequential progression of a quantitative value (AveragePrice)."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Prepare x/y\nx = df[\"Unnamed: 0\"]\ny = df[\"AveragePrice\"]\n\n# Plot (single chart)\nplt.figure(figsize=(9, 4.8))\nplt.plot(x, y, marker=\"o\", linewidth=1.8)\nplt.title(\"Average Avocado Price by Record Index (2015, conventional)\")\nplt.xlabel(\"Record Index (Unnamed: 0)\")\nplt.ylabel(\"Average Price ($)\")\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() from the matplotlib.pyplot library to render the data directly. According to the taxonomy, a chart using quantitative and categorical/temporal dimensions (in this case, Record Index vs Average Price) rendered with lines is a Line chart."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Ensure proper numeric sorting by the index-like column\ndf = df.sort_values(\"Unnamed: 0\")\n\n# Single chart: AveragePrice vs Total Volume (scatter)\nplt.figure(figsize=(8, 5))\nplt.scatter(df[\"Total Volume\"], df[\"AveragePrice\"], alpha=0.85)\n\nplt.title(\"Avocado: AveragePrice vs Total Volume (type=conventional, year=2015)\")\nplt.xlabel(\"Total Volume\")\nplt.ylabel(\"AveragePrice\")\nplt.grid(True, linewidth=0.5, alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization is created using the plt.scatter() function from the matplotlib library, plotting two quantitative variables (Total Volume and AveragePrice)."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"10Avocado.csv\")\n\n    # Ensure numeric columns are treated correctly\n    numeric_cols = [\"AveragePrice\", \"Total Volume\", \"Total Bags\", \"Small Bags\", \"Large Bags\", \"XLarge Bags\", \"year\"]\n    for c in numeric_cols:\n        df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n    # Sort by the original row index column to preserve sequence\n    if \"Unnamed: 0\" in df.columns:\n        df = df.sort_values(\"Unnamed: 0\")\n\n    # Single chart: AveragePrice and Total Volume over the sequence (dual y-axis)\n    x = df[\"Unnamed: 0\"] if \"Unnamed: 0\" in df.columns else df.index\n\n    fig, ax1 = plt.subplots(figsize=(10, 5))\n\n    ax1.plot(x, df[\"AveragePrice\"], color=\"tab:blue\", linewidth=2, label=\"AveragePrice\")\n    ax1.set_xlabel(\"Index (Unnamed: 0)\")\n    ax1.set_ylabel(\"AveragePrice\", color=\"tab:blue\")\n    ax1.tick_params(axis=\"y\", labelcolor=\"tab:blue\")\n    ax1.grid(True, linestyle=\"--\", alpha=0.3)\n\n    ax2 = ax1.twinx()\n    ax2.plot(x, df[\"Total Volume\"], color=\"tab:orange\", linewidth=2, label=\"Total Volume\")\n    ax2.set_ylabel(\"Total Volume\", color=\"tab:orange\")\n    ax2.tick_params(axis=\"y\", labelcolor=\"tab:orange\")\n\n    title_parts = []\n    if \"type\" in df.columns and df[\"type\"].notna().any():\n        title_parts.append(f\"type={df['type'].dropna().iloc[0]}\")\n    if \"year\" in df.columns and df[\"year\"].notna().any():\n        years = sorted(df[\"year\"].dropna().unique().tolist())\n        title_parts.append(f\"year={years[0]}\" if len(years) == 1 else f\"years={years[0]}-{years[-1]}\")\n    title = \"Avocado: AveragePrice vs Total Volume\" + (f\" ({', '.join(title_parts)})\" if title_parts else \"\")\n    ax1.set_title(title)\n\n    lines1, labels1 = ax1.get_legend_handles_labels()\n    lines2, labels2 = ax2.get_legend_handles_labels()\n    ax1.legend(lines1 + lines2, labels1 + labels2, loc=\"upper right\")\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.plot()` function directly to render data on both primary and secondary y-axes. It does not use the pandas `.plot()` wrapper or seaborn functions. The visualization represents quantitative values over a sequence index, which fits the Line chart taxonomy."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    # Cargar datos\n    df = pd.read_csv(\"10Avocado.csv\")\n\n    # Asegurar orden por índice original (si existe) para representar la serie correctamente\n    if \"Unnamed: 0\" in df.columns:\n        df = df.sort_values(\"Unnamed: 0\")\n\n    # Gráfico: Precio promedio vs. Volumen total (un solo chart)\n    plt.figure(figsize=(9, 5))\n    plt.scatter(df[\"Total Volume\"], df[\"AveragePrice\"], alpha=0.85)\n\n    plt.title(\"AveragePrice vs Total Volume (10Avocado.csv)\")\n    plt.xlabel(\"Total Volume\")\n    plt.ylabel(\"AveragePrice\")\n    plt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses plt.scatter() directly from the Matplotlib library to render the data points. Two quantitative variables (Total Volume and AveragePrice) are plotted against each other, which fits the definition of a Scatterplot."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Ensure numeric columns are numeric (robust to formatting issues)\ncols = [\"AveragePrice\", \"Total Volume\", \"Total Bags\", \"Small Bags\", \"Large Bags\", \"XLarge Bags\"]\nfor c in cols:\n    df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n# Sort for a clean x-axis\ndf = df.sort_values(\"Total Volume\")\n\n# Single chart: AveragePrice vs Total Volume, bubble size by Total Bags\nfig, ax = plt.subplots(figsize=(9, 5.5))\n\nsizes = df[\"Total Bags\"].fillna(0)\n# Scale bubble sizes to a reasonable range\ns = (sizes - sizes.min()) / (sizes.max() - sizes.min() + 1e-9)\ns = 80 + s * 620  # points^2\n\nsc = ax.scatter(\n    df[\"Total Volume\"],\n    df[\"AveragePrice\"],\n    s=s,\n    c=df[\"AveragePrice\"],\n    cmap=\"viridis\",\n    alpha=0.85,\n    edgecolor=\"white\",\n    linewidth=0.6,\n)\n\nax.set_title(\"Avocado Average Price vs Total Volume (Bubble Size = Total Bags)\")\nax.set_xlabel(\"Total Volume\")\nax.set_ylabel(\"Average Price (USD)\")\nax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.35)\n\ncbar = plt.colorbar(sc, ax=ax, pad=0.02)\ncbar.set_label(\"Average Price (USD)\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "viridis", "reasoning": "The code uses the standard matplotlib ax.scatter() function. Since it maps two quantitative variables to the X and Y axes and a third quantitative variable (Total Bags) to the marker size (s), it is classified as a Bubble chart."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Ensure expected columns exist\nrequired = [\"Unnamed: 0\", \"AveragePrice\", \"Total Volume\", \"Total Bags\", \"Small Bags\", \"Large Bags\", \"XLarge Bags\", \"type\", \"year\"]\nmissing = [c for c in required if c not in df.columns]\nif missing:\n    raise ValueError(f\"Missing columns in CSV: {missing}\")\n\n# Sort for a clean x-axis\ndf = df.sort_values(\"Unnamed: 0\")\n\n# Plot: AveragePrice vs Total Volume (bubble size = Total Bags)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsizes = (df[\"Total Bags\"] / df[\"Total Bags\"].max()) * 1200 + 60  # scale bubble sizes\n\nsc = ax.scatter(\n    df[\"Total Volume\"],\n    df[\"AveragePrice\"],\n    s=sizes,\n    c=df[\"Total Volume\"],\n    cmap=\"viridis\",\n    alpha=0.85,\n    edgecolor=\"white\",\n    linewidth=0.8,\n)\n\ntitle = f\"Avocados ({df['type'].iloc[0] if len(df) else ''}, {df['year'].iloc[0] if len(df) else ''}): Price vs Volume\\nBubble size = Total Bags\"\nax.set_title(title, pad=12)\nax.set_xlabel(\"Total Volume\")\nax.set_ylabel(\"Average Price (USD)\")\n\nax.xaxis.set_major_formatter(mtick.StrMethodFormatter(\"{x:,.0f}\"))\nax.yaxis.set_major_formatter(mtick.StrMethodFormatter(\"${x:.2f}\"))\n\ncbar = fig.colorbar(sc, ax=ax, pad=0.02)\ncbar.set_label(\"Total Volume\")\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "viridis", "reasoning": "The data is rendered using the ax.scatter() method from matplotlib. The chart maps two quantitative variables (Total Volume and AveragePrice) to the X and Y axes, and uses a third quantitative variable (Total Bags) to modulate the size of the markers, satisfying the definition of a Bubble chart. The cmap 'viridis' is explicitly provided in the scatter function."}}
{"input_csv_file": "10Avocado.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"10Avocado.csv\")\n\n# Clean/ensure numeric columns\nfor col in [\"AveragePrice\", \"Total Volume\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\ndf = df.dropna(subset=[\"AveragePrice\", \"Total Volume\"])\n\n# Scatter: AveragePrice vs Total Volume (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5.5))\n\nax.scatter(\n    df[\"Total Volume\"],\n    df[\"AveragePrice\"],\n    s=65,\n    alpha=0.85,\n    edgecolor=\"white\",\n    linewidth=0.8,\n)\n\nax.set_title(\"Avocado Average Price vs Total Volume (10Avocado.csv)\", pad=10, fontsize=13)\nax.set_xlabel(\"Total Volume\")\nax.set_ylabel(\"Average Price ($)\")\n\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{x/1000:.0f}K\"))\nax.set_xlim(left=0)\n\n# Annotate points with row index for traceability (small dataset)\nfor i, r in df.iterrows():\n    ax.annotate(\n        str(int(r[\"Unnamed: 0\"])) if \"Unnamed: 0\" in df.columns else str(i),\n        (r[\"Total Volume\"], r[\"AveragePrice\"]),\n        textcoords=\"offset points\",\n        xytext=(6, 4),\n        fontsize=8,\n        alpha=0.85,\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The plot is created using the standard matplotlib axes-level function ax.scatter() to visualize the relationship between two quantitative variables (Total Volume and Average Price), making it a Scatterplot. While pandas is used for data manipulation, the drawing logic belongs to matplotlib."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Diamond.csv\")\n\n# Single chart: Price vs Carat, colored by cut\ncuts = sorted(df[\"cut\"].unique())\ncmap = plt.get_cmap(\"tab10\")\ncolors = {cut: cmap(i % 10) for i, cut in enumerate(cuts)}\n\nplt.figure(figsize=(8, 5.5))\nfor cut in cuts:\n    sub = df[df[\"cut\"] == cut]\n    plt.scatter(\n        sub[\"carat\"],\n        sub[\"price\"],\n        s=60,\n        alpha=0.85,\n        color=colors[cut],\n        edgecolor=\"white\",\n        linewidth=0.6,\n        label=cut,\n    )\n\nplt.title(\"Diamond Price vs Carat (colored by Cut)\")\nplt.xlabel(\"Carat\")\nplt.ylabel(\"Price (USD)\")\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\nplt.legend(title=\"Cut\", frameon=True)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "tab10", "reasoning": "The visualization is created using the standard matplotlib.pyplot function plt.scatter() to map two quantitative variables (carat and price) onto the axes."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Diamond.csv\")\n\n# Single chart: relationship between carat and price\nplt.figure(figsize=(8, 5))\nplt.scatter(df[\"carat\"], df[\"price\"], color=\"#1f77b4\", edgecolor=\"black\", linewidth=0.6, alpha=0.9)\n\nplt.title(\"Diamond Price vs Carat (10Diamond.csv)\")\nplt.xlabel(\"Carat\")\nplt.ylabel(\"Price (USD)\")\nplt.grid(True, linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.scatter() to plot the data, which directly matches the priority rule for 'matplotlib'. It maps two quantitative variables (carat and price) to the X and Y axes, identifying it as a scatterplot."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Diamond.csv\")\n\n# Simple, \"read the data\" level chart: count of diamonds by cut\ncut_counts = df[\"cut\"].value_counts().sort_index()\n\nplt.figure(figsize=(8, 4.5))\ncut_counts.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\n\nplt.title(\"Number of Diamonds by Cut (10Diamond.csv)\")\nplt.xlabel(\"Cut\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas Series .plot() method with kind='bar', which defaults to vertical bars (Column chart). Even though matplotlib is used for styling, the hierarchy rules prioritize pandas when .plot() is used to draw the data."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Diamond.csv\")\n\n# Clean up index-like column if present\nif \"Unnamed: 0\" in df.columns:\n    df = df.drop(columns=[\"Unnamed: 0\"])\n\n# Simple, \"read the data\" level chart: distribution of prices by cut (boxplot)\norder = [\"Fair\", \"Good\", \"Very Good\", \"Premium\", \"Ideal\"]\ncuts_in_data = [c for c in order if c in set(df[\"cut\"])]\n\ndata = [df.loc[df[\"cut\"] == c, \"price\"] for c in cuts_in_data]\n\nplt.figure(figsize=(9, 5))\nplt.boxplot(data, labels=cuts_in_data, showmeans=True)\nplt.title(\"Diamond Price Distribution by Cut (10Diamond.csv)\")\nplt.xlabel(\"Cut\")\nplt.ylabel(\"Price (USD)\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Box plot", "color_palette": null, "reasoning": "The code uses the standard matplotlib function plt.boxplot() to draw the data distributions, rather than using a high-level wrapper like seaborn or pandas.plot()."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"10Diamond.csv\")\n\n    fig, ax = plt.subplots(figsize=(8, 5))\n\n    cuts = df[\"cut\"].unique()\n    for cut in cuts:\n        sub = df[df[\"cut\"] == cut]\n        ax.scatter(sub[\"carat\"], sub[\"price\"], label=cut, s=55, alpha=0.85, edgecolors=\"white\", linewidths=0.6)\n\n    ax.set_title(\"Diamond Price vs Carat (colored by Cut)\")\n    ax.set_xlabel(\"Carat\")\n    ax.set_ylabel(\"Price (USD)\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.35)\n    ax.legend(title=\"Cut\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the 'ax.scatter' method from the matplotlib library to render data points. It plots two quantitative variables, 'carat' and 'price', on the X and Y axes respectively, which fits the definition of a scatterplot."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"10Diamond.csv\")\n\n    # Scatter: carat vs price, colored by cut\n    fig, ax = plt.subplots(figsize=(8, 5))\n\n    cuts = df[\"cut\"].astype(str).unique()\n    for cut in cuts:\n        sub = df[df[\"cut\"].astype(str) == cut]\n        ax.scatter(sub[\"carat\"], sub[\"price\"], label=cut, s=60, alpha=0.85, edgecolors=\"white\", linewidths=0.5)\n\n    ax.set_title(\"Diamond Price vs Carat (colored by Cut)\")\n    ax.set_xlabel(\"Carat\")\n    ax.set_ylabel(\"Price\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n    ax.legend(title=\"Cut\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is plotted using the `ax.scatter()` method from matplotlib. According to the hierarchy rules, since it uses matplotlib functions directly rather than seaborn or pandas plotting methods, the library is classified as matplotlib. The chart maps two quantitative dimensions (carat and price) to the X and Y axes, fitting the definition of a Scatterplot."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"10Diamond.csv\")\n\n    # Scatter plot: carat vs price, colored by cut\n    cuts = df[\"cut\"].astype(str).unique()\n    cmap = plt.cm.get_cmap(\"tab10\", len(cuts))\n\n    plt.figure(figsize=(8, 5))\n    for i, cut in enumerate(cuts):\n        sub = df[df[\"cut\"] == cut]\n        plt.scatter(sub[\"carat\"], sub[\"price\"], label=cut, s=60, alpha=0.85, color=cmap(i), edgecolors=\"white\", linewidths=0.6)\n\n    plt.title(\"Diamond Price vs Carat (colored by Cut)\")\n    plt.xlabel(\"Carat\")\n    plt.ylabel(\"Price\")\n    plt.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.5)\n    plt.legend(title=\"Cut\", frameon=True)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "tab10", "reasoning": "The visualization uses plt.scatter() directly to render the relationship between two quantitative variables ('carat' and 'price'). The 'tab10' colormap is explicitly retrieved via plt.cm.get_cmap and applied to the scatter points."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Diamond.csv\")\n\n# Aggregate: average price by cut\ncut_order = [\"Fair\", \"Good\", \"Very Good\", \"Premium\", \"Ideal\"]\navg_price_by_cut = (\n    df.groupby(\"cut\", as_index=True)[\"price\"]\n      .mean()\n      .reindex(cut_order)\n      .dropna()\n)\n\n# Plot (single chart)\nplt.figure(figsize=(8, 4.5))\nbars = plt.bar(avg_price_by_cut.index, avg_price_by_cut.values, color=\"#4C78A8\")\n\nplt.title(\"Average Diamond Price by Cut (10Diamond.csv)\")\nplt.xlabel(\"Cut\")\nplt.ylabel(\"Average Price\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n# Value labels\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h, f\"{h:.1f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function 'plt.bar()' to render data directly. Since the bars are vertical and represent a categorical dimension (Cut) versus a quantitative dimension (Average Price), it is classified as a Column chart."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"10Diamond.csv\")\n\n# Dispersión: relación entre quilates (carat) y precio (price)\nplt.figure(figsize=(8, 5))\nplt.scatter(df[\"carat\"], df[\"price\"], alpha=0.85)\nplt.title(\"Precio vs Quilates (carat) - 10Diamond.csv\")\nplt.xlabel(\"Quilates (carat)\")\nplt.ylabel(\"Precio (price)\")\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the standard pyplot function plt.scatter() to visualize the relationship between two quantitative variables ('carat' and 'price'), which classifies the library as matplotlib and the chart type as a Scatterplot."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"10Diamond.csv\")\n\n# Clean up column name if present\nif \"Unnamed: 0\" in df.columns:\n    df = df.rename(columns={\"Unnamed: 0\": \"id\"})\n\n# Styling\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\n\n# Single chart: Price vs Carat, colored by Cut\nplt.figure(figsize=(10, 6))\nax = sns.scatterplot(\n    data=df,\n    x=\"carat\",\n    y=\"price\",\n    hue=\"cut\",\n    s=120,\n    edgecolor=\"white\",\n    linewidth=0.8,\n    alpha=0.9\n)\n\nax.set_title(\"Diamond Price vs Carat (colored by Cut)\")\nax.set_xlabel(\"Carat\")\nax.set_ylabel(\"Price (USD)\")\n\n# Improve legend placement\nax.legend(title=\"Cut\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", borderaxespad=0)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization is created using the sns.scatterplot() function from the Seaborn library. It maps two quantitative variables ('carat' and 'price') to the axes, which fits the definition of a Scatterplot. Although 'hue' is used for a categorical variable and 's' is used for point size, the size is a constant value (120) rather than a variable-modulating dimension, excluding it from being a bubble chart."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Diamond.csv\")\n\n# Scatter: price vs carat, colored by cut (single chart)\ncuts = df[\"cut\"].astype(str).unique()\ncmap = plt.get_cmap(\"tab10\")\ncolor_map = {cut: cmap(i % 10) for i, cut in enumerate(cuts)}\n\nplt.figure(figsize=(8.5, 5.2))\nfor cut in cuts:\n    sub = df[df[\"cut\"].astype(str) == cut]\n    plt.scatter(\n        sub[\"carat\"],\n        sub[\"price\"],\n        s=55,\n        alpha=0.85,\n        edgecolors=\"white\",\n        linewidths=0.6,\n        color=color_map[cut],\n        label=cut,\n    )\n\nplt.title(\"Diamond Price vs Carat (colored by Cut)\")\nplt.xlabel(\"Carat\")\nplt.ylabel(\"Price (USD)\")\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.35)\nplt.legend(title=\"Cut\", frameon=False, ncols=2)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "tab10", "reasoning": "The data is rendered using the standard matplotlib.pyplot function 'plt.scatter()' to map two quantitative variables ('carat' and 'price') against each other. The color palette 'tab10' is explicitly fetched using 'plt.get_cmap()'."}}
{"input_csv_file": "10Diamond.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10Diamond.csv\")\n\n# Clean up index-like column if present\nif \"Unnamed: 0\" in df.columns:\n    df = df.rename(columns={\"Unnamed: 0\": \"id\"})\n\n# Plot: Price vs Carat, colored by Cut\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\nplt.figure(figsize=(10, 6))\n\nax = sns.scatterplot(\n    data=df,\n    x=\"carat\",\n    y=\"price\",\n    hue=\"cut\",\n    style=\"cut\",\n    s=120,\n    alpha=0.9\n)\n\nax.set_title(\"Diamond Price vs Carat (colored by Cut)\")\nax.set_xlabel(\"Carat\")\nax.set_ylabel(\"Price (USD)\")\n\n# Make legend more compact\nleg = ax.legend(title=\"Cut\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", borderaxespad=0)\nfor h in leg.legend_handles:\n    try:\n        h.set_alpha(1)\n    except Exception:\n        pass\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The plot is rendered using the 'sns.scatterplot()' function from the seaborn library. It visualizes the relationship between two quantitative variables, 'carat' and 'price', which identifies it as a Scatterplot according to the taxonomy."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10VG.csv\")\n\n# Prepare stacked regional sales by game (Top 10 by Global_Sales)\ntop = df.sort_values(\"Global_Sales\", ascending=False).head(10).copy()\ntop[\"Name\"] = top[\"Name\"].astype(str)\n\nregions = [\"NA_Sales\", \"EU_Sales\", \"JP_Sales\", \"Other_Sales\"]\ncolors = {\n    \"NA_Sales\": \"#1f77b4\",\n    \"EU_Sales\": \"#ff7f0e\",\n    \"JP_Sales\": \"#2ca02c\",\n    \"Other_Sales\": \"#7f7f7f\",\n}\n\ny = top[\"Name\"]\nleft = pd.Series([0.0] * len(top), index=top.index)\n\n# Plot: single chart (stacked horizontal bars)\nfig, ax = plt.subplots(figsize=(12, 7))\n\nfor r in regions:\n    ax.barh(\n        y,\n        top[r],\n        left=left,\n        label=r.replace(\"_Sales\", \"\"),\n        color=colors[r],\n        edgecolor=\"white\",\n        linewidth=0.6,\n    )\n    left = left + top[r]\n\nax.set_title(\"Top 10 Video Games by Global Sales (Stacked by Region)\")\nax.set_xlabel(\"Sales (millions of units)\")\nax.set_ylabel(\"Game\")\nax.invert_yaxis()\nax.legend(title=\"Region\", frameon=False, ncol=4, loc=\"lower right\")\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nfor spine in [\"top\", \"right\", \"left\"]:\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses the 'ax.barh' function from matplotlib to render horizontal bars. By iterating through multiple data columns and utilizing the 'left' parameter, it stacks the segments horizontally."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10VG.csv\")\n\n# Prepare: top 10 by Global Sales\ntop10 = df.sort_values(\"Global_Sales\", ascending=False).head(10).copy()\ntop10 = top10.sort_values(\"Global_Sales\", ascending=True)  # for horizontal bar ordering\n\n# Plot: Global Sales (millions) for top 10 games\nplt.figure(figsize=(10, 6))\nplt.barh(top10[\"Name\"], top10[\"Global_Sales\"], color=\"#4C78A8\")\nplt.title(\"Top 10 Video Games by Global Sales (Millions)\")\nplt.xlabel(\"Global Sales (Millions)\")\nplt.ylabel(\"Game\")\n\n# Label values\nfor y, v in enumerate(top10[\"Global_Sales\"]):\n    plt.text(v + 0.5, y, f\"{v:.2f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization is created using plt.barh(), which is a standard matplotlib function for horizontal bars. According to the taxonomy, horizontal bars representing one categorical and one quantitative variable are classified as a 'Bar chart'."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10VG.csv\")\n\n# Prepare: top 10 by Global_Sales\ntop10 = df.sort_values(\"Global_Sales\", ascending=False).head(10).copy()\ntop10 = top10.sort_values(\"Global_Sales\", ascending=True)  # for readable horizontal bars\n\n# Plot: Global sales (millions) for top 10 games\nplt.figure(figsize=(10, 6))\nplt.barh(top10[\"Name\"], top10[\"Global_Sales\"], color=\"#4C78A8\")\n\nplt.title(\"Top 10 Video Games by Global Sales\")\nplt.xlabel(\"Global Sales (millions)\")\nplt.ylabel(\"Game\")\n\n# Add value labels\nfor y, v in enumerate(top10[\"Global_Sales\"]):\n    plt.text(v + 0.5, y, f\"{v:.2f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization is created using plt.barh() directly from the matplotlib library. Since the bars are horizontal, it is classified as a 'Bar chart' per the taxonomy definitions."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10VG.csv\")\n\n# Prepare: top games by global sales (already ranked, but sort to be safe)\ntop = df.sort_values(\"Global_Sales\", ascending=False).head(10)\n\n# Plot: simple, \"read the data\" level chart (Curcio Level 1)\nplt.figure(figsize=(11, 6))\nplt.barh(top[\"Name\"], top[\"Global_Sales\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()  # highest at top\n\nplt.title(\"Top 10 Video Games by Global Sales\")\nplt.xlabel(\"Global Sales (millions)\")\nplt.ylabel(\"Game\")\n\n# Add value labels for direct reading\nfor y, v in enumerate(top[\"Global_Sales\"]):\n    plt.text(v + 0.4, y, f\"{v:.2f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization uses plt.barh() to create horizontal bars, which corresponds to the 'Bar chart' definition in the taxonomy. Since the data is rendered using standard pyplot functions rather than pandas or seaborn wrappers, the library is classified as 'matplotlib'."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10VG.csv\")\n\n# Plot: Global sales by game (sorted)\ndf = df.sort_values(\"Global_Sales\", ascending=True)\n\nplt.figure(figsize=(10, 7))\nplt.barh(df[\"Name\"], df[\"Global_Sales\"], color=\"#4C78A8\")\nplt.title(\"Top Video Games by Global Sales\")\nplt.xlabel(\"Global Sales (millions)\")\nplt.ylabel(\"Game\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib pyplot function plt.barh() to render horizontal bars. Per the taxonomy, horizontal layouts are classified as Bar charts rather than Column charts, and since the data is drawn directly via plt functions rather than pandas wrappers, the library is matplotlib."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"10VG.csv\")\n\n    # Aggregate global sales by genre\n    genre_sales = (\n        df.groupby(\"Genre\", as_index=True)[\"Global_Sales\"]\n        .sum()\n        .sort_values(ascending=False)\n    )\n\n    # Single chart: bar chart of Global Sales by Genre\n    plt.figure(figsize=(10, 5))\n    bars = plt.bar(genre_sales.index, genre_sales.values, color=\"#4C78A8\")\n    plt.title(\"Total Global Sales by Genre (from 10VG.csv)\")\n    plt.xlabel(\"Genre\")\n    plt.ylabel(\"Global Sales (millions)\")\n    plt.xticks(rotation=30, ha=\"right\")\n    plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n    # Value labels\n    for b in bars:\n        h = b.get_height()\n        plt.text(b.get_x() + b.get_width() / 2, h, f\"{h:.2f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered directly using `plt.bar()`, which corresponds to the 'matplotlib' library. Since `plt.bar()` creates vertical bars by default, the visualization is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10VG.csv\")\n\n# Aggregate Global Sales by Platform\nplatform_sales = (\n    df.groupby(\"Platform\", as_index=False)[\"Global_Sales\"]\n    .sum()\n    .sort_values(\"Global_Sales\", ascending=False)\n)\n\n# Plot: Global Sales by Platform (single chart)\nplt.figure(figsize=(10, 5))\nplt.bar(platform_sales[\"Platform\"], platform_sales[\"Global_Sales\"], color=\"#4C78A8\")\nplt.title(\"Global Sales by Platform (from 10VG.csv)\")\nplt.xlabel(\"Platform\")\nplt.ylabel(\"Global Sales (Millions)\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses the plt.bar() function directly to render data as vertical bars, which according to the taxonomy is a 'Column chart'. Although a hex color is provided, no named color palette was used."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"10VG.csv\")\n\n    # 生成：按平台汇总的全球销量（百万）\n    platform_sales = (\n        df.groupby(\"Platform\", as_index=True)[\"Global_Sales\"]\n        .sum()\n        .sort_values(ascending=False)\n    )\n\n    plt.style.use(\"seaborn-v0_8\")\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    ax.bar(platform_sales.index, platform_sales.values, color=\"#4C78A8\")\n    ax.set_title(\"Global Sales by Platform (Top 17 Games in 10VG.csv)\")\n    ax.set_xlabel(\"Platform\")\n    ax.set_ylabel(\"Global Sales (million units)\")\n\n    # 数值标注\n    for i, v in enumerate(platform_sales.values):\n        ax.text(i, v + max(platform_sales.values) * 0.01, f\"{v:.2f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses the matplotlib axes method `ax.bar()` to draw vertical bars, which corresponds to a Column chart. Although pandas is used for data processing, the actual rendering is performed directly through matplotlib functions."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"10VG.csv\")\n\n# Ordenar por ventas globales y preparar etiquetas\ndf = df.sort_values(\"Global_Sales\", ascending=True)\nlabels = df[\"Name\"] + \" (\" + df[\"Platform\"] + \")\"\nvalues = df[\"Global_Sales\"]\n\n# Gráfico: Top ventas globales (barras horizontales)\nplt.figure(figsize=(12, 7))\nplt.barh(labels, values, color=\"#4C78A8\")\nplt.xlabel(\"Global_Sales (millones)\")\nplt.ylabel(\"Juego (Plataforma)\")\nplt.title(\"Ventas Globales (millones) - Top 17 videojuegos\")\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses plt.barh() directly to render the data, which according to the hierarchy rules classifies it as matplotlib. Since the bars are horizontal, it is classified as a Bar chart rather than a Column chart."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"10VG.csv\")\n\n# Prepare: sort by Global_Sales (descending) and keep top 10 (entire file is 17 rows)\ndf = df.sort_values(\"Global_Sales\", ascending=False).copy()\n\n# Shorten long titles for readability\ndef shorten(s, n=26):\n    s = str(s)\n    return s if len(s) <= n else s[: n - 1] + \"…\"\n\ndf[\"Name_short\"] = df[\"Name\"].map(shorten)\n\n# Figure\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 7))\n\n# Colors by platform\nplatforms = df[\"Platform\"].unique()\npalette = plt.cm.Set2(range(len(platforms)))\ncolor_map = dict(zip(platforms, palette))\ncolors = df[\"Platform\"].map(color_map)\n\n# Horizontal bar chart\nbars = ax.barh(df[\"Name_short\"], df[\"Global_Sales\"], color=colors, edgecolor=\"white\", linewidth=0.8)\nax.invert_yaxis()\n\n# Labels\nax.set_title(\"Top Video Games by Global Sales (with Platform Color Coding)\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Global Sales (millions of units)\")\nax.set_ylabel(\"Game\")\n\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{x:.0f}M\"))\n\n# Annotate values\nfor b, val in zip(bars, df[\"Global_Sales\"]):\n    ax.text(b.get_width() + 0.35, b.get_y() + b.get_height() / 2, f\"{val:.2f}\",\n            va=\"center\", ha=\"left\", fontsize=9)\n\n# Legend\nhandles = [plt.Line2D([0], [0], marker=\"s\", linestyle=\"\", markersize=10,\n                      markerfacecolor=color_map[p], markeredgecolor=\"none\", label=p)\n           for p in platforms]\nax.legend(handles=handles, title=\"Platform\", loc=\"lower right\", frameon=True)\n\nax.set_xlim(0, df[\"Global_Sales\"].max() * 1.18)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "Set2", "reasoning": "The plot is created using ax.barh(), a direct matplotlib function. Because the bars are oriented horizontally, it is classified as a Bar chart rather than a Column chart. The Set2 colormap was explicitly accessed via plt.cm.Set2."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"10VG.csv\")\n\n# Sort by global sales (descending) and keep order for plotting\ndf = df.sort_values(\"Global_Sales\", ascending=False).reset_index(drop=True)\n\n# Build labels: Game (Platform, Year)\nlabels = df.apply(lambda r: f\"{r['Name']} ({r['Platform']}, {int(r['Year'])})\", axis=1)\n\n# Regional sales for stacked bars\nregions = [\"NA_Sales\", \"EU_Sales\", \"JP_Sales\", \"Other_Sales\"]\ncolors = {\n    \"NA_Sales\": \"#1f77b4\",\n    \"EU_Sales\": \"#ff7f0e\",\n    \"JP_Sales\": \"#2ca02c\",\n    \"Other_Sales\": \"#9467bd\",\n}\n\nfig, ax = plt.subplots(figsize=(12, 9))\n\nleft = pd.Series([0.0] * len(df))\nfor col in regions:\n    ax.barh(\n        labels,\n        df[col],\n        left=left,\n        color=colors[col],\n        edgecolor=\"white\",\n        linewidth=0.6,\n        label=col.replace(\"_Sales\", \"\"),\n    )\n    left += df[col]\n\n# Overlay global sales as a marker line for quick totals\nax.plot(df[\"Global_Sales\"], labels, color=\"black\", linewidth=1.0, marker=\"o\", markersize=3, label=\"Global (total)\")\n\n# Styling\nax.invert_yaxis()\nax.set_xlabel(\"Sales (Millions)\")\nax.set_title(\"Top Video Games: Regional Sales Breakdown and Global Totals\")\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\n\n# Compact legend\nax.legend(ncols=3, frameon=False, loc=\"lower right\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses 'ax.barh' in a loop with the 'left' parameter to manually stack horizontal bars, which classifies it as a stacked bar chart. Since it uses standard matplotlib axes methods for rendering data, the library is classified as matplotlib."}}
{"input_csv_file": "10VG.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"10VG.csv\")\n\n# Prepare (Top titles by Global Sales)\ndf = df.sort_values(\"Global_Sales\", ascending=True)\nnames = df[\"Name\"].astype(str).values\n\nregions = [\"NA_Sales\", \"EU_Sales\", \"JP_Sales\", \"Other_Sales\"]\nregion_labels = [\"North America\", \"Europe\", \"Japan\", \"Other\"]\ndata = df[regions].values\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 7))\n\ny = np.arange(len(df))\nleft = np.zeros(len(df))\n\ncolors = [\"#4C78A8\", \"#F58518\", \"#54A24B\", \"#B279A2\"]\n\nfor i, (col, label, color) in enumerate(zip(regions, region_labels, colors)):\n    ax.barh(y, data[:, i], left=left, color=color, edgecolor=\"none\", label=label)\n    left += data[:, i]\n\n# Labels & formatting\nax.set_title(\"Top Video Games: Global Sales Breakdown by Region\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Sales (millions of units)\")\nax.set_yticks(y)\nax.set_yticklabels(names)\nax.set_xlim(0, df[\"Global_Sales\"].max() * 1.08)\n\n# Annotate totals at bar ends\ntotals = df[\"Global_Sales\"].values\nfor yi, total in zip(y, totals):\n    ax.text(total + 0.3, yi, f\"{total:.2f}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#333333\")\n\n# Legend\nax.legend(ncols=4, loc=\"lower right\", frameon=True, framealpha=0.95)\n\n# Clean up spines\nfor spine in [\"top\", \"right\"]:\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The visualization is created using standard Matplotlib axes functions (ax.barh). It is a horizontal layout (barh) where multiple regional categories are stacked for each game using the 'left' parameter, which fits the 'Stacked bar chart' definition."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot: Revenue over time for three companies (single chart)\nplt.figure(figsize=(11, 5.5))\nplt.plot(df[\"Quarter\"], df[\"Company_A\"], marker=\"o\", linewidth=2, label=\"Company A\")\nplt.plot(df[\"Quarter\"], df[\"Company_B\"], marker=\"o\", linewidth=2, label=\"Company B\")\nplt.plot(df[\"Quarter\"], df[\"Company_C\"], marker=\"o\", linewidth=2, label=\"Company C\")\n\nplt.title(\"Quarterly Revenue by Company (2022–2024)\")\nplt.xlabel(\"Quarter\")\nplt.ylabel(\"Revenue (USD)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.35)\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard matplotlib.pyplot functions (plt.plot) to render the data rather than pandas' .plot() method or seaborn's high-level functions."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot (single chart): Revenue trends over time for each company\nfig, ax = plt.subplots(figsize=(10, 5))\n\nfor col in [\"Company_A\", \"Company_B\", \"Company_C\"]:\n    ax.plot(df[\"Quarter\"], df[col], marker=\"o\", linewidth=2, label=col)\n\nax.set_title(\"Quarterly Revenue by Company (2022–2024)\")\nax.set_xlabel(\"Quarter\")\nax.set_ylabel(\"Revenue (USD)\")\nax.yaxis.set_major_formatter(mtick.StrMethodFormatter(\"${x:,.0f}\"))\n\nax.grid(True, linestyle=\"--\", alpha=0.4)\nax.legend(title=\"Company\", frameon=False)\n\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the standard Matplotlib 'ax.plot' function within a loop. Based on the taxonomy, it is a Line chart as it depicts temporal (Quarter), categorical (Company), and quantitative (Revenue) dimensions."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot: revenue over time for each company (single chart)\nplt.figure(figsize=(10, 5))\nfor col in [\"Company_A\", \"Company_B\", \"Company_C\"]:\n    plt.plot(df[\"Quarter\"], df[col], marker=\"o\", linewidth=2, label=col)\n\nplt.title(\"Quarterly Revenue by Company (2022–2024)\")\nplt.xlabel(\"Quarter\")\nplt.ylabel(\"Revenue (USD)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using standard matplotlib.pyplot functions (plt.plot) directly to render quantitative revenue data over temporal quarters for multiple categories (companies)."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot\nfig, ax = plt.subplots(figsize=(11, 5.5))\n\nax.plot(df[\"Quarter\"], df[\"Company_A\"], marker=\"o\", linewidth=2, label=\"Company A\")\nax.plot(df[\"Quarter\"], df[\"Company_B\"], marker=\"o\", linewidth=2, label=\"Company B\")\nax.plot(df[\"Quarter\"], df[\"Company_C\"], marker=\"o\", linewidth=2, label=\"Company C\")\n\n# Formatting\nax.set_title(\"Quarterly Revenue by Company (2022–2024)\")\nax.set_xlabel(\"Quarter\")\nax.set_ylabel(\"Revenue (USD)\")\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"${x:,.0f}\"))\n\nax.grid(True, axis=\"y\", alpha=0.3)\nax.legend(frameon=False, ncols=3, loc=\"upper left\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses ax.plot() from the matplotlib library to render temporal/categorical data (Quarter) against quantitative values (Revenue) for different companies, which identifies it as a Line chart."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot: Quarterly revenue trends\nplt.figure(figsize=(11, 5.5))\nfor col in [\"Company_A\", \"Company_B\", \"Company_C\"]:\n    plt.plot(df[\"Quarter\"], df[col], marker=\"o\", linewidth=2, label=col)\n\nplt.title(\"Quarterly Revenue by Company (2022–2024)\")\nplt.xlabel(\"Quarter\")\nplt.ylabel(\"Revenue (USD)\")\nplt.grid(True, axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.xticks(rotation=45, ha=\"right\")\n\nplt.gca().yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x/1000:,.0f}K\"))\nplt.legend(frameon=False, ncol=3, loc=\"upper left\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function 'plt.plot()' to render the data points for multiple series over a time-series axis (Quarter), which according to the hierarchy rules classifies it as matplotlib."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"11company_revenue.csv\")\n\n    plt.figure(figsize=(10, 5))\n    plt.plot(df[\"Quarter\"], df[\"Company_A\"], marker=\"o\", linewidth=2, label=\"Company_A\")\n    plt.plot(df[\"Quarter\"], df[\"Company_B\"], marker=\"o\", linewidth=2, label=\"Company_B\")\n    plt.plot(df[\"Quarter\"], df[\"Company_C\"], marker=\"o\", linewidth=2, label=\"Company_C\")\n\n    plt.title(\"Quarterly Revenue by Company (2022-2024)\")\n    plt.xlabel(\"Quarter\")\n    plt.ylabel(\"Revenue\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.grid(True, linestyle=\"--\", alpha=0.4)\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly from the matplotlib library to visualize multiple quantitative variables (Company revenue) over a temporal/categorical dimension (Quarter), which fits the definition of a Line chart."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot\nplt.figure(figsize=(10, 5))\nfor col in [\"Company_A\", \"Company_B\", \"Company_C\"]:\n    plt.plot(df[\"Quarter\"], df[col], marker=\"o\", linewidth=2, label=col)\n\nplt.title(\"Quarterly Revenue by Company (2022–2024)\")\nplt.xlabel(\"Quarter\")\nplt.ylabel(\"Revenue\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard `plt.plot()` function from the matplotlib library to render temporal/sequential data (Quarters) against quantitative values (Revenue) for multiple categories (Companies)."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 5.5))\n\nfor col, color in zip([\"Company_A\", \"Company_B\", \"Company_C\"], [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\"]):\n    ax.plot(df[\"Quarter\"], df[col], marker=\"o\", linewidth=2, label=col.replace(\"_\", \" \"))\n\n# Formatting\nax.set_title(\"Quarterly Revenue by Company (2022–2024)\")\nax.set_xlabel(\"Quarter\")\nax.set_ylabel(\"Revenue (USD)\")\n\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x/1000:.0f}K\"))\nax.set_xticks(range(len(df[\"Quarter\"])))\nax.set_xticklabels(df[\"Quarter\"], rotation=45, ha=\"right\")\n\nax.legend(frameon=True, title=\"Company\")\nfig.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses `ax.plot()` to draw the data, which is a standard matplotlib function. The visualization maps temporal/categorical 'Quarter' data to quantitative 'Revenue' values for multiple categories using lines and markers, which corresponds to the 'Line chart' taxonomy."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Gráfico: evolución de ingresos por trimestre (una sola figura)\nplt.figure(figsize=(11, 5))\nplt.plot(df[\"Quarter\"], df[\"Company_A\"], marker=\"o\", linewidth=2, label=\"Company_A\")\nplt.plot(df[\"Quarter\"], df[\"Company_B\"], marker=\"o\", linewidth=2, label=\"Company_B\")\nplt.plot(df[\"Quarter\"], df[\"Company_C\"], marker=\"o\", linewidth=2, label=\"Company_C\")\n\nplt.title(\"Ingresos trimestrales por compañía (2022–2024)\")\nplt.xlabel(\"Trimestre\")\nplt.ylabel(\"Ingresos\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, alpha=0.3)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses matplotlib's plt.plot() function directly to render multiple series of quantitative data across temporal/categorical quarters, which corresponds to the definition of a Line chart in the taxonomy."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 5.5))\n\ncompanies = [\"Company_A\", \"Company_B\", \"Company_C\"]\ncolors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\"]\n\nfor c, col in zip(companies, colors):\n    ax.plot(\n        df[\"Quarter\"],\n        df[c],\n        marker=\"o\",\n        linewidth=2.5,\n        markersize=5.5,\n        color=col,\n        label=c.replace(\"_\", \" \"),\n    )\n\nax.set_title(\"Quarterly Revenue by Company (2022–2024)\", fontsize=14, pad=12)\nax.set_xlabel(\"Quarter\")\nax.set_ylabel(\"Revenue (USD)\")\n\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x/1000:.0f}K\"))\n\nax.set_xticks(range(len(df[\"Quarter\"])))\nax.set_xticklabels(df[\"Quarter\"], rotation=45, ha=\"right\")\n\nax.legend(title=\"Company\", frameon=True, loc=\"upper left\")\nax.margins(x=0.02)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the matplotlib library's ax.plot() function directly to render data. It visualizes quantitative revenue data over temporal/sequential quarters for multiple categorical company variables, which defines a Line chart."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 5.8))\n\ncolors = {\"Company_A\": \"#1f77b4\", \"Company_B\": \"#ff7f0e\", \"Company_C\": \"#2ca02c\"}\nfor col in [\"Company_A\", \"Company_B\", \"Company_C\"]:\n    ax.plot(\n        df[\"Quarter\"],\n        df[col],\n        marker=\"o\",\n        linewidth=2.4,\n        markersize=5.5,\n        color=colors[col],\n        label=col.replace(\"_\", \" \"),\n    )\n\nax.set_title(\"Quarterly Revenue by Company (Q1 2022 – Q4 2024)\", pad=12, fontsize=13, weight=\"bold\")\nax.set_xlabel(\"Quarter\")\nax.set_ylabel(\"Revenue (USD)\")\n\nax.yaxis.set_major_formatter(mtick.FuncFormatter(lambda x, pos: f\"${x/1000:,.0f}K\"))\nax.set_ylim(0, df[[\"Company_A\", \"Company_B\", \"Company_C\"]].to_numpy().max() * 1.12)\n\nax.legend(frameon=True, ncols=3, loc=\"upper left\")\nax.tick_params(axis=\"x\", rotation=45)\n\n# Subtle endpoint labels for quick reading\nfor col in [\"Company_A\", \"Company_B\", \"Company_C\"]:\n    ax.annotate(\n        f\"${df[col].iloc[-1]/1000:,.0f}K\",\n        (df[\"Quarter\"].iloc[-1], df[col].iloc[-1]),\n        textcoords=\"offset points\",\n        xytext=(8, 0),\n        va=\"center\",\n        fontsize=9,\n        color=colors[col],\n        weight=\"bold\",\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard Matplotlib Axes method `ax.plot()` to render the data directly, rather than using the pandas or seaborn wrappers. The chart plots quarterly (temporal) data against revenue (quantitative) for different companies (categorical), matching the Line chart definition."}}
{"input_csv_file": "11company_revenue.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"11company_revenue.csv\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6))\n\ncolors = {\n    \"Company_A\": \"#1f77b4\",\n    \"Company_B\": \"#ff7f0e\",\n    \"Company_C\": \"#2ca02c\",\n}\n\nfor col in [\"Company_A\", \"Company_B\", \"Company_C\"]:\n    ax.plot(\n        df[\"Quarter\"],\n        df[col],\n        marker=\"o\",\n        linewidth=2.5,\n        markersize=5,\n        label=col.replace(\"_\", \" \"),\n        color=colors[col],\n    )\n\n# Formatting\nax.set_title(\"Quarterly Revenue by Company (2022–2024)\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Quarter\")\nax.set_ylabel(\"Revenue (USD)\")\n\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x/1000:,.0f}K\"))\n\nax.set_xticks(range(len(df[\"Quarter\"])))\nax.set_xticklabels(df[\"Quarter\"], rotation=45, ha=\"right\")\n\nax.legend(title=\"Company\", frameon=True)\nax.margins(x=0.01)\nfig.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using standard Matplotlib axes functions (ax.plot) rather than seaborn or pandas wrappers. It plots quantitative revenue values across quarters (temporal/categorical) for multiple companies using lines and markers, which fits the 'Line chart' taxonomy."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Preserve month order as in the file\nmonths = df[\"Month\"].tolist()\nx = range(len(months))\n\n# Plot\nplt.figure(figsize=(11, 5.5))\nplt.plot(x, df[\"Seoul\"], marker=\"o\", linewidth=2, label=\"Seoul\")\nplt.plot(x, df[\"Tokyo\"], marker=\"o\", linewidth=2, label=\"Tokyo\")\nplt.plot(x, df[\"Beijing\"], marker=\"o\", linewidth=2, label=\"Beijing\")\n\nplt.title(\"Average Monthly Temperature (°C): Seoul vs Tokyo vs Beijing\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Temperature (°C)\")\nplt.xticks(x, months, rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.35)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard `plt.plot()` function from the matplotlib library to draw data representing temporal (monthly) and quantitative (temperature) variables."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Ensure months are in calendar order as they appear in the file\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=df[\"Month\"].tolist(), ordered=True)\ndf = df.sort_values(\"Month\")\n\n# Single chart: line chart comparing monthly average temperatures\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Month\"], df[\"Seoul\"], marker=\"o\", linewidth=2, label=\"Seoul\")\nplt.plot(df[\"Month\"], df[\"Tokyo\"], marker=\"o\", linewidth=2, label=\"Tokyo\")\nplt.plot(df[\"Month\"], df[\"Beijing\"], marker=\"o\", linewidth=2, label=\"Beijing\")\n\nplt.title(\"Monthly Average Temperature by City\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Temperature (°C)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses the plt.plot() function from matplotlib to draw lines representing temperatures across months, which matches the 'Line chart' definition for temporal/categorical data plotted against quantitative values."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Plot: monthly temperature lines for each city\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Month\"], df[\"Seoul\"], marker=\"o\", linewidth=2, label=\"Seoul\")\nplt.plot(df[\"Month\"], df[\"Tokyo\"], marker=\"o\", linewidth=2, label=\"Tokyo\")\nplt.plot(df[\"Month\"], df[\"Beijing\"], marker=\"o\", linewidth=2, label=\"Beijing\")\n\n# Titles and labels (basic reading-the-data level)\nplt.title(\"Average Monthly Temperature: Seoul, Tokyo, Beijing\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Temperature (°C)\")\n\n# Improve readability for month labels\nplt.xticks(rotation=45, ha=\"right\")\n\n# Legend and layout\nplt.legend(title=\"City\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function (plt.plot) to draw data points connected by lines. It maps a sequential/temporal dimension (Month), a quantitative dimension (Temperature), and multiple categories (Cities) to distinct lines, which matches the definition of a Line chart."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Keep months in the CSV order\nmonths = df[\"Month\"]\n\n# Plot\nplt.figure(figsize=(10, 5))\nplt.plot(months, df[\"Seoul\"], marker=\"o\", linewidth=2, label=\"Seoul\")\nplt.plot(months, df[\"Tokyo\"], marker=\"o\", linewidth=2, label=\"Tokyo\")\nplt.plot(months, df[\"Beijing\"], marker=\"o\", linewidth=2, label=\"Beijing\")\n\nplt.title(\"Average Monthly Temperature (°C): Seoul, Tokyo, Beijing\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Temperature (°C)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the plt.plot() function from matplotlib to render the data directly. It visualizes quantitative temperature values across categorical/temporal month labels for multiple categories (Seoul, Tokyo, Beijing) using markers and lines, which fits the 'Line chart' definition."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Plot\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Month\"], df[\"Seoul\"], marker=\"o\", linewidth=2, label=\"Seoul\")\nplt.plot(df[\"Month\"], df[\"Tokyo\"], marker=\"o\", linewidth=2, label=\"Tokyo\")\nplt.plot(df[\"Month\"], df[\"Beijing\"], marker=\"o\", linewidth=2, label=\"Beijing\")\n\nplt.title(\"Monthly Average Temperature: Seoul vs Tokyo vs Beijing\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Temperature (°C)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the standard plt.plot() function from matplotlib rather than pandas or seaborn wrappers. The chart depicts quantitative values (temperature) over a temporal/categorical axis (Month) for multiple categories (Seoul, Tokyo, Beijing), which corresponds to the Line chart taxonomy."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Plot\nplt.figure(figsize=(10, 5))\nfor city in [\"Seoul\", \"Tokyo\", \"Beijing\"]:\n    plt.plot(df[\"Month\"], df[city], marker=\"o\", linewidth=2, label=city)\n\nplt.title(\"Monthly Average Temperature: Seoul vs Tokyo vs Beijing\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Temperature (°C)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using the matplotlib.pyplot function 'plt.plot()' to draw data directly from the DataFrame. It maps temporal (Month), categorical (city), and quantitative (Temperature) dimensions, which aligns with the taxonomy definition for a Line chart."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Plot\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Month\"], df[\"Seoul\"], marker=\"o\", linewidth=2, label=\"Seoul\")\nplt.plot(df[\"Month\"], df[\"Tokyo\"], marker=\"o\", linewidth=2, label=\"Tokyo\")\nplt.plot(df[\"Month\"], df[\"Beijing\"], marker=\"o\", linewidth=2, label=\"Beijing\")\n\nplt.title(\"Monthly Average Temperature (Seoul, Tokyo, Beijing)\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Temperature (°C)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot library (plt.plot) to render the data rather than pandas or seaborn wrappers. The chart displays quantitative values over a temporal/categorical sequence (Month), which classifies it as a Line chart."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"11monthly_temperature.csv\")\n\n    x = df[\"Month\"]\n    plt.figure(figsize=(10, 5))\n    plt.plot(x, df[\"Seoul\"], marker=\"o\", linewidth=2, label=\"Seoul\")\n    plt.plot(x, df[\"Tokyo\"], marker=\"o\", linewidth=2, label=\"Tokyo\")\n    plt.plot(x, df[\"Beijing\"], marker=\"o\", linewidth=2, label=\"Beijing\")\n\n    plt.title(\"Monthly Average Temperature: Seoul vs Tokyo vs Beijing\")\n    plt.xlabel(\"Month\")\n    plt.ylabel(\"Temperature (°C)\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.grid(True, linestyle=\"--\", alpha=0.4)\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly from the matplotlib.pyplot library to render quantitative temperature data against categorical/temporal month data. No pandas or seaborn plotting methods were used for data rendering."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Plot\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Month\"], df[\"Seoul\"], marker=\"o\", linewidth=2, label=\"Seoul\")\nplt.plot(df[\"Month\"], df[\"Tokyo\"], marker=\"o\", linewidth=2, label=\"Tokyo\")\nplt.plot(df[\"Month\"], df[\"Beijing\"], marker=\"o\", linewidth=2, label=\"Beijing\")\n\nplt.title(\"Temperatura media mensual: Seoul, Tokyo y Beijing\")\nplt.xlabel(\"Mes\")\nplt.ylabel(\"Temperatura (°C)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using standard matplotlib.pyplot functions (plt.plot) rather than pandas or seaborn wrappers. It displays quantitative temperature values over a temporal/sequential dimension (Month) for multiple categories (Cities), which fits the definition of a Line chart."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Ensure month order as in file\nmonths = df[\"Month\"].tolist()\nx = range(len(months))\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 5.5), dpi=140)\n\n# Lines\nax.plot(x, df[\"Seoul\"],   marker=\"o\", linewidth=2.2, label=\"Seoul\",   color=\"#1f77b4\")\nax.plot(x, df[\"Tokyo\"],   marker=\"o\", linewidth=2.2, label=\"Tokyo\",   color=\"#ff7f0e\")\nax.plot(x, df[\"Beijing\"], marker=\"o\", linewidth=2.2, label=\"Beijing\", color=\"#2ca02c\")\n\n# Highlight hottest month per city\nfor city, color in [(\"Seoul\", \"#1f77b4\"), (\"Tokyo\", \"#ff7f0e\"), (\"Beijing\", \"#2ca02c\")]:\n    idx = int(df[city].idxmax())\n    ax.scatter(idx, df.loc[idx, city], s=120, facecolor=\"white\", edgecolor=color, linewidth=2.2, zorder=5)\n\n# Axes / labels\nax.set_title(\"Average Monthly Temperature (°C): Seoul vs Tokyo vs Beijing\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Temperature (°C)\")\nax.set_xticks(list(x))\nax.set_xticklabels(months, rotation=35, ha=\"right\")\n\n# Nicely padded y-limits\nymin = min(df[\"Seoul\"].min(), df[\"Tokyo\"].min(), df[\"Beijing\"].min())\nymax = max(df[\"Seoul\"].max(), df[\"Tokyo\"].max(), df[\"Beijing\"].max())\nax.set_ylim(ymin - 2, ymax + 2)\n\n# Legend and footnote\nleg = ax.legend(title=\"City\", frameon=True, loc=\"upper left\")\nleg.get_frame().set_alpha(0.9)\n\nax.text(\n    0.99, 0.02,\n    \"White-centered markers indicate each city's hottest month.\",\n    transform=ax.transAxes,\n    ha=\"right\", va=\"bottom\", fontsize=9, color=\"#444\"\n)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using standard Matplotlib axes methods (ax.plot) rather than pandas or seaborn wrappers. The chart displays a quantitative variable (temperature) over a temporal/categorical sequence (months) using lines, which classifies it as a Line chart."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Plot\nplt.figure(figsize=(11, 5.5))\nfor city in [\"Seoul\", \"Tokyo\", \"Beijing\"]:\n    plt.plot(df[\"Month\"], df[city], marker=\"o\", linewidth=2, label=city)\n\nplt.title(\"Average Monthly Temperature: Seoul vs Tokyo vs Beijing\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Temperature (°C)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.legend(frameon=False, ncol=3, loc=\"upper left\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly from the matplotlib library to render data for each city category across monthly intervals."}}
{"input_csv_file": "11monthly_temperature.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11monthly_temperature.csv\")\n\n# Ensure chronological month order\nmonth_order = [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\ndf = df.sort_values(\"Month\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5), dpi=150)\n\ncolors = {\"Seoul\": \"#1f77b4\", \"Tokyo\": \"#ff7f0e\", \"Beijing\": \"#2ca02c\"}\nfor city in [\"Seoul\", \"Tokyo\", \"Beijing\"]:\n    ax.plot(\n        df[\"Month\"], df[city],\n        label=city, color=colors[city],\n        linewidth=2.6, marker=\"o\", markersize=4.8\n    )\n\nax.set_title(\"Monthly Average Temperature (°C): Seoul vs Tokyo vs Beijing\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Temperature (°C)\")\nax.set_ylim(-2, 32)\nax.legend(title=\"City\", frameon=True, loc=\"upper left\")\n\nax.tick_params(axis=\"x\", rotation=35)\nax.margins(x=0.01)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The plot is rendered using the matplotlib 'ax.plot()' function within a loop to draw lines for different city categories over a temporal (monthly) scale."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Plot\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2, label=\"Math\")\nplt.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2, label=\"Science\")\nplt.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2, label=\"English\")\n\n# Styling\nplt.title(\"Student Progress Over 12 Weeks\")\nplt.xlabel(\"Week\")\nplt.ylabel(\"Score\")\nplt.xticks(df[\"Week\"])\nplt.ylim(60, 100)\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the standard plt.plot() function from matplotlib, visualizing quantitative scores over a temporal/sequential dimension (weeks) for different categories (subjects)."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Create a single chart: line plot of weekly scores by subject\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2, label=\"Math\")\nplt.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2, label=\"Science\")\nplt.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2, label=\"English\")\n\nplt.title(\"Student Progress Over 12 Weeks\")\nplt.xlabel(\"Week\")\nplt.ylabel(\"Score\")\nplt.xticks(df[\"Week\"])\nplt.ylim(0, 100)\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses the standard matplotlib.pyplot function (plt.plot) to render the data directly rather than using a high-level wrapper like pandas.plot() or seaborn. The chart displays quantitative values (scores) across a temporal dimension (weeks) for different categories (subjects), which aligns with the Line chart definition."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Plot: single chart with 3 subject trend lines over weeks\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2, label=\"Math\")\nplt.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2, label=\"Science\")\nplt.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2, label=\"English\")\n\nplt.title(\"Student Progress Over 12 Weeks\")\nplt.xlabel(\"Week\")\nplt.ylabel(\"Score\")\nplt.xticks(df[\"Week\"])\nplt.ylim(0, 100)\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard plt.plot() function from matplotlib to draw data points connected by lines, representing a sequence over time (Weeks). Following the hierarchy rules, since plt functions are used directly rather than seaborn or pandas wrappers, the library is classified as matplotlib."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Single chart: line chart showing scores over weeks\nplt.figure(figsize=(9, 5))\nplt.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2, label=\"Math\")\nplt.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2, label=\"Science\")\nplt.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2, label=\"English\")\n\nplt.title(\"Student Progress Over 12 Weeks\")\nplt.xlabel(\"Week\")\nplt.ylabel(\"Score\")\nplt.xticks(df[\"Week\"])\nplt.ylim(60, 100)\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using standard matplotlib.pyplot functions (plt.plot) rather than pandas or seaborn wrappers. The chart depicts quantitative scores across a temporal dimension (weeks), fitting the definition of a line chart."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Plot a single chart with three lines\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2, label=\"Math\")\nplt.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2, label=\"Science\")\nplt.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2, label=\"English\")\n\nplt.title(\"Student Progress Over 12 Weeks\")\nplt.xlabel(\"Week\")\nplt.ylabel(\"Score\")\nplt.xticks(df[\"Week\"])\nplt.ylim(60, 100)\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses the plt.plot() function from matplotlib to draw multiple lines representing score progress over a series of weeks. This fits the 'Line chart' taxonomy which uses temporal (Week), categorical (Subject labels), and quantitative (Scores) dimensions."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"11student_progress.csv\")\n\n    plt.figure(figsize=(10, 5))\n    plt.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2, label=\"Math\")\n    plt.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2, label=\"Science\")\n    plt.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2, label=\"English\")\n\n    plt.title(\"Student Progress Over 12 Weeks\")\n    plt.xlabel(\"Week\")\n    plt.ylabel(\"Score\")\n    plt.xticks(df[\"Week\"])\n    plt.grid(True, linestyle=\"--\", alpha=0.4)\n    plt.legend()\n    plt.tight_layout()\n\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard plt.plot() function from matplotlib to render quantitative data (scores) over a temporal dimension (weeks), which defines a Line chart."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Create a single chart: line plot of scores over weeks\nplt.figure(figsize=(10, 6))\nplt.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2, label=\"Math\")\nplt.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2, label=\"Science\")\nplt.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2, label=\"English\")\n\nplt.title(\"Student Progress Over 12 Weeks\")\nplt.xlabel(\"Week\")\nplt.ylabel(\"Score\")\nplt.xticks(df[\"Week\"])\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard matplotlib.pyplot functions (plt.plot) to render the data directly. It visualizes quantitative scores over a temporal dimension (Weeks), which corresponds to the Line chart definition."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"11student_progress.csv\")\n\n    plt.figure(figsize=(10, 6))\n    plt.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2, label=\"Math\")\n    plt.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2, label=\"Science\")\n    plt.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2, label=\"English\")\n\n    plt.title(\"Student Progress Over 12 Weeks\")\n    plt.xlabel(\"Week\")\n    plt.ylabel(\"Score\")\n    plt.xticks(df[\"Week\"])\n    plt.ylim(60, 100)\n    plt.grid(True, linestyle=\"--\", alpha=0.4)\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the `plt.plot()` function from the matplotlib library to plot scores over a temporal dimension (Week), which classifies it as a Line chart. No explicit color palette name was provided in the arguments."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos desde el CSV\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Crear un único gráfico de líneas con el progreso semanal por materia\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2, label=\"Matemáticas\")\nplt.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2, label=\"Ciencias\")\nplt.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2, label=\"Inglés\")\n\nplt.title(\"Progreso del estudiante por semana\")\nplt.xlabel(\"Semana\")\nplt.ylabel(\"Puntaje\")\nplt.xticks(df[\"Week\"])\nplt.grid(True, alpha=0.3)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly to render the data points rather than a dataframe wrapper, identifying it as matplotlib. The visualization maps student scores across a temporal/ordered sequence of weeks, fitting the 'Line chart' definition."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5), dpi=140)\n\nax.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2.2, label=\"Math\")\nax.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2.2, label=\"Science\")\nax.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2.2, label=\"English\")\n\nax.set_title(\"Student Progress Over 12 Weeks\", pad=12, fontsize=14, weight=\"semibold\")\nax.set_xlabel(\"Week\")\nax.set_ylabel(\"Score\")\nax.set_xticks(df[\"Week\"])\nax.set_ylim(60, 100)\n\nax.legend(title=\"Subject\", frameon=True, loc=\"upper left\")\nax.margins(x=0.02)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard Matplotlib axes method (ax.plot()) to render data, rather than Seaborn or Pandas wrappers. The visualization tracks multiple quantitative dimensions (scores) across a temporal dimension (Week), fitting the definition of a Line chart."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Plot setup\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5), dpi=120)\n\n# Lines\nax.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2.5, label=\"Math\")\nax.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2.5, label=\"Science\")\nax.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2.5, label=\"English\")\n\n# Labels & title\nax.set_title(\"Student Progress Over 12 Weeks\", fontsize=14, pad=10)\nax.set_xlabel(\"Week\")\nax.set_ylabel(\"Score\")\n\n# Axis formatting\nax.set_xticks(df[\"Week\"])\nax.set_ylim(60, 100)\n\n# Legend\nax.legend(title=\"Subject\", frameon=True, loc=\"upper left\")\n\n# Clean spines\nfor spine in [\"top\", \"right\"]:\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard matplotlib axes functions (ax.plot) to render the data rather than using pandas or seaborn wrappers. The chart plots quantitative scores over a temporal dimension (Week), which aligns with the Line chart definition."}}
{"input_csv_file": "11student_progress.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"11student_progress.csv\")\n\n# Plot: student progress over weeks (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5), dpi=120)\n\nax.plot(df[\"Week\"], df[\"Math_Score\"], marker=\"o\", linewidth=2.2, label=\"Math\")\nax.plot(df[\"Week\"], df[\"Science_Score\"], marker=\"o\", linewidth=2.2, label=\"Science\")\nax.plot(df[\"Week\"], df[\"English_Score\"], marker=\"o\", linewidth=2.2, label=\"English\")\n\nax.set_title(\"Student Progress Over 12 Weeks\", pad=10, fontsize=14, weight=\"semibold\")\nax.set_xlabel(\"Week\")\nax.set_ylabel(\"Score\")\n\nax.set_xticks(df[\"Week\"])\nax.set_ylim(60, 100)\n\nax.legend(title=\"Subject\", frameon=True)\nax.margins(x=0.02)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using the matplotlib library's `ax.plot()` function directly. It plots quantitative scores against a sequential/temporal variable (Week) for three different subjects (categories), which fits the definition of a Line chart."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\nCSV_PATH = \"13CAR DETAILS FROM CAR DEKHO.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\n# Aggregate: median selling price by fuel type (robust to outliers)\nfuel_median = (\n    df.groupby(\"fuel\", as_index=True)[\"selling_price\"]\n    .median()\n    .sort_values(ascending=False)\n)\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5.5))\n\nbars = ax.bar(fuel_median.index, fuel_median.values, color=\"#4C78A8\")\n\nax.set_title(\"Median Selling Price by Fuel Type\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Fuel Type\")\nax.set_ylabel(\"Median Selling Price (INR)\")\nax.yaxis.set_major_formatter(mtick.StrMethodFormatter(\"₹{x:,.0f}\"))\n\n# Value labels\nfor b in bars:\n    h = b.get_height()\n    ax.annotate(\n        f\"₹{h:,.0f}\",\n        xy=(b.get_x() + b.get_width() / 2, h),\n        xytext=(0, 6),\n        textcoords=\"offset points\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib axes function `ax.bar()`. Since `ax.bar()` produces vertical bars by default and maps a categorical variable (fuel type) to a quantitative one (median selling price), it is classified as a Column chart. A specific hex color was used for the bars rather than a named color palette."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\nfile_path = \"13CAR DETAILS FROM CAR DEKHO.csv\"\ndf = pd.read_csv(file_path)\n\n# Plot: Selling price distribution by fuel type (simple comparison)\nplt.figure(figsize=(10, 5))\nsns.boxplot(data=df, x=\"fuel\", y=\"selling_price\", palette=\"Set2\")\nsns.stripplot(data=df, x=\"fuel\", y=\"selling_price\", color=\"black\", alpha=0.45, jitter=0.2, size=3)\n\nplt.title(\"Selling Price by Fuel Type (CarDekho sample)\")\nplt.xlabel(\"Fuel Type\")\nplt.ylabel(\"Selling Price\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Box plot", "color_palette": "Set2", "reasoning": "The data is rendered using the seaborn library (sns.boxplot and sns.stripplot). The primary visualization is a box plot which analyzes the distribution of the quantitative 'selling_price' across categorical 'fuel' types."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\nfile_path = \"13CAR DETAILS FROM CAR DEKHO.csv\"\ndf = pd.read_csv(file_path)\n\n# Simple aggregation (Curcio \"read the data\" level): average selling price by fuel type\navg_price_by_fuel = (\n    df.groupby(\"fuel\", dropna=False)[\"selling_price\"]\n      .mean()\n      .sort_values(ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(9, 5))\nbars = plt.bar(avg_price_by_fuel.index.astype(str), avg_price_by_fuel.values, color=\"#4C78A8\")\n\nplt.title(\"Average Selling Price by Fuel Type\")\nplt.xlabel(\"Fuel Type\")\nplt.ylabel(\"Average Selling Price\")\n\n# Add value labels on bars\nfor b in bars:\n    y = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, y, f\"{y:,.0f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using the standard `plt.bar()` function from the matplotlib library to render vertical bars. Based on the taxonomy, vertical bars represent a 'Column chart'. Although a specific hex color is used, there is no named palette provided."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"13CAR DETAILS FROM CAR DEKHO.csv\"\ndf = pd.read_csv(csv_path)\n\n# Prepare summary: average selling price by fuel type\nfuel_avg = (\n    df.groupby(\"fuel\", dropna=False)[\"selling_price\"]\n    .mean()\n    .sort_values(ascending=False)\n)\n\n# Plot (single chart)\nplt.figure(figsize=(9, 5))\nplt.bar(fuel_avg.index.astype(str), fuel_avg.values, color=\"#4C78A8\")\n\nplt.title(\"Average Selling Price by Fuel Type\")\nplt.xlabel(\"Fuel Type\")\nplt.ylabel(\"Average Selling Price\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib function `plt.bar()` to draw data, which creates vertical bars, classifying it as a Column chart. Although a specific hex color is used, no named color palette is specified."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\nCSV_PATH = \"13CAR DETAILS FROM CAR DEKHO.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\n# Aggregate: average selling price by year\nyearly = (\n    df.groupby(\"year\", as_index=False)[\"selling_price\"]\n    .mean()\n    .sort_values(\"year\")\n)\n\nfig, ax = plt.subplots(figsize=(10, 5))\nax.plot(yearly[\"year\"], yearly[\"selling_price\"], marker=\"o\", linewidth=2)\n\nax.set_title(\"Average Car Selling Price by Year\")\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Average Selling Price\")\nax.yaxis.set_major_formatter(mtick.StrMethodFormatter(\"{x:,.0f}\"))\nax.grid(True, which=\"major\", axis=\"both\", alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using ax.plot() which is a direct matplotlib function for rendering data. According to the hierarchy rules, since no seaborn or pandas plotting methods were used to draw the data, the library is matplotlib. The chart plots a temporal/ordered variable (year) against a quantitative variable (average price), fitting the definition of a Line chart."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nCSV_PATH = \"13CAR DETAILS FROM CAR DEKHO.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\n# Single chart: Selling price distribution by fuel type (box + jittered points)\nplt.figure(figsize=(10, 5.5))\nsns.set_style(\"whitegrid\")\n\norder = (\n    df.groupby(\"fuel\")[\"selling_price\"]\n    .median()\n    .sort_values(ascending=False)\n    .index\n)\n\nax = sns.boxplot(\n    data=df,\n    x=\"fuel\",\n    y=\"selling_price\",\n    order=order,\n    showfliers=False,\n    width=0.55,\n    color=\"#8ecae6\",\n)\n\nsns.stripplot(\n    data=df,\n    x=\"fuel\",\n    y=\"selling_price\",\n    order=order,\n    color=\"#023047\",\n    size=4,\n    jitter=0.25,\n    alpha=0.65,\n)\n\nax.set_title(\"Selling Price by Fuel Type (CarDekho sample, n=69)\")\nax.set_xlabel(\"Fuel\")\nax.set_ylabel(\"Selling Price\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Box plot", "color_palette": null, "reasoning": "The code uses Seaborn's sns.boxplot() as the primary visualization method to display data distributions across categories (fuel types). Per the hierarchy rules, use of sns. functions classifies the library as 'seaborn'. Although specific hex colors are used for individual elements, no named color palette was specified."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ncsv_path = \"13CAR DETAILS FROM CAR DEKHO.csv\"\ndf = pd.read_csv(csv_path)\n\n# Single chart: Selling price distribution by fuel type (boxplot)\norder = df.groupby(\"fuel\")[\"selling_price\"].median().sort_values().index\n\nplt.figure(figsize=(9, 5))\nplt.boxplot(\n    [df.loc[df[\"fuel\"] == f, \"selling_price\"].values for f in order],\n    tick_labels=list(order),\n    showfliers=False,\n)\nplt.title(\"Selling Price by Fuel Type\")\nplt.xlabel(\"Fuel\")\nplt.ylabel(\"Selling Price\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Box plot", "color_palette": null, "reasoning": "Used the matplotlib function plt.boxplot() directly to render a distribution analysis across categorical fuel types."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    csv_path = \"13CAR DETAILS FROM CAR DEKHO.csv\"\n    df = pd.read_csv(csv_path)\n\n    # 单个图表：不同燃料类型的平均售价（并显示样本量）\n    grp = (\n        df.groupby(\"fuel\")[\"selling_price\"]\n        .agg(avg_price=\"mean\", count=\"size\")\n        .sort_values(\"avg_price\", ascending=False)\n    )\n\n    fig, ax = plt.subplots(figsize=(9, 5))\n    bars = ax.bar(grp.index, grp[\"avg_price\"], color=\"#4C78A8\")\n\n    ax.set_title(\"不同燃料类型的平均售价（selling_price）\")\n    ax.set_xlabel(\"燃料类型 (fuel)\")\n    ax.set_ylabel(\"平均售价\")\n\n    # 标注样本量与均价\n    ymax = grp[\"avg_price\"].max()\n    for b, (fuel, row) in zip(bars, grp.iterrows()):\n        ax.text(\n            b.get_x() + b.get_width() / 2,\n            b.get_height() + ymax * 0.02,\n            f\"n={int(row['count'])}\\n{row['avg_price']:.0f}\",\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=9,\n        )\n\n    ax.set_ylim(0, ymax * 1.18)\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using the standard matplotlib function `ax.bar()`. Because the bars are oriented vertically, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\ncsv_path = Path(\"13CAR DETAILS FROM CAR DEKHO.csv\")\ndf = pd.read_csv(csv_path)\n\n# Promedio de precio de venta por tipo de combustible\navg_price_by_fuel = (\n    df.groupby(\"fuel\", as_index=True)[\"selling_price\"]\n      .mean()\n      .sort_values(ascending=False)\n)\n\nplt.figure(figsize=(9, 5))\navg_price_by_fuel.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Precio promedio de venta por tipo de combustible\")\nplt.xlabel(\"Combustible\")\nplt.ylabel(\"Precio promedio (selling_price)\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is generated using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, even though matplotlib is used for styling, the rendering method makes the library 'pandas'. Since the bars are vertical, it is classified as a Column chart."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom matplotlib.ticker import FuncFormatter\n\nCSV_PATH = \"13CAR DETAILS FROM CAR DEKHO.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\n# Basic cleaning / typing safeguards\ndf[\"year\"] = pd.to_numeric(df[\"year\"], errors=\"coerce\")\ndf[\"selling_price\"] = pd.to_numeric(df[\"selling_price\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"year\", \"selling_price\", \"fuel\"])\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 6.2))\n\npalette = {\n    \"Petrol\": \"#1f77b4\",\n    \"Diesel\": \"#ff7f0e\",\n    \"CNG\": \"#2ca02c\",\n    \"LPG\": \"#d62728\",\n    \"Electric\": \"#9467bd\",\n}\n\nsns.scatterplot(\n    data=df,\n    x=\"year\",\n    y=\"selling_price\",\n    hue=\"fuel\",\n    palette=palette,\n    s=70,\n    alpha=0.85,\n    edgecolor=\"white\",\n    linewidth=0.6,\n    ax=ax,\n)\n\nax.set_title(\"Selling Price vs Year (colored by Fuel type)\", pad=10, weight=\"bold\")\nax.set_xlabel(\"Model Year\")\nax.set_ylabel(\"Selling Price (INR)\")\n\nax.yaxis.set_major_formatter(FuncFormatter(lambda v, pos: f\"₹{v/1e5:.1f}L\" if v >= 1e5 else f\"₹{int(v):,}\"))\nax.set_xlim(df[\"year\"].min() - 0.5, df[\"year\"].max() + 0.5)\n\nleg = ax.legend(title=\"Fuel\", frameon=True, borderpad=0.6)\nfor lh in leg.legendHandles:\n    try:\n        lh.set_alpha(1)\n    except Exception:\n        pass\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using the sns.scatterplot function, which maps two numerical variables ('year' and 'selling_price') to the X and Y axes. A custom dictionary was used for the palette instead of a named preset."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ncsv_path = \"13CAR DETAILS FROM CAR DEKHO.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate: median selling price by fuel type (robust to outliers)\nsummary = (\n    df.groupby(\"fuel\", as_index=False)\n      .agg(median_price=(\"selling_price\", \"median\"),\n           count=(\"selling_price\", \"size\"))\n      .sort_values(\"median_price\", ascending=False)\n)\n\n# Plot (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\nbars = ax.bar(summary[\"fuel\"], summary[\"median_price\"], color=\"#2E86AB\", edgecolor=\"#1B4F72\", linewidth=0.8)\n\ndef inr_format(x, pos):\n    x = int(round(x))\n    return f\"₹{x/1_00_000:.1f}L\" if x >= 1_00_000 else f\"₹{x/1_000:.0f}K\"\n\nax.yaxis.set_major_formatter(FuncFormatter(inr_format))\n\nax.set_title(\"Median Selling Price by Fuel Type\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Fuel Type\")\nax.set_ylabel(\"Median Selling Price\")\n\n# Label bars with counts (n)\nfor b, n in zip(bars, summary[\"count\"]):\n    ax.text(\n        b.get_x() + b.get_width() / 2,\n        b.get_height(),\n        f\"n={n}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=10,\n        color=\"#1B2631\",\n        clip_on=False\n    )\n\nax.set_ylim(0, max(summary[\"median_price\"]) * 1.18)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using the standard Matplotlib axes function ax.bar() which renders vertical bars, making it a Column chart. Although the style 'seaborn-v0_8-whitegrid' is applied, the library is matplotlib because seaborn plotting functions (sns.*) or pandas plotting wrappers were not used."}}
{"input_csv_file": "13CAR DETAILS FROM CAR DEKHO.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\n# --- Load data ---\ncsv_path = Path(\"13CAR DETAILS FROM CAR DEKHO.csv\")\ndf = pd.read_csv(csv_path)\n\n# --- Prep ---\n# Keep essentials and drop missing\ndf = df[[\"year\", \"selling_price\", \"fuel\"]].dropna()\n\n# Median selling price by year & fuel (more stable than mean for small samples)\ng = (\n    df.groupby([\"year\", \"fuel\"], as_index=False)[\"selling_price\"]\n      .median()\n      .rename(columns={\"selling_price\": \"median_selling_price\"})\n)\n\n# Pivot for plotting multiple lines\npivot = g.pivot(index=\"year\", columns=\"fuel\", values=\"median_selling_price\").sort_index()\n\n# --- Plot: single chart ---\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 6.2))\n\nfor fuel in pivot.columns:\n    ax.plot(\n        pivot.index,\n        pivot[fuel],\n        marker=\"o\",\n        linewidth=2.2,\n        markersize=5.5,\n        label=fuel,\n    )\n\nax.set_title(\"Median Selling Price by Model Year (split by Fuel)\", pad=12, fontsize=14, weight=\"semibold\")\nax.set_xlabel(\"Model Year\")\nax.set_ylabel(\"Median Selling Price (INR)\")\nax.ticklabel_format(style=\"plain\", axis=\"y\")\n\n# Improve readability for sparse years\nax.set_xticks(sorted(pivot.index.unique()))\nax.legend(title=\"Fuel\", frameon=True, loc=\"upper left\")\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using ax.plot() in a loop, which is a standard matplotlib.axes function. Although the code uses pandas for data manipulation and a seaborn style sheet, the actual drawing call is made through matplotlib."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"13data.csv\")\n\n# Plot\nplt.figure(figsize=(8, 4.5))\nplt.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\")\nplt.title(\"Population by Age Group\")\nplt.xlabel(\"Age group\")\nplt.ylabel(\"Population\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data as vertical bars, which classifies it as a Column chart. Because it calls matplotlib's pyplot function rather than seaborn or pandas plotting methods, the library is classified as matplotlib."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"13data.csv\")\n\n# Plot (single chart)\nplt.figure(figsize=(9, 5))\nplt.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\")\nplt.title(\"Population by Age Group\")\nplt.xlabel(\"Age group\")\nplt.ylabel(\"Population\")\nplt.xticks(rotation=0)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C78A8", "reasoning": "The data is rendered using plt.bar() directly, which classifies the library as matplotlib according to the hierarchy rules. Since plt.bar() produces vertical bars, it is classified as a Column chart."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"13data.csv\")\n\n# Create chart\nplt.figure(figsize=(10, 5))\nplt.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\")\nplt.title(\"Population by Age Group\")\nplt.xlabel(\"Age group\")\nplt.ylabel(\"Population\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib.pyplot function 'plt.bar()', which creates vertical bars. Per the hierarchy rules, since no seaborn or pandas plotting methods were used, the library is classified as matplotlib."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"13data.csv\")\n\n# Plot\nfig, ax = plt.subplots(figsize=(9, 5))\nax.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\")\n\nax.set_title(\"Population by Age Group\")\nax.set_xlabel(\"Age group\")\nax.set_ylabel(\"Population\")\nax.tick_params(axis=\"x\", rotation=0)\n\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the matplotlib axes method ax.bar() to render the data directly. Based on the taxonomy, vertical bars are classified as a Column chart rather than a bar chart (which is reserved for horizontal layouts)."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"13data.csv\")\n    df[\"age\"] = df[\"age\"].astype(str).str.strip()\n\n    plt.figure(figsize=(9, 5))\n    plt.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\")\n    plt.title(\"Population by Age Group\")\n    plt.xlabel(\"Age group\")\n    plt.ylabel(\"Population\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, which identifies the library as matplotlib. Since plt.bar() generates vertical bars by default, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.read_csv(\"13data.csv\")\n\nplt.figure(figsize=(9, 5))\nplt.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\")\nplt.title(\"Population by Age Group\")\nplt.xlabel(\"Age group\")\nplt.ylabel(\"Population\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the plt.bar() function directly from matplotlib to render vertical bars, which fits the 'Column chart' definition in the taxonomy. A single hex color is specified rather than a named palette."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"13data.csv\")\n\n    plt.figure(figsize=(9, 5))\n    plt.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\")\n    plt.title(\"Population by Age Group\")\n    plt.xlabel(\"Age group\")\n    plt.ylabel(\"Population\")\n    plt.xticks(rotation=0)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using the plt.bar() function from the matplotlib library. Following the provided taxonomy, vertical bars are classified as a 'Column chart'. Since the data is rendered directly via pyplot and not through pandas .plot() or seaborn, the library is matplotlib."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Read data\ndf = pd.read_csv(\"13data.csv\")\n\n# Ensure correct order of age groups\nage_order = [\"<5\", \"5-13\", \"14-17\", \"18-24\", \"25-44\", \"45-64\", \"≥65\"]\ndf[\"age\"] = df[\"age\"].astype(str).str.strip()\ndf[\"age\"] = pd.Categorical(df[\"age\"], categories=age_order, ordered=True)\ndf = df.sort_values(\"age\")\n\n# Plot single chart\nplt.figure(figsize=(9, 4.8))\nplt.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\")\nplt.title(\"Population by Age Group\")\nplt.xlabel(\"Age group\")\nplt.ylabel(\"Population\")\nplt.xticks(rotation=0)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render vertical bars representing population by age group. Following the hierarchy rules, because data is drawn with a standard pyplot function rather than sns or a pandas wrapper, the library is 'matplotlib'. Since the bars are vertical, it is classified as a 'Column chart'."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"13data.csv\")\n\n# Asegurar orden lógico de las categorías de edad\norder = [\"<5\", \"5-13\", \"14-17\", \"18-24\", \"25-44\", \"45-64\", \"≥65\"]\ndf[\"age\"] = pd.Categorical(df[\"age\"].astype(str).str.strip(), categories=order, ordered=True)\ndf = df.sort_values(\"age\")\n\n# Gráfico (un solo chart)\nplt.figure(figsize=(9, 4.8))\nplt.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\")\nplt.title(\"Población por grupo de edad\")\nplt.xlabel(\"Grupo de edad\")\nplt.ylabel(\"Población\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is generated using the standard plt.bar() function from matplotlib, which creates vertical bars. Since the bars are vertical and represent categorical and quantitative variables, it is classified as a Column chart."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"13data.csv\")\n\n# Ensure intended ordering\nage_order = [\"<5\", \"5-13\", \"14-17\", \"18-24\", \"25-44\", \"45-64\", \"≥65\"]\ndf[\"age\"] = pd.Categorical(df[\"age\"], categories=age_order, ordered=True)\ndf = df.sort_values(\"age\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5))\n\nbars = ax.bar(df[\"age\"], df[\"population\"], color=\"#2E86AB\", edgecolor=\"#1B4F72\", linewidth=0.8)\n\nax.set_title(\"Population by Age Group\", pad=10, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Age group\")\nax.set_ylabel(\"Population\")\nax.tick_params(axis=\"x\", rotation=0)\n\n# Format y-axis with commas\nax.get_yaxis().set_major_formatter(lambda x, pos: f\"{int(x):,}\")\n\n# Add value labels\nfor b in bars:\n    h = b.get_height()\n    ax.annotate(f\"{int(h):,}\",\n                (b.get_x() + b.get_width() / 2, h),\n                xytext=(0, 6),\n                textcoords=\"offset points\",\n                ha=\"center\", va=\"bottom\",\n                fontsize=9, color=\"#0B1F2A\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses `ax.bar()` to render data directly from matplotlib. Since `ax.bar()` creates vertical bars (as opposed to `ax.barh()`), it is classified as a Column chart. While a hex color is provided, no named palette (e.g., 'viridis') is used."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"13data.csv\")\n\n# Ensure the intended order (as in the CSV)\ndf[\"age\"] = pd.Categorical(df[\"age\"], categories=list(df[\"age\"]), ordered=True)\ndf = df.sort_values(\"age\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5.2))\n\nbars = ax.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\", edgecolor=\"white\", linewidth=1)\n\n# Formatting\nax.set_title(\"Population by Age Group\", pad=12, weight=\"semibold\")\nax.set_xlabel(\"Age group\")\nax.set_ylabel(\"Population\")\n\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"{x/1e6:.1f}M\" if x >= 1e6 else f\"{int(x):,}\"))\nax.set_ylim(0, df[\"population\"].max() * 1.12)\n\n# Value labels\nfor b in bars:\n    h = b.get_height()\n    ax.text(\n        b.get_x() + b.get_width() / 2,\n        h,\n        f\"{h:,}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n        color=\"#1f2d3d\",\n        rotation=0,\n        clip_on=False,\n    )\n\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using the matplotlib library's `ax.bar()` function. Because the bars are oriented vertically with categorical labels on the x-axis and quantitative values on the y-axis, it is classified as a Column chart. A specific hex color code ('#4C78A8') was used instead of a named color palette."}}
{"input_csv_file": "13data.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"13data.csv\")\n\n# Ensure the intended order\nage_order = [\"<5\", \"5-13\", \"14-17\", \"18-24\", \"25-44\", \"45-64\", \"≥65\"]\ndf[\"age\"] = pd.Categorical(df[\"age\"], categories=age_order, ordered=True)\ndf = df.sort_values(\"age\")\n\n# Plot: single chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 4.8))\n\nbars = ax.bar(df[\"age\"], df[\"population\"], color=\"#4C78A8\", width=0.7)\n\nax.set_title(\"Population by Age Group\", pad=10, weight=\"bold\")\nax.set_xlabel(\"Age group\")\nax.set_ylabel(\"Population\")\n\nax.ticklabel_format(style=\"plain\", axis=\"y\")\nax.margins(x=0.02)\n\n# Value labels (compact, readable)\nfor b in bars:\n    h = b.get_height()\n    ax.annotate(\n        f\"{h:,}\",\n        (b.get_x() + b.get_width() / 2, h),\n        xytext=(0, 4),\n        textcoords=\"offset points\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n        color=\"#2F2F2F\",\n    )\n\nfor spine in (\"top\", \"right\"):\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the ax.bar() function from matplotlib. Since the bars are oriented vertically, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"13Global YouTube Statistics.csv\"\n\ndef main():\n    df = pd.read_csv(CSV_PATH)\n\n    # Clean/prepare\n    df[\"Country\"] = df[\"Country\"].fillna(\"Unknown\")\n    df[\"subscribers\"] = pd.to_numeric(df[\"subscribers\"], errors=\"coerce\")\n\n    # Aggregate: total subscribers by country, then take top 10\n    top = (\n        df.dropna(subset=[\"subscribers\"])\n          .groupby(\"Country\", as_index=False)[\"subscribers\"].sum()\n          .sort_values(\"subscribers\", ascending=False)\n          .head(10)\n    )\n\n    # Plot: single chart\n    plt.figure(figsize=(11, 6))\n    plt.barh(top[\"Country\"], top[\"subscribers\"] / 1e6, color=\"#1f77b4\")\n    plt.gca().invert_yaxis()\n    plt.title(\"Top 10 Countries by Total Subscribers (Dataset: Top 50 YouTubers)\")\n    plt.xlabel(\"Total Subscribers (Millions)\")\n    plt.ylabel(\"Country\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization uses the matplotlib library directly via plt.barh() to create horizontal bars, which classifies it as a 'Bar chart' according to the taxonomy."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ncsv_path = \"13Global YouTube Statistics.csv\"\ndf = pd.read_csv(csv_path)\n\n# Prepare: Top 10 by subscribers\ntop10 = (\n    df[[\"Youtuber\", \"subscribers\"]]\n    .dropna()\n    .sort_values(\"subscribers\", ascending=False)\n    .head(10)\n    .sort_values(\"subscribers\", ascending=True)\n)\n\n# Plot: horizontal bar chart\nfig, ax = plt.subplots(figsize=(10, 6))\nax.barh(top10[\"Youtuber\"], top10[\"subscribers\"], color=\"#4C78A8\")\n\nax.set_title(\"Top 10 YouTube Channels by Subscribers\", pad=12)\nax.set_xlabel(\"Subscribers\")\nax.set_ylabel(\"Channel\")\n\nax.xaxis.set_major_formatter(mtick.FuncFormatter(lambda x, pos: f\"{x/1e6:.0f}M\"))\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.3)\nax.set_axisbelow(True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.barh()` function directly to render data as horizontal bars, which identifies the library as matplotlib and the chart type as a Bar chart according to the provided taxonomy."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ncsv_path = \"13Global YouTube Statistics.csv\"\ndf = pd.read_csv(csv_path)\n\n# Clean + select\ndf = df.dropna(subset=[\"Country\", \"subscribers\"]).copy()\ndf[\"subscribers\"] = pd.to_numeric(df[\"subscribers\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"subscribers\"])\n\n# Aggregate: total subscribers by country\ncountry_subs = (\n    df.groupby(\"Country\", as_index=True)[\"subscribers\"]\n      .sum()\n      .sort_values(ascending=False)\n)\n\ntop_n = 10\nplot_data = country_subs.head(top_n).sort_values(ascending=True)  # ascending for horizontal bar order\n\n# Plot (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nax.barh(plot_data.index, plot_data.values, color=\"#2E86AB\")\n\nax.set_title(f\"Total Subscribers by Country (Top {top_n})\\nfrom '13Global YouTube Statistics.csv' (Top 50 channels)\")\nax.set_xlabel(\"Total subscribers\")\nax.set_ylabel(\"Country\")\n\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{x/1e6:.0f}M\"))\n\n# Value labels\nfor y, v in enumerate(plot_data.values):\n    ax.text(v, y, f\"  {v/1e6:.0f}M\", va=\"center\", ha=\"left\", fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the Matplotlib function `ax.barh()` to render horizontal bars directly, which classifies it as a 'Bar chart' according to the taxonomy (horizontal layout). Since it uses standard matplotlib axes methods rather than seaborn or pandas wrappers, the library is 'matplotlib'."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"13Global YouTube Statistics.csv\"\ndf = pd.read_csv(csv_path)\n\n# Prepare: top 10 by subscribers\ntop10 = df.sort_values(\"subscribers\", ascending=False).head(10).copy()\ntop10[\"subscribers_m\"] = top10[\"subscribers\"] / 1_000_000\n\n# Plot: single chart (bar)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nax.barh(top10[\"Youtuber\"], top10[\"subscribers_m\"], color=\"#4C78A8\")\nax.invert_yaxis()\n\nax.set_title(\"Top 10 YouTube Channels by Subscribers\", pad=10)\nax.set_xlabel(\"Subscribers (millions)\")\nax.set_ylabel(\"Channel\")\n\n# Value labels\nfor y, v in enumerate(top10[\"subscribers_m\"]):\n    ax.text(v + 1, y, f\"{v:.1f}M\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is created using the matplotlib function `ax.barh()`, which generates horizontal bars. According to the taxonomy, horizontal layouts are classified as Bar charts, and since standard axes functions were used to draw the data, the library is matplotlib."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"13Global YouTube Statistics.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\n# Clean/ensure numeric\ndf[\"subscribers\"] = pd.to_numeric(df[\"subscribers\"], errors=\"coerce\")\n\n# Top 10 by subscribers\ntop = (\n    df.dropna(subset=[\"subscribers\", \"Youtuber\"])\n      .sort_values(\"subscribers\", ascending=False)\n      .head(10)\n      .iloc[::-1]  # reverse for horizontal bar (largest at top)\n)\n\nplt.figure(figsize=(10, 6))\nplt.barh(top[\"Youtuber\"], top[\"subscribers\"] / 1e6, color=\"#4C78A8\")\nplt.title(\"Top 10 YouTube Channels by Subscribers\")\nplt.xlabel(\"Subscribers (millions)\")\nplt.ylabel(\"Channel\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses plt.barh() directly to render the data, which identifies the library as matplotlib and the chart type as a Bar chart (horizontal bars)."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\ndef main():\n    csv_path = \"13Global YouTube Statistics.csv\"\n    df = pd.read_csv(csv_path)\n\n    # Clean and aggregate\n    df[\"Country\"] = df[\"Country\"].fillna(\"Unknown\")\n    country_subs = (\n        df.groupby(\"Country\", as_index=False)[\"subscribers\"]\n        .sum()\n        .sort_values(\"subscribers\", ascending=False)\n        .head(10)\n    )\n\n    # Plot: Top 10 countries by total subscribers (in this dataset)\n    plt.figure(figsize=(11, 6))\n    plt.barh(country_subs[\"Country\"], country_subs[\"subscribers\"], color=\"#4C78A8\")\n    plt.gca().invert_yaxis()\n\n    plt.title(\"Top 10 Countries by Total Subscribers (Top 50 YouTubers Dataset)\")\n    plt.xlabel(\"Total Subscribers\")\n    plt.ylabel(\"Country\")\n\n    plt.gca().xaxis.set_major_formatter(\n        mtick.FuncFormatter(lambda x, pos: f\"{x/1e6:.0f}M\" if x >= 1e6 else f\"{x:.0f}\")\n    )\n\n    for i, v in enumerate(country_subs[\"subscribers\"].values):\n        label = f\"{v/1e6:.1f}M\" if v >= 1e6 else f\"{v:.0f}\"\n        plt.text(v, i, f\"  {label}\", va=\"center\", ha=\"left\", fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is rendered using `plt.barh()`, which is a standard matplotlib function for creating horizontal bars. Following the taxonomy, horizontal bars are classified as a 'Bar chart' and vertical bars as a 'Column chart'."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    csv_path = \"13Global YouTube Statistics.csv\"\n    df = pd.read_csv(csv_path)\n\n    # Top 10 by subscribers\n    top = df.sort_values(\"subscribers\", ascending=False).head(10).copy()\n    top[\"subscribers_m\"] = top[\"subscribers\"] / 1_000_000\n\n    plt.style.use(\"seaborn-v0_8-whitegrid\")\n    fig, ax = plt.subplots(figsize=(12, 6))\n\n    ax.barh(top[\"Youtuber\"], top[\"subscribers_m\"], color=\"#4C78A8\")\n    ax.invert_yaxis()\n    ax.set_title(\"Top 10 YouTubers by Subscribers\", pad=10)\n    ax.set_xlabel(\"Subscribers (Millions)\")\n    ax.set_ylabel(\"Youtuber\")\n\n    # value labels\n    for y, v in enumerate(top[\"subscribers_m\"]):\n        ax.text(v + 0.5, y, f\"{v:.1f}M\", va=\"center\", fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The data is rendered using the ax.barh() method from the matplotlib library. Since the bars are horizontal, it is classified as a Bar chart according to the taxonomy."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\nCSV_PATH = Path(\"13Global YouTube Statistics.csv\")\n\ndef main():\n    df = pd.read_csv(CSV_PATH)\n\n    # Clean/prepare\n    df[\"category\"] = df[\"category\"].fillna(\"Unknown\").astype(str).str.strip()\n    df[\"subscribers\"] = pd.to_numeric(df[\"subscribers\"], errors=\"coerce\")\n    df = df.dropna(subset=[\"subscribers\"])\n\n    # Aggregate: total subscribers by category, take top 10 for readability\n    cat_subs = (\n        df.groupby(\"category\", dropna=False)[\"subscribers\"]\n        .sum()\n        .sort_values(ascending=False)\n        .head(10)\n        .sort_values(ascending=True)\n    )\n\n    # Plot: single chart\n    plt.figure(figsize=(10, 6))\n    bars = plt.barh(cat_subs.index, cat_subs.values / 1e6, color=\"#4C78A8\")\n    plt.title(\"Top 10 Categories by Total Subscribers (Millions)\")\n    plt.xlabel(\"Total Subscribers (Millions)\")\n    plt.ylabel(\"Category\")\n\n    # Value labels\n    for b in bars:\n        w = b.get_width()\n        plt.text(w + 0.5, b.get_y() + b.get_height() / 2, f\"{w:.1f}\", va=\"center\", fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization uses 'plt.barh()' directly to render horizontal bars, which classifies the library as matplotlib and the chart type as a 'Bar chart' according to the taxonomy."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"13Global YouTube Statistics.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\ntop = (\n    df[[\"Youtuber\", \"subscribers\"]]\n    .dropna(subset=[\"Youtuber\", \"subscribers\"])\n    .sort_values(\"subscribers\", ascending=False)\n    .head(10)\n    .iloc[::-1]\n)\n\nplt.figure(figsize=(12, 7))\nplt.barh(top[\"Youtuber\"], top[\"subscribers\"] / 1e6, color=\"#1f77b4\")\nplt.title(\"Top 10 canales por suscriptores (millones)\")\nplt.xlabel(\"Suscriptores (M)\")\nplt.ylabel(\"Canal\")\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard pyplot function plt.barh() to render the data, which identifies the library as matplotlib. Because plt.barh() generates horizontal bars representing categorical Youtuber names against quantitative subscriber counts, it is classified as a Bar chart."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# --- Load data ---\npath = \"13Global YouTube Statistics.csv\"\ndf = pd.read_csv(path)\n\n# --- Prep: top 15 by subscribers ---\ntop_n = 15\nd = (\n    df[[\"Youtuber\", \"subscribers\", \"Country\"]]\n    .copy()\n    .dropna(subset=[\"Youtuber\", \"subscribers\"])\n)\nd[\"Country\"] = d[\"Country\"].fillna(\"Unknown\")\nd = d.sort_values(\"subscribers\", ascending=False).head(top_n)\n\n# --- Plot: horizontal bar chart ---\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 7))\n\nlabels = [f\"{y} ({c})\" for y, c in zip(d[\"Youtuber\"], d[\"Country\"])]\nax.barh(labels[::-1], d[\"subscribers\"].values[::-1], color=\"#2a6fdb\")\n\nax.set_title(f\"Top {top_n} YouTube Channels by Subscribers\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Subscribers\")\nax.set_ylabel(\"\")\n\nax.xaxis.set_major_formatter(mtick.FuncFormatter(lambda x, pos: f\"{int(x/1_000_000)}M\"))\n\n# annotate values\nfor i, v in enumerate(d[\"subscribers\"].values[::-1]):\n    ax.text(v + d[\"subscribers\"].max() * 0.01, i, f\"{v/1_000_000:.0f}M\", va=\"center\", fontsize=9)\n\nax.set_xlim(0, d[\"subscribers\"].max() * 1.18)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization is created using the matplotlib function ax.barh(), which specifically renders horizontal bars. Based on the taxonomy, horizontal bars are classified as 'Bar chart', while vertical ones are 'Column chart'. Since the data is rendered directly via matplotlib axes rather than pandas wrappers or seaborn, the library is classified as 'matplotlib'."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"13Global YouTube Statistics.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\n# Keep sensible rows (drop placeholders / missing countries)\nd = df[[\"Country\", \"subscribers\"]].dropna()\nd = d[d[\"Country\"].astype(str).str.strip().ne(\"\")]\n\n# Aggregate and take top countries by total subscribers\ntop = (\n    d.groupby(\"Country\", as_index=False)[\"subscribers\"]\n    .sum()\n    .sort_values(\"subscribers\", ascending=False)\n    .head(10)\n    .sort_values(\"subscribers\", ascending=True)\n)\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nbars = ax.barh(top[\"Country\"], top[\"subscribers\"], color=\"#2a9d8f\")\n\nax.set_title(\"Top 10 Countries by Total Subscribers (Top 50 YouTubers)\", pad=12)\nax.set_xlabel(\"Total subscribers\")\nax.set_ylabel(\"Country\")\n\n# Format x-axis as millions\nax.xaxis.set_major_formatter(lambda x, pos: f\"{x/1e6:.0f}M\")\n\n# Value labels\nxmax = top[\"subscribers\"].max()\nfor b in bars:\n    w = b.get_width()\n    ax.text(w + 0.01 * xmax, b.get_y() + b.get_height() / 2, f\"{w/1e6:.1f}M\",\n            va=\"center\", ha=\"left\", fontsize=9, color=\"#1f2937\")\n\nax.set_xlim(0, xmax * 1.12)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.barh()` function to draw the data. According to the taxonomy, horizontal bars are classified as a 'Bar chart' and the library is 'matplotlib' because standard axes functions are used to render the visual elements directly."}}
{"input_csv_file": "13Global YouTube Statistics.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ncsv_path = \"13Global YouTube Statistics.csv\"\ndf = pd.read_csv(csv_path)\n\n# Clean and prepare\ndf = df.copy()\ndf[\"category\"] = df[\"category\"].fillna(\"Unknown\")\ndf = df[df[\"subscribers\"].notna()]\ndf[\"subscribers_m\"] = df[\"subscribers\"] / 1_000_000\n\n# Aggregate: total subscribers by category (top 10)\ncat = (\n    df.groupby(\"category\", as_index=False)[\"subscribers_m\"]\n    .sum()\n    .sort_values(\"subscribers_m\", ascending=False)\n    .head(10)\n)\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6.5))\n\nax.barh(cat[\"category\"][::-1], cat[\"subscribers_m\"][::-1], color=\"#1f77b4\")\nax.set_title(\"Top 10 YouTube Categories by Total Subscribers (Top 50 Channels)\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Total subscribers (millions)\")\nax.set_ylabel(\"Category\")\n\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"{x:,.0f}M\"))\n\n# Value labels\nfor i, v in enumerate(cat[\"subscribers_m\"][::-1].values):\n    ax.text(v + max(cat[\"subscribers_m\"]) * 0.01, i, f\"{v:,.0f}M\", va=\"center\", fontsize=9)\n\nax.set_xlim(0, max(cat[\"subscribers_m\"]) * 1.12)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is rendered using the `ax.barh()` method, which is a standard matplotlib function for creating horizontal bars. Following the taxonomy, horizontal bar visualizations are classified as 'Bar chart', while vertical ones are 'Column chart'."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"14_national_population_2025.csv\")\n\n# Ensure correct ordering of age ranges\nage_order = [\n    \"0-4\",\"5-9\",\"10-14\",\"15-19\",\"20-24\",\"25-29\",\"30-34\",\"35-39\",\n    \"40-44\",\"45-49\",\"50-54\",\"55-59\",\"60-64\",\"65-69\",\"70-74\",\"75-79\",\n    \"80-84\",\"85+\"\n]\ndf[\"Age_Range\"] = pd.Categorical(df[\"Age_Range\"], categories=age_order, ordered=True)\ndf = df.sort_values(\"Age_Range\")\n\n# Population pyramid data (male negative, female positive)\nmale = -df[\"Male_Population\"].values\nfemale = df[\"Female_Population\"].values\nages = df[\"Age_Range\"].astype(str).values\n\n# Plot\nfig, ax = plt.subplots(figsize=(10, 7))\nax.barh(ages, male, color=\"#4C78A8\", label=\"Male\")\nax.barh(ages, female, color=\"#F58518\", label=\"Female\")\n\n# Formatting\nmax_pop = max(df[\"Male_Population\"].max(), df[\"Female_Population\"].max())\nax.set_xlim(-max_pop * 1.15, max_pop * 1.15)\n\nxticks = ax.get_xticks()\nax.set_xticklabels([f\"{abs(int(x)):,}\" if x != 0 else \"0\" for x in xticks])\n\nax.axvline(0, color=\"black\", linewidth=0.8)\nax.set_title(\"National Population by Age Range and Sex (2025)\")\nax.set_xlabel(\"Population\")\nax.set_ylabel(\"Age Range\")\nax.legend(loc=\"lower right\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() to visualize population data across age ranges for two groups (male and female) positioned on either side of a central vertical axis, which fits the definition of a Pyramid chart."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_national_population_2025.csv\")\n\n# Ensure age groups stay in the given order\ndf[\"Age_Range\"] = pd.Categorical(df[\"Age_Range\"], categories=df[\"Age_Range\"].tolist(), ordered=True)\ndf = df.sort_values(\"Age_Range\")\n\nages = df[\"Age_Range\"].astype(str).tolist()\ny = np.arange(len(ages))\n\nmale = df[\"Male_Population\"].to_numpy()\nfemale = df[\"Female_Population\"].to_numpy()\n\n# Plot (population pyramid)\nfig, ax = plt.subplots(figsize=(10, 7))\n\nax.barh(y, -male, color=\"#4C78A8\", label=\"Male\")\nax.barh(y, female, color=\"#F58518\", label=\"Female\")\n\n# Center line\nax.axvline(0, color=\"black\", linewidth=0.8)\n\n# Labels and formatting\nax.set_yticks(y)\nax.set_yticklabels(ages)\n\nmax_pop = max(male.max(), female.max())\nax.set_xlim(-max_pop * 1.15, max_pop * 1.15)\n\nxticks = ax.get_xticks()\nax.set_xticklabels([f\"{abs(int(x)):,}\" for x in xticks])\n\nax.set_xlabel(\"Population\")\nax.set_title(\"National Population by Age Range and Sex (2025)\")\nax.legend(loc=\"lower right\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() directly to render a horizontal mirrored bar chart representing population age ranges and two quantitative variables (Male and Female), which fits the definition of a Pyramid chart."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"14_national_population_2025.csv\")\n\n# Ensure age ranges stay in the intended order as they appear in the file\ndf[\"Age_Range\"] = pd.Categorical(df[\"Age_Range\"], categories=df[\"Age_Range\"].tolist(), ordered=True)\ndf = df.sort_values(\"Age_Range\")\n\n# Population pyramid: males negative, females positive\nmale = -df[\"Male_Population\"]\nfemale = df[\"Female_Population\"]\nages = df[\"Age_Range\"]\n\nplt.figure(figsize=(10, 7))\nplt.barh(ages, male, label=\"Male\", color=\"#4C78A8\")\nplt.barh(ages, female, label=\"Female\", color=\"#F58518\")\n\nmax_pop = max(df[\"Male_Population\"].max(), df[\"Female_Population\"].max())\nplt.xlim(-max_pop * 1.15, max_pop * 1.15)\n\n# Show symmetric tick labels as positive numbers\nticks = plt.xticks()[0]\nplt.xticks(ticks, [f\"{abs(int(t)):,}\" for t in ticks])\n\nplt.axvline(0, color=\"black\", linewidth=0.8)\nplt.title(\"National Population by Age Range and Sex (2025)\")\nplt.xlabel(\"Population\")\nplt.ylabel(\"Age Range\")\nplt.legend(loc=\"lower right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The code uses matplotlib's plt.barh() directly to render horizontal bars representing male and female populations across age ranges, which fits the taxonomy for a Pyramid chart."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"14_national_population_2025.csv\")\n\n# Prepare values for a population pyramid (male left as negative, female right as positive)\nage = df[\"Age_Range\"]\nmale = -df[\"Male_Population\"]\nfemale = df[\"Female_Population\"]\n\n# Plot\nplt.figure(figsize=(10, 7))\nplt.barh(age, male, color=\"#4C78A8\", label=\"Male\")\nplt.barh(age, female, color=\"#F58518\", label=\"Female\")\n\n# Formatting\nmax_pop = max(df[\"Male_Population\"].max(), df[\"Female_Population\"].max())\nticks = [-20000, -15000, -10000, -5000, 0, 5000, 10000, 15000, 20000, 25000]\nplt.xticks(ticks, [f\"{abs(t):,}\" for t in ticks])\n\nplt.axvline(0, color=\"black\", linewidth=0.8)\nplt.title(\"National Population by Age Group and Sex (2025)\")\nplt.xlabel(\"Population\")\nplt.ylabel(\"Age Range\")\nplt.legend(loc=\"lower right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The code uses matplotlib.pyplot's barh() function to plot population data across age ranges (categorical) with two quantitative variables (male and female population), creating a population pyramid layout."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ncsv_path = \"14_national_population_2025.csv\"\ndf = pd.read_csv(csv_path)\n\n# Ensure correct order of age ranges (as given in the file)\ndf[\"Age_Range\"] = pd.Categorical(df[\"Age_Range\"], categories=df[\"Age_Range\"].tolist(), ordered=True)\ndf = df.sort_values(\"Age_Range\")\n\n# Prepare pyramid values (male negative, female positive)\nages = df[\"Age_Range\"].astype(str).tolist()\nmale = -df[\"Male_Population\"].to_numpy()\nfemale = df[\"Female_Population\"].to_numpy()\n\n# Plot\nfig, ax = plt.subplots(figsize=(10, 7))\nax.barh(ages, male, color=\"#4C78A8\", label=\"Male\")\nax.barh(ages, female, color=\"#F58518\", label=\"Female\")\n\n# Formatting\nmax_val = int(max(df[\"Male_Population\"].max(), df[\"Female_Population\"].max()))\nax.set_xlim(-max_val * 1.15, max_val * 1.15)\n\nxticks = ax.get_xticks()\nax.set_xticklabels([f\"{abs(int(x)):,}\" for x in xticks])\n\nax.axvline(0, color=\"black\", linewidth=0.8)\nax.set_title(\"National Population by Age Range and Sex (2025)\")\nax.set_xlabel(\"Population\")\nax.set_ylabel(\"Age Range\")\nax.legend(loc=\"lower right\", frameon=False)\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The plot uses matplotlib's 'ax.barh' directly to render data. It is classified as a 'Pyramid chart' because it visualizes population data across categorical age ranges and two quantitative gender variables (male and female) mirroring each other across a central axis."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"14_national_population_2025.csv\")\n\n# Ensure correct order (as given) and prepare population pyramid values\nage = df[\"Age_Range\"]\nmale = -df[\"Male_Population\"]      # negative for left side\nfemale = df[\"Female_Population\"]   # positive for right side\n\n# Plot\nfig, ax = plt.subplots(figsize=(9, 7))\nax.barh(age, male, color=\"#4C78A8\", label=\"Male\")\nax.barh(age, female, color=\"#F58518\", label=\"Female\")\n\n# Formatting\nmax_pop = max(df[\"Male_Population\"].max(), df[\"Female_Population\"].max())\nax.set_xlim(-max_pop * 1.15, max_pop * 1.15)\nax.axvline(0, color=\"black\", linewidth=0.8)\n\nticks = ax.get_xticks()\nax.set_xticklabels([f\"{abs(int(t)):,}\" for t in ticks])\n\nax.set_title(\"National Population by Age Range and Gender (2025)\")\nax.set_xlabel(\"Population\")\nax.set_ylabel(\"Age Range\")\nax.legend(loc=\"lower right\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The code uses Matplotlib's ax.barh() function directly to render data. It displays population data segmented by age ranges and gender (two quantitative dimensions) in a mirrored horizontal layout, which corresponds to the definition of a Pyramid chart."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"14_national_population_2025.csv\")\n\n    # Plot a population pyramid (single chart)\n    fig, ax = plt.subplots(figsize=(10, 7))\n\n    y = range(len(df))\n    male = -df[\"Male_Population\"]\n    female = df[\"Female_Population\"]\n\n    ax.barh(y, male, color=\"#4C78A8\", label=\"Male\")\n    ax.barh(y, female, color=\"#F58518\", label=\"Female\")\n\n    ax.set_yticks(list(y))\n    ax.set_yticklabels(df[\"Age_Range\"])\n    ax.set_xlabel(\"Population\")\n    ax.set_title(\"National Population by Age Range (2025)\")\n    ax.axvline(0, color=\"black\", linewidth=1)\n\n    # Make x-axis labels show positive numbers on both sides\n    xticks = ax.get_xticks()\n    ax.set_xticklabels([f\"{abs(int(t)):,}\" if t == int(t) else f\"{abs(t):,.0f}\" for t in xticks])\n\n    ax.legend(loc=\"lower right\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() directly to create a visualization of population data across age ranges for two groups (male and female), which fits the taxonomy definition of a Pyramid chart."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"14_national_population_2025.csv\"\ndf = pd.read_csv(csv_path)\n\n# Ensure ordering as in file (or sort by age bins if needed)\ndf[\"Age_Range\"] = df[\"Age_Range\"].astype(str)\n\n# Population pyramid (male on left as negative)\nmale = -df[\"Male_Population\"]\nfemale = df[\"Female_Population\"]\nages = df[\"Age_Range\"]\n\nfig, ax = plt.subplots(figsize=(9, 7))\n\nax.barh(ages, male, color=\"#4C78A8\", label=\"Male\")\nax.barh(ages, female, color=\"#F58518\", label=\"Female\")\n\n# Format x-axis to show positive values on both sides\nmax_pop = max(df[\"Male_Population\"].max(), df[\"Female_Population\"].max())\nax.set_xlim(-max_pop * 1.15, max_pop * 1.15)\n\nxticks = ax.get_xticks()\nax.set_xticklabels([f\"{abs(int(x)):,}\" for x in xticks])\n\nax.axvline(0, color=\"black\", linewidth=0.8)\nax.set_title(\"National Population by Age Range and Gender (2025)\")\nax.set_xlabel(\"Population\")\nax.set_ylabel(\"Age Range\")\nax.legend(loc=\"lower right\", frameon=False)\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"error": "JSON Parsing Failed: Expecting property name enclosed in double quotes: line 6 column 1 (char 336)", "raw_text": "{\n    \"library\": \"matplotlib\",\n    \"chart_type\": \"Pyramid chart\",\n    \"color_palette\": null,\n    \"reasoning\": \"The code uses matplotlib's ax.barh() to create a population pyramid by plotting male and female population counts on opposite sides of a central axis for specific age ranges, which aligns with the Pyramid chart definition.\",\n}"}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ncsv_path = \"14_national_population_2025.csv\"\ndf = pd.read_csv(csv_path)\n\n# Preparación para pirámide poblacional (hombres negativos para espejo)\ndf[\"Male_Neg\"] = -df[\"Male_Population\"]\n\n# Gráfico\nfig, ax = plt.subplots(figsize=(10, 7))\n\nax.barh(df[\"Age_Range\"], df[\"Male_Neg\"], color=\"#4C78A8\", label=\"Hombres\")\nax.barh(df[\"Age_Range\"], df[\"Female_Population\"], color=\"#F58518\", label=\"Mujeres\")\n\n# Formato: eje X con valores absolutos\nmax_pop = max(df[\"Male_Population\"].max(), df[\"Female_Population\"].max())\nax.set_xlim(-max_pop * 1.15, max_pop * 1.15)\n\nxticks = ax.get_xticks()\nax.set_xticklabels([f\"{abs(int(x)):,}\" for x in xticks])\n\nax.axvline(0, color=\"black\", linewidth=0.8)\nax.set_title(\"Pirámide poblacional nacional (2025)\")\nax.set_xlabel(\"Población\")\nax.set_ylabel(\"Rango de edad\")\nax.legend(loc=\"lower right\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() method to create a mirrored horizontal visualization of population data by age ranges and gender, which fits the 'Pyramid chart' definition."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ncsv_path = \"14_national_population_2025.csv\"\ndf = pd.read_csv(csv_path)\n\n# Preserve the given age order\ndf[\"Age_Range\"] = pd.Categorical(df[\"Age_Range\"], categories=df[\"Age_Range\"].tolist(), ordered=True)\ndf = df.sort_values(\"Age_Range\")\n\n# Prepare pyramid values (males negative, females positive)\nmale = -df[\"Male_Population\"].values\nfemale = df[\"Female_Population\"].values\nages = df[\"Age_Range\"].astype(str).values\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 7))\n\nax.barh(ages, male, color=\"#4C78A8\", alpha=0.9, label=\"Male\")\nax.barh(ages, female, color=\"#F58518\", alpha=0.9, label=\"Female\")\n\n# Formatting\nmax_pop = max(df[\"Male_Population\"].max(), df[\"Female_Population\"].max())\nax.set_xlim(-max_pop * 1.15, max_pop * 1.15)\n\nax.axvline(0, color=\"#333333\", linewidth=1)\nax.set_title(\"National Population by Age and Sex (2025)\")\nax.set_xlabel(\"Population\")\nax.set_ylabel(\"Age Range\")\n\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"{abs(int(x)):,}\"))\n\n# Clean up legend and layout\nax.legend(loc=\"lower right\", frameon=True)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() function to plot population data for two categories (male and female) against age ranges, where one side is made negative to create the characteristic symmetry of a population pyramid, matching the 'Pyramid chart' definition."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_national_population_2025.csv\")\n\n# Ensure proper order (as provided in the CSV)\nage = df[\"Age_Range\"].astype(str)\nmale = df[\"Male_Population\"].astype(int)\nfemale = df[\"Female_Population\"].astype(int)\n\n# Population pyramid: males negative, females positive\nmale_neg = -male.values\nfemale_pos = female.values\ny = np.arange(len(age))\n\nfig, ax = plt.subplots(figsize=(10, 7))\n\nax.barh(y, male_neg, color=\"#4C78A8\", alpha=0.9, label=\"Male\")\nax.barh(y, female_pos, color=\"#F58518\", alpha=0.9, label=\"Female\")\n\n# Formatting\nmax_pop = max(male.max(), female.max())\nxlim = int(np.ceil(max_pop / 5000) * 5000)\nax.set_xlim(-xlim, xlim)\n\nax.set_yticks(y)\nax.set_yticklabels(age)\nax.invert_yaxis()\n\nax.axvline(0, color=\"#333333\", linewidth=1)\n\n# Show absolute values on x-axis ticks\nticks = ax.get_xticks()\nax.set_xticklabels([f\"{abs(int(t)):,}\" for t in ticks])\n\nax.set_title(\"National Population 2025 by Age Range and Sex (Population Pyramid)\")\nax.set_xlabel(\"Population\")\nax.set_ylabel(\"Age Range\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.25)\nax.legend(loc=\"lower right\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The visualization uses matplotlib's ax.barh() function to plot population data by age range and gender, specifically mirrored around a central axis to form a population pyramid as defined in the taxonomy."}}
{"input_csv_file": "14_national_population_2025.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"14_national_population_2025.csv\")\n\n# Preserve provided order (top = youngest). For a classic pyramid, plot oldest at top.\ndf[\"Age_Range\"] = pd.Categorical(df[\"Age_Range\"], categories=df[\"Age_Range\"].tolist(), ordered=True)\ndf = df.sort_values(\"Age_Range\", ascending=False)\n\n# Prepare values (male negative for left side)\nmale = -df[\"Male_Population\"].values\nfemale = df[\"Female_Population\"].values\nages = df[\"Age_Range\"].astype(str).values\n\n# Figure\nplt.figure(figsize=(10, 7))\nax = plt.gca()\n\n# Bars\nax.barh(ages, male, color=\"#2C7FB8\", alpha=0.9, label=\"Male\")\nax.barh(ages, female, color=\"#F768A1\", alpha=0.9, label=\"Female\")\n\n# Axis formatting\nmax_val = max(df[\"Male_Population\"].max(), df[\"Female_Population\"].max())\npad = int(max_val * 0.12)\nax.set_xlim(-(max_val + pad), (max_val + pad))\n\nxticks = ax.get_xticks()\nax.set_xticklabels([f\"{abs(int(x)):,}\" for x in xticks])\n\nax.axvline(0, color=\"#333333\", linewidth=1)\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.3)\n\n# Labels and title\nax.set_title(\"National Population by Age Range and Sex (2025)\")\nax.set_xlabel(\"Population\")\nax.set_ylabel(\"Age Range\")\nax.legend(loc=\"lower right\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Pyramid chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() function to plot population data with age ranges on the Y-axis and two quantitative variables (male and female population) on the X-axis, with one side inverted to create the pyramid shape."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Prepare plot positions\nx = np.arange(len(df[\"Age_Group\"]))\nwidth = 0.38\n\n# Create chart: grouped bar chart by gender\nfig, ax = plt.subplots(figsize=(9, 5))\nax.bar(x - width/2, df[\"Male_Customers\"], width, label=\"Male\", color=\"#4C78A8\")\nax.bar(x + width/2, df[\"Female_Customers\"], width, label=\"Female\", color=\"#F58518\")\n\n# Formatting\nax.set_title(\"Shop Customers by Age Group and Gender\")\nax.set_xlabel(\"Age Group\")\nax.set_ylabel(\"Number of Customers\")\nax.set_xticks(x)\nax.set_xticklabels(df[\"Age_Group\"])\nax.legend(frameon=False)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered directly using matplotlib's ax.bar() function rather than pandas or seaborn wrappers. The bars are oriented vertically and grouped side-by-side using arithmetic offsets on the x-axis, which corresponds to the 'Grouped column chart' definition in the taxonomy."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Plot: Grouped bar chart by age group\nx = range(len(df[\"Age_Group\"]))\nwidth = 0.38\n\nplt.figure(figsize=(9, 5))\nplt.bar([i - width/2 for i in x], df[\"Male_Customers\"], width=width, label=\"Male\")\nplt.bar([i + width/2 for i in x], df[\"Female_Customers\"], width=width, label=\"Female\")\n\nplt.xticks(list(x), df[\"Age_Group\"])\nplt.ylabel(\"Number of Customers\")\nplt.xlabel(\"Age Group\")\nplt.title(\"Shop Customers by Age Group and Gender\")\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses plt.bar() from the matplotlib.pyplot library to draw vertical bars. Since there are two sets of bars (Male and Female) plotted side-by-side for each category on the x-axis (Age Group), it is classified as a Grouped column chart."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Prepare\nage_groups = df[\"Age_Group\"].astype(str).tolist()\nmale = df[\"Male_Customers\"].to_numpy()\nfemale = df[\"Female_Customers\"].to_numpy()\n\nx = np.arange(len(age_groups))\nwidth = 0.38\n\n# Plot: grouped bar chart\nfig, ax = plt.subplots(figsize=(8, 4.8))\nax.bar(x - width/2, male, width, label=\"Male\", color=\"#4C78A8\")\nax.bar(x + width/2, female, width, label=\"Female\", color=\"#F58518\")\n\n# Labels & styling\nax.set_title(\"Shop Customers by Age Group and Gender\")\nax.set_xlabel(\"Age Group\")\nax.set_ylabel(\"Number of Customers\")\nax.set_xticks(x)\nax.set_xticklabels(age_groups)\nax.legend(frameon=False)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.bar() function directly to render data. The bars are vertical and grouped by offset (width/2) to compare two categories (Male and Female) across a set of discrete age groups."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Prepare values\nage_groups = df[\"Age_Group\"]\nmale = df[\"Male_Customers\"]\nfemale = df[\"Female_Customers\"]\n\nx = np.arange(len(age_groups))\nwidth = 0.38\n\n# Plot: grouped bar chart\nplt.figure(figsize=(9, 5))\nplt.bar(x - width/2, male, width=width, label=\"Male\", color=\"#4C78A8\")\nplt.bar(x + width/2, female, width=width, label=\"Female\", color=\"#F58518\")\n\nplt.title(\"Shop Customers by Age Group and Gender\")\nplt.xlabel(\"Age Group\")\nplt.ylabel(\"Number of Customers\")\nplt.xticks(x, age_groups)\nplt.legend(frameon=False)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, and it creates vertical bars grouped by offsets (x - width/2 and x + width/2) to represent two categories (Male/Female) across age groups."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Ensure a consistent order for age groups\nage_order = [\"0-19\", \"20-39\", \"40-59\", \"60+\"]\ndf[\"Age_Group\"] = pd.Categorical(df[\"Age_Group\"], categories=age_order, ordered=True)\ndf = df.sort_values(\"Age_Group\")\n\n# Prepare plot data\nx = np.arange(len(df[\"Age_Group\"]))\nwidth = 0.38\n\nplt.figure(figsize=(9, 5.5))\nplt.bar(x - width/2, df[\"Male_Customers\"], width, label=\"Male\", color=\"#4C78A8\")\nplt.bar(x + width/2, df[\"Female_Customers\"], width, label=\"Female\", color=\"#F58518\")\n\nplt.title(\"Shop Customers by Age Group and Gender\")\nplt.xlabel(\"Age Group\")\nplt.ylabel(\"Number of Customers\")\nplt.xticks(x, df[\"Age_Group\"])\nplt.legend(frameon=False)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly from the matplotlib library to draw vertical bars. It creates a grouped layout by manually offsetting the x-positions of the 'Male' and 'Female' data series (x - width/2 and x + width/2)."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Plot: Grouped bar chart of male vs female customers by age group\nx = range(len(df[\"Age_Group\"]))\nbar_width = 0.4\n\nplt.figure(figsize=(8, 4.5))\nplt.bar([i - bar_width/2 for i in x], df[\"Male_Customers\"], width=bar_width, label=\"Male\")\nplt.bar([i + bar_width/2 for i in x], df[\"Female_Customers\"], width=bar_width, label=\"Female\")\n\nplt.xticks(list(x), df[\"Age_Group\"])\nplt.xlabel(\"Age Group\")\nplt.ylabel(\"Number of Customers\")\nplt.title(\"Customers by Age Group and Gender\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's plt.bar() function directly to render data. Because the bars are oriented vertically and manually offset to compare multiple categories (Male vs Female) for each Age Group, it is classified as a grouped column chart."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Plot: grouped bar chart comparing male vs female customers by age group\nx = range(len(df[\"Age_Group\"]))\nwidth = 0.4\n\nplt.figure(figsize=(8, 4.5))\nplt.bar([i - width/2 for i in x], df[\"Male_Customers\"], width=width, label=\"Male\")\nplt.bar([i + width/2 for i in x], df[\"Female_Customers\"], width=width, label=\"Female\")\n\nplt.xticks(list(x), df[\"Age_Group\"])\nplt.xlabel(\"Age Group\")\nplt.ylabel(\"Number of Customers\")\nplt.title(\"Customers by Age Group and Gender\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, hence the library is matplotlib. It creates two sets of vertical bars grouped side-by-side for each age category to represent two categorical variables (Age Group and Gender) against a quantitative value, fitting the definition of a Grouped column chart."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Ensure consistent ordering\nage_order = [\"0-19\", \"20-39\", \"40-59\", \"60+\"]\ndf[\"Age_Group\"] = pd.Categorical(df[\"Age_Group\"], categories=age_order, ordered=True)\ndf = df.sort_values(\"Age_Group\")\n\n# Plot: grouped bar chart (single chart)\nx = np.arange(len(df[\"Age_Group\"]))\nwidth = 0.38\n\nplt.figure(figsize=(9, 5))\nplt.bar(x - width/2, df[\"Male_Customers\"], width=width, label=\"Male\", color=\"#4C78A8\")\nplt.bar(x + width/2, df[\"Female_Customers\"], width=width, label=\"Female\", color=\"#F58518\")\n\nplt.xticks(x, df[\"Age_Group\"])\nplt.ylabel(\"Number of Customers\")\nplt.xlabel(\"Age Group\")\nplt.title(\"Shop Customers by Age Group and Gender\")\nplt.legend(frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the `plt.bar()` function directly from matplotlib. The visualization displays vertical bars grouped together side-by-side for each 'Age Group' category to represent 'Male' vs 'Female' counts, which fits the definition of a Grouped column chart."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"14_shop_customers_demographics.csv\"\ndf = pd.read_csv(csv_path)\n\n# Plot: grouped bar chart by age group and gender\nplt.figure(figsize=(9, 5))\nx = range(len(df[\"Age_Group\"]))\nbar_width = 0.4\n\nplt.bar([i - bar_width / 2 for i in x], df[\"Male_Customers\"], width=bar_width, label=\"Hombres\")\nplt.bar([i + bar_width / 2 for i in x], df[\"Female_Customers\"], width=bar_width, label=\"Mujeres\")\n\nplt.title(\"Clientes por grupo de edad y género\")\nplt.xlabel(\"Grupo de edad\")\nplt.ylabel(\"Número de clientes\")\nplt.xticks(list(x), df[\"Age_Group\"])\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render vertical bars. By manually adjusting the x-coordinates with offsets (bar_width / 2), it creates side-by-side groupings for two categorical variables (Gender and Age Group) against a quantitative value, fitting the definition of a Grouped column chart."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Prepare\nage_groups = df[\"Age_Group\"]\nmale = df[\"Male_Customers\"]\nfemale = df[\"Female_Customers\"]\nx = np.arange(len(age_groups))\nwidth = 0.38\n\n# Plot\nplt.figure(figsize=(9, 5.2))\nplt.bar(x - width/2, male, width=width, label=\"Male\", color=\"#4C78A8\")\nplt.bar(x + width/2, female, width=width, label=\"Female\", color=\"#F58518\")\n\n# Styling\nplt.title(\"Shop Customers by Age Group and Gender\")\nplt.xlabel(\"Age Group\")\nplt.ylabel(\"Number of Customers\")\nplt.xticks(x, age_groups)\nplt.legend(frameon=False)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses standard matplotlib axes functions (plt.bar) to render vertical bars. Since it plots two distinct series (Male and Female) side-by-side for each Age Group category, it is classified as a grouped column chart."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Prepare\nage_groups = df[\"Age_Group\"].astype(str).tolist()\nmale = df[\"Male_Customers\"].to_numpy()\nfemale = df[\"Female_Customers\"].to_numpy()\n\nx = np.arange(len(age_groups))\nwidth = 0.38\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5.2))\n\nax.bar(x - width/2, male, width, label=\"Male\", color=\"#4C78A8\")\nax.bar(x + width/2, female, width, label=\"Female\", color=\"#F58518\")\n\n# Labels & formatting\nax.set_title(\"Shop Customers by Age Group and Gender\", pad=12)\nax.set_xlabel(\"Age Group\")\nax.set_ylabel(\"Number of Customers\")\nax.set_xticks(x)\nax.set_xticklabels(age_groups)\nax.legend(frameon=False, ncols=2, loc=\"upper right\")\n\n# Value labels\nymax = max(male.max(), female.max())\nax.set_ylim(0, ymax * 1.15)\nfor xi, v in zip(x - width/2, male):\n    ax.text(xi, v + ymax * 0.02, f\"{int(v)}\", ha=\"center\", va=\"bottom\", fontsize=9)\nfor xi, v in zip(x + width/2, female):\n    ax.text(xi, v + ymax * 0.02, f\"{int(v)}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "Data is rendered using standard matplotlib axis functions (ax.bar). The bars are vertical and positioned side-by-side using offset calculations (x - width/2 and x + width/2) to represent two categorical dimensions (Age Group and Gender) and one quantitative dimension."}}
{"input_csv_file": "14_shop_customers_demographics.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"14_shop_customers_demographics.csv\")\n\n# Ensure intended order (in case CSV order changes)\nage_order = [\"0-19\", \"20-39\", \"40-59\", \"60+\"]\ndf[\"Age_Group\"] = pd.Categorical(df[\"Age_Group\"], categories=age_order, ordered=True)\ndf = df.sort_values(\"Age_Group\")\n\n# Plot: grouped bar chart\nx = np.arange(len(df))\nwidth = 0.38\n\nfig, ax = plt.subplots(figsize=(9, 5))\n\nax.bar(x - width/2, df[\"Male_Customers\"], width, label=\"Male\", color=\"#4C78A8\")\nax.bar(x + width/2, df[\"Female_Customers\"], width, label=\"Female\", color=\"#F58518\")\n\nax.set_title(\"Shop Customers by Age Group and Gender\", pad=10)\nax.set_xlabel(\"Age Group\")\nax.set_ylabel(\"Number of Customers\")\nax.set_xticks(x)\nax.set_xticklabels(df[\"Age_Group\"])\nax.legend(frameon=False, ncols=2, loc=\"upper left\")\n\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization is created using standard Matplotlib axes methods (ax.bar) rather than seaborn or pandas wrappers. It features vertical bars grouped side-by-side to compare two categories (Male vs Female customers) across a categorical X-axis (Age Group), which classifies it as a Grouped column chart."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"14nc-est2024-agesex-res.csv\"\n\ndef main():\n    df = pd.read_csv(CSV_PATH)\n\n    # Keep total population (SEX=0) and ages 0-29 (as provided)\n    total = df[(df[\"SEX\"] == 0)].copy()\n    total = total.sort_values(\"AGE\")\n\n    years = [\"POPESTIMATE2020\", \"POPESTIMATE2021\", \"POPESTIMATE2022\", \"POPESTIMATE2023\", \"POPESTIMATE2024\"]\n\n    plt.style.use(\"seaborn-v0_8-whitegrid\")\n    fig, ax = plt.subplots(figsize=(11, 6))\n\n    for y in years:\n        ax.plot(total[\"AGE\"], total[y], linewidth=2, label=y.replace(\"POPESTIMATE\", \"\"))\n\n    ax.set_title(\"Population by Single Year of Age (Total Population, SEX=0): 2020–2024\")\n    ax.set_xlabel(\"Age\")\n    ax.set_ylabel(\"Population\")\n    ax.legend(title=\"Year\", ncols=5, frameon=True)\n\n    ax.ticklabel_format(axis=\"y\", style=\"plain\")\n    ax.margins(x=0.01)\n\n    fig.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib axes function ax.plot() to render quantitative population data over ages for multiple years, which corresponds to a line chart."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\npath = \"14nc-est2024-agesex-res.csv\"\ndf = pd.read_csv(path)\n\n# Use total population (SEX=0) and compare 2020 vs 2024 by age\ntotal = df[df[\"SEX\"] == 0].copy()\ntotal = total.sort_values(\"AGE\")\n\nx = total[\"AGE\"]\ny2020 = total[\"POPESTIMATE2020\"]\ny2024 = total[\"POPESTIMATE2024\"]\ndiff = y2024 - y2020\n\n# Single chart: bar chart of change with a zero baseline\nplt.figure(figsize=(12, 6))\nplt.bar(x, diff, color=[\"#2E86AB\" if v >= 0 else \"#C0392B\" for v in diff], width=0.85)\nplt.axhline(0, color=\"black\", linewidth=1)\n\nplt.title(\"Population Change by Age (Total, 2024 minus 2020)\")\nplt.xlabel(\"Age\")\nplt.ylabel(\"Change in population (people)\")\nplt.xticks(range(int(x.min()), int(x.max()) + 1, 1), rotation=0)\n\n# Make y-axis easier to read\nplt.ticklabel_format(axis=\"y\", style=\"plain\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render vertical bars, classifying the library as matplotlib and the chart type as a Column chart according to the taxonomy."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ncsv_path = \"14nc-est2024-agesex-res.csv\"\ndf = pd.read_csv(csv_path)\n\n# Use total population (SEX=0) and focus on ages 0-29 (already the full set here)\ntotal = df[df[\"SEX\"] == 0].copy().sort_values(\"AGE\")\n\n# Plot: population by age for 2020 vs 2024\nfig, ax = plt.subplots(figsize=(11, 6))\nax.plot(total[\"AGE\"], total[\"POPESTIMATE2020\"], linewidth=2, label=\"2020\")\nax.plot(total[\"AGE\"], total[\"POPESTIMATE2024\"], linewidth=2, label=\"2024\")\n\nax.set_title(\"U.S. Resident Population by Single Year of Age (Ages 0–29): 2020 vs 2024\")\nax.set_xlabel(\"Age\")\nax.set_ylabel(\"Population\")\n\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"{int(x/1_000_000)}M\" if x >= 1_000_000 else f\"{int(x):,}\"))\nax.set_xticks(range(int(total[\"AGE\"].min()), int(total[\"AGE\"].max()) + 1, 1))\nax.grid(True, axis=\"y\", alpha=0.25)\nax.legend(frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard matplotlib axes functions (ax.plot) to render the data directly, fitting the library classification for matplotlib. It visualizes quantitative population data across age (an ordinal/temporal dimension) using lines, which corresponds to the Line chart taxonomy."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ncsv_path = \"14nc-est2024-agesex-res.csv\"\ndf = pd.read_csv(csv_path)\n\n# Use total population (SEX=0) and focus on ages 0–29 (already in file)\ntotal = df[df[\"SEX\"] == 0].copy()\n\n# Prepare series\nages = total[\"AGE\"]\npop_2020 = total[\"POPESTIMATE2020\"]\npop_2024 = total[\"POPESTIMATE2024\"]\nchange = pop_2024 - pop_2020\n\n# Plot: population change by age from 2020 to 2024 (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6))\n\nbars = ax.bar(ages, change, color=[\"#2ca02c\" if v >= 0 else \"#d62728\" for v in change], width=0.85)\n\nax.set_title(\"Population Change by Age (Total Population): 2020 → 2024\", pad=12)\nax.set_xlabel(\"Age\")\nax.set_ylabel(\"Change in population (2024 minus 2020)\")\n\nax.axhline(0, color=\"black\", linewidth=1)\n\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\"))\nax.set_xticks(list(range(int(ages.min()), int(ages.max()) + 1, 1)))\n\n# Annotate the largest increase and largest decrease\nimax = change.idxmax()\nimin = change.idxmin()\n\nfor idx, label in [(imax, \"Largest increase\"), (imin, \"Largest decrease\")]:\n    age = int(total.loc[idx, \"AGE\"])\n    val = int(change.loc[idx])\n    ax.annotate(\n        f\"{label}\\nAge {age}: {val:+,}\",\n        xy=(age, val),\n        xytext=(age + (2 if label == \"Largest increase\" else -6), val + (max(change) - min(change)) * (0.12 if val >= 0 else -0.12)),\n        arrowprops=dict(arrowstyle=\"->\", lw=1),\n        ha=\"left\" if label == \"Largest increase\" else \"right\",\n        va=\"bottom\" if val >= 0 else \"top\",\n        fontsize=9,\n        bbox=dict(boxstyle=\"round,pad=0.25\", fc=\"white\", ec=\"0.6\", alpha=0.95),\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the matplotlib Axes method ax.bar() to render vertical bars, making it a Column chart. While the plot style is set to a seaborn variant, the specific data colors are assigned manually using a list of hex codes based on the data values rather than using a named color palette."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"14nc-est2024-agesex-res.csv\"\ndf = pd.read_csv(csv_path)\n\n# Use total population rows (SEX=0) and ages 0-29 (as provided)\ntotal = df[(df[\"SEX\"] == 0) & (df[\"AGE\"].between(0, 29))].copy()\n\nyears = [2020, 2021, 2022, 2023, 2024]\nyear_cols = [f\"POPESTIMATE{y}\" for y in years]\n\n# Compute total population (ages 0-29) by year\ntotals_by_year = total[year_cols].sum()\n\n# Plot (single chart)\nplt.figure(figsize=(9, 5))\nplt.plot(years, totals_by_year.values, marker=\"o\", linewidth=2)\nplt.title(\"Total Population Ages 0–29 (SEX=0) by Year\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Population\")\nplt.grid(True, alpha=0.3)\n\n# Add labels on points\nfor x, y in zip(years, totals_by_year.values):\n    plt.annotate(f\"{y:,}\", (x, y), textcoords=\"offset points\", xytext=(0, 8), ha=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function `plt.plot()` to render the data. The visualization displays a quantitative population variable across a temporal sequence of years, which satisfies the definition of a Line chart."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"14nc-est2024-agesex-res.csv\"\n\ndef main():\n    df = pd.read_csv(CSV_PATH)\n\n    # Use total (SEX=0) and 2024 estimate\n    d = df[df[\"SEX\"] == 0][[\"AGE\", \"POPESTIMATE2024\"]].copy()\n    d = d.sort_values(\"AGE\")\n\n    plt.figure(figsize=(10, 5.5))\n    plt.plot(d[\"AGE\"], d[\"POPESTIMATE2024\"], linewidth=2)\n    plt.title(\"2024 Population Estimate by Single Year of Age (Total, SEX=0)\")\n    plt.xlabel(\"Age\")\n    plt.ylabel(\"Population (POPESTIMATE2024)\")\n    plt.grid(True, alpha=0.3)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.plot() to render the data, and the resulting visualization shows a quantitative variable (population) over a sequential dimension (age), which classifies it as a Line chart."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    path = \"14nc-est2024-agesex-res.csv\"\n    df = pd.read_csv(path)\n\n    # Use totals (SEX==0), and compare 2020 base vs 2024 estimate by age\n    d = df[df[\"SEX\"] == 0].copy().sort_values(\"AGE\")\n    d[\"diff_2024_minus_base2020\"] = d[\"POPESTIMATE2024\"] - d[\"ESTIMATESBASE2020\"]\n\n    fig, ax = plt.subplots(figsize=(10, 5))\n    ax.plot(\n        d[\"AGE\"],\n        d[\"diff_2024_minus_base2020\"],\n        color=\"tab:blue\",\n        linewidth=2,\n        label=\"POPESTIMATE2024 - ESTIMATESBASE2020 (SEX=0)\",\n    )\n    ax.axhline(0, color=\"black\", linewidth=1)\n\n    ax.set_title(\"Age-specific population change: 2024 estimate vs 2020 base (Total, SEX=0)\")\n    ax.set_xlabel(\"Age\")\n    ax.set_ylabel(\"Population difference (persons)\")\n    ax.grid(True, alpha=0.3)\n    ax.legend(frameon=False)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The plot is rendered using the standard matplotlib axes function `ax.plot()`. It visualizes the relationship between an ordered categorical/numeric variable (Age) and a quantitative variable (Population difference) using lines, which matches the definition of a Line chart."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Read CSV\ndf = pd.read_csv(\"14nc-est2024-agesex-res.csv\")\n\n# Keep only total (SEX == 0) and ages 0-29 as provided\ndf = df[(df[\"SEX\"] == 0) & (df[\"AGE\"].between(0, 29))].copy()\ndf = df.sort_values(\"AGE\")\n\n# Years to plot\nyears = [2020, 2021, 2022, 2023, 2024]\ncols = [f\"POPESTIMATE{y}\" for y in years]\n\n# Plot: population by age, multiple years on one chart\nplt.figure(figsize=(12, 6))\nfor y, c in zip(years, cols):\n    plt.plot(df[\"AGE\"], df[c], linewidth=2, label=str(y))\n\nplt.title(\"Population Estimates by Single Year of Age (0–29), Total (SEX=0)\")\nplt.xlabel(\"Age\")\nplt.ylabel(\"Population\")\nplt.xticks(range(0, 30, 1))\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\nplt.legend(title=\"Year\", ncols=5, frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses `plt.plot()` from the matplotlib library to draw the data. The visualization displays population trends across a range of ages for multiple years (temporal/categorical), which classifies it as a Line chart."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"14nc-est2024-agesex-res.csv\"\ndf = pd.read_csv(csv_path)\n\n# Keep only Male (1) and Female (2) and focus on 2024\nsex_map = {1: \"Hombres\", 2: \"Mujeres\"}\ndf = df[df[\"SEX\"].isin([1, 2])].copy()\ndf[\"Sexo\"] = df[\"SEX\"].map(sex_map)\n\n# Prepare series by sex\nmale = df[df[\"SEX\"] == 1].sort_values(\"AGE\")\nfemale = df[df[\"SEX\"] == 2].sort_values(\"AGE\")\n\n# Plot: Population estimate by age (2024) for men vs women\nplt.figure(figsize=(10, 6))\nplt.plot(male[\"AGE\"], male[\"POPESTIMATE2024\"], label=\"Hombres (2024)\", linewidth=2)\nplt.plot(female[\"AGE\"], female[\"POPESTIMATE2024\"], label=\"Mujeres (2024)\", linewidth=2)\n\nplt.title(\"Estimación de población por edad (2024): Hombres vs Mujeres\")\nplt.xlabel(\"Edad\")\nplt.ylabel(\"Población estimada\")\nplt.grid(True, alpha=0.3)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly to render the data, which follows the hierarchy for 'matplotlib' classification. The visualization represents population estimates over ages (ordered variable) for two categories (Hombres and Mujeres), aligning with the definition of a line chart."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ncsv_path = \"14nc-est2024-agesex-res.csv\"\ndf = pd.read_csv(csv_path)\n\n# Keep male (1) and female (2); exclude total (0)\ndf = df[df[\"SEX\"].isin([1, 2])].copy()\n\n# Compute 2020 -> 2024 change per age and sex\ndf[\"delta_20_24\"] = df[\"POPESTIMATE2024\"] - df[\"POPESTIMATE2020\"]\ndf[\"sex_label\"] = df[\"SEX\"].map({1: \"Male\", 2: \"Female\"})\n\n# Pivot for plotting\npvt = df.pivot(index=\"AGE\", columns=\"sex_label\", values=\"delta_20_24\").sort_index()\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6.2))\n\ncolors = {\"Male\": \"#2E86AB\", \"Female\": \"#D1495B\"}\n\nfor col in [\"Male\", \"Female\"]:\n    if col in pvt.columns:\n        ax.plot(\n            pvt.index,\n            pvt[col],\n            lw=2.5,\n            color=colors[col],\n            label=col,\n        )\n\nax.axhline(0, color=\"black\", lw=1, alpha=0.6)\n\nax.set_title(\"Population Change by Age (2020 → 2024) — Male vs Female\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Age\")\nax.set_ylabel(\"Change in population (2024 minus 2020)\")\n\nax.set_xlim(pvt.index.min(), pvt.index.max())\nax.xaxis.set_major_locator(plt.MaxNLocator(integer=True, nbins=16))\n\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"{int(x):,}\"))\n\nax.legend(frameon=True, title=\"Sex\")\nax.margins(x=0.01)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using matplotlib's `ax.plot()` function to render the data directly. It depicts population change (quantitative) across ages (ordered categorical/temporal dimension), which classifies it as a line chart."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"14nc-est2024-agesex-res.csv\"\n\ndef main():\n    df = pd.read_csv(CSV_PATH)\n\n    # Use total population (SEX=0) and compare 2020 vs 2024 by single-year age.\n    total = df[df[\"SEX\"] == 0].copy().sort_values(\"AGE\")\n    total[\"Change_2020_2024\"] = total[\"POPESTIMATE2024\"] - total[\"POPESTIMATE2020\"]\n\n    x = total[\"AGE\"]\n    y = total[\"Change_2020_2024\"]\n\n    plt.style.use(\"seaborn-v0_8-whitegrid\")\n    fig, ax = plt.subplots(figsize=(11, 6.2), dpi=140)\n\n    colors = [\"#2ca02c\" if v >= 0 else \"#d62728\" for v in y]\n    ax.bar(x, y, color=colors, width=0.85, linewidth=0)\n\n    ax.axhline(0, color=\"#333333\", linewidth=1)\n    ax.set_title(\"Population Change by Age (Total, 2020 → 2024)\", pad=10, weight=\"bold\")\n    ax.set_xlabel(\"Age\")\n    ax.set_ylabel(\"Change in population (2024 minus 2020)\")\n\n    # Ticks\n    ax.set_xticks(range(int(x.min()), int(x.max()) + 1, 2))\n    ax.margins(x=0.01)\n\n    # Subtle annotation: highlight max increase/decrease\n    max_idx = y.idxmax()\n    min_idx = y.idxmin()\n    for idx, label in [(max_idx, \"Largest increase\"), (min_idx, \"Largest decrease\")]:\n        age = int(total.loc[idx, \"AGE\"])\n        val = int(total.loc[idx, \"Change_2020_2024\"])\n        ax.annotate(\n            f\"{label}\\nAge {age}: {val:,}\",\n            xy=(age, val),\n            xytext=(age + (2 if label == \"Largest increase\" else -6), val * 0.6),\n            textcoords=\"data\",\n            arrowprops=dict(arrowstyle=\"-|>\", color=\"#444444\", lw=1),\n            fontsize=9,\n            ha=\"left\" if label == \"Largest increase\" else \"right\",\n            va=\"center\",\n            bbox=dict(boxstyle=\"round,pad=0.25\", fc=\"white\", ec=\"#bbbbbb\", alpha=0.95),\n        )\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using the Matplotlib function ax.bar(), which generates vertical bars, qualifying it as a Column chart. Although pandas is used for data manipulation, the rendering is done directly through Matplotlib."}}
{"input_csv_file": "14nc-est2024-agesex-res.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"14nc-est2024-agesex-res.csv\"\ndf = pd.read_csv(csv_path)\n\n# Use total population (SEX == 0) and compare 2020 vs 2024 by single year of age\nd = df[df[\"SEX\"] == 0][[\"AGE\", \"POPESTIMATE2020\", \"POPESTIMATE2024\"]].sort_values(\"AGE\").copy()\nd[\"Change_2024_minus_2020\"] = d[\"POPESTIMATE2024\"] - d[\"POPESTIMATE2020\"]\n\n# Plot: single chart (bar change by age)\nplt.figure(figsize=(12, 6))\nplt.axhline(0, color=\"black\", linewidth=1)\n\nbars = plt.bar(\n    d[\"AGE\"],\n    d[\"Change_2024_minus_2020\"] / 1_000_000,\n    color=[\"#2a9d8f\" if v >= 0 else \"#e76f51\" for v in d[\"Change_2024_minus_2020\"]],\n    width=0.9\n)\n\nplt.title(\"Population Change by Age (Total, SEX=0): 2024 vs 2020\")\nplt.xlabel(\"Age\")\nplt.ylabel(\"Change in population (millions)\")\nplt.xticks(d[\"AGE\"], rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to create vertical bars (Column chart) based on 'AGE' and 'Population Change' variables. Custom hex codes are used via list comprehension rather than a named palette."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Compute overall score as the average across all metrics (excluding City)\nmetric_cols = [c for c in df.columns if c != \"City\"]\ndf[\"Overall_Score\"] = df[metric_cols].mean(axis=1)\n\n# Sort for plotting\ndf_sorted = df.sort_values(\"Overall_Score\", ascending=True)\n\n# Plot: Overall Quality of Life Score by City\nplt.figure(figsize=(10, 5.5))\nplt.barh(df_sorted[\"City\"], df_sorted[\"Overall_Score\"], color=\"#4C78A8\")\nplt.title(\"Overall Quality of Life Score by City (Average of Metrics)\")\nplt.xlabel(\"Average Score (0–100)\")\nplt.ylabel(\"City\")\nplt.xlim(0, 100)\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n\n# Label bars\nfor i, v in enumerate(df_sorted[\"Overall_Score\"]):\n    plt.text(v + 0.6, i, f\"{v:.1f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib function plt.barh() to render the data. Based on the taxonomy, horizontal bars are classified as a 'Bar chart' rather than a 'Column chart'."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Compute an overall quality score (simple average of all metrics except City)\nmetrics = [c for c in df.columns if c != \"City\"]\ndf[\"Overall_Score\"] = df[metrics].mean(axis=1)\n\n# Sort for clearer comparison\ndf_sorted = df.sort_values(\"Overall_Score\", ascending=True)\n\n# Plot: Overall score by city\nplt.figure(figsize=(10, 5.5))\nplt.barh(df_sorted[\"City\"], df_sorted[\"Overall_Score\"], color=\"#4C78A8\")\nplt.title(\"Overall Quality of Life Score by City (Average of All Metrics)\")\nplt.xlabel(\"Overall Score (0–100)\")\nplt.ylabel(\"City\")\nplt.xlim(0, 100)\n\n# Annotate values\nfor i, v in enumerate(df_sorted[\"Overall_Score\"]):\n    plt.text(v + 0.6, i, f\"{v:.1f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the `plt.barh()` function from matplotlib to render the data directly. According to the taxonomy, horizontal bars are classified as a 'Bar chart', whereas vertical bars are 'Column charts'."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Compute an overall average score per city (simple mean across the numeric categories)\nscore_cols = [c for c in df.columns if c != \"City\"]\ndf[\"Overall_Score\"] = df[score_cols].mean(axis=1)\n\n# Sort for easier comparison\ndf = df.sort_values(\"Overall_Score\", ascending=False)\n\n# Single chart: bar chart of overall scores by city\nplt.figure(figsize=(10, 5))\nplt.bar(df[\"City\"], df[\"Overall_Score\"], color=\"#4C78A8\")\nplt.title(\"Overall Quality of Life Score by City (Average of Categories)\")\nplt.xlabel(\"City\")\nplt.ylabel(\"Average Score (0–100)\")\nplt.ylim(0, 100)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is rendered using the standard `plt.bar()` function from matplotlib. Since the bars are vertical and represent a categorical dimension (City) against a quantitative one (Overall_Score), it is classified as a Column chart."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Compute overall average score (simple mean of all quality-of-life metrics)\nmetrics = [c for c in df.columns if c != \"City\"]\ndf[\"Overall_Average\"] = df[metrics].mean(axis=1)\n\n# Sort for easier comparison\ndf = df.sort_values(\"Overall_Average\", ascending=True)\n\n# Plot: Overall average score by city\nplt.figure(figsize=(10, 5))\nplt.barh(df[\"City\"], df[\"Overall_Average\"], color=\"#4C78A8\")\nplt.title(\"Overall Quality-of-Life Score by City (Average of All Metrics)\")\nplt.xlabel(\"Average Score (0–100)\")\nplt.xlim(0, 100)\n\n# Add value labels\nfor y, val in enumerate(df[\"Overall_Average\"]):\n    plt.text(val + 0.8, y, f\"{val:.1f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is generated using 'plt.barh()', which renders horizontal bars, identifying it as a 'Bar chart' per the taxonomy. The library is classified as 'matplotlib' because the data is rendered using standard pyplot functions rather than seaborn or pandas plotting wrappers."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Prepare data for a single chart: stacked horizontal bars per city\nmetrics = [\"Safety\", \"Healthcare\", \"Education\", \"Environment\", \"Economy\", \"Traffic\", \"Culture\", \"Housing_Affordability\"]\nplot_df = df.set_index(\"City\")[metrics]\n\n# Plot\nplt.figure(figsize=(12, 6))\nax = plot_df.plot(kind=\"barh\", stacked=True, colormap=\"tab20\", edgecolor=\"white\", linewidth=0.6)\n\nax.set_title(\"City Quality of Life Profile (Stacked Scores by Dimension)\")\nax.set_xlabel(\"Total (Stacked) Score\")\nax.set_ylabel(\"City\")\nax.legend(title=\"Metric\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked bar chart", "color_palette": "tab20", "reasoning": "The code uses the pandas DataFrame plotting wrapper `plot_df.plot()` with `kind='barh'` and `stacked=True`, which creates a horizontal stacked bar layout."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Calculate overall quality-of-life score (mean of all numeric columns)\nscore_cols = [c for c in df.columns if c != \"City\"]\ndf[\"Overall_Score\"] = df[score_cols].mean(axis=1)\n\n# Sort by score for clearer visualization\ndf_sorted = df.sort_values(\"Overall_Score\", ascending=True)\n\n# Plot: Horizontal bar chart of overall scores by city\nplt.figure(figsize=(9, 5.5))\nplt.barh(df_sorted[\"City\"], df_sorted[\"Overall_Score\"], color=\"#4C78A8\")\nplt.title(\"Overall Quality of Life Score by City (Average of Metrics)\")\nplt.xlabel(\"Average Score (0–100)\")\nplt.ylabel(\"City\")\nplt.xlim(0, 100)\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.barh() to draw horizontal bars directly from a categorical variable ('City') and a quantitative one ('Overall_Score'), which classifies as a Bar chart."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Prepare data for a single-chart visualization\nmetrics = [c for c in df.columns if c != \"City\"]\ndf[\"Overall_Score\"] = df[metrics].mean(axis=1)\n\n# Sort by overall score for clearer comparison\ndf_sorted = df.sort_values(\"Overall_Score\", ascending=True)\n\n# Plot: Overall Quality of Life score by city (single chart)\nplt.figure(figsize=(10, 5))\nplt.barh(df_sorted[\"City\"], df_sorted[\"Overall_Score\"], color=\"#4C78A8\")\nplt.xlabel(\"Overall Quality of Life Score (Average of All Metrics)\")\nplt.ylabel(\"City\")\nplt.title(\"Overall Quality of Life by City\")\nplt.xlim(0, 100)\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses plt.barh() from the matplotlib library to render data as horizontal bars. According to the taxonomy, horizontal bars representing a categorical variable and a quantitative variable are classified as a Bar chart."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Compute overall score (simple average across metrics)\nmetrics = [c for c in df.columns if c != \"City\"]\ndf[\"Overall_Score\"] = df[metrics].mean(axis=1)\n\n# Sort for readability\ndf = df.sort_values(\"Overall_Score\", ascending=True)\n\n# Plot: Overall quality-of-life score by city\nplt.figure(figsize=(10, 5.5))\nplt.barh(df[\"City\"], df[\"Overall_Score\"], color=\"#4C78A8\")\nplt.xlabel(\"Overall Score (Average of All Metrics)\")\nplt.ylabel(\"City\")\nplt.title(\"Overall Quality of Life Score by City\")\nplt.xlim(0, 100)\n\n# Value labels\nfor y, v in enumerate(df[\"Overall_Score\"]):\n    plt.text(v + 0.6, y, f\"{v:.1f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is generated using 'plt.barh()', which is a standard matplotlib function for creating horizontal bars. Following the taxonomy and library hierarchy, this is classified as 'matplotlib' and 'Bar chart' because the bars are oriented horizontally."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"15_city_quality_of_life.csv\"\ndf = pd.read_csv(csv_path)\n\n# Compute overall quality-of-life score (mean of all numeric columns)\nnumeric_cols = df.columns.drop(\"City\")\ndf[\"Quality_of_Life_Score\"] = df[numeric_cols].mean(axis=1)\n\n# Sort for nicer plotting\ndf_sorted = df.sort_values(\"Quality_of_Life_Score\", ascending=True)\n\n# Plot: horizontal bar chart of overall score by city\nplt.figure(figsize=(10, 5.5))\nplt.barh(df_sorted[\"City\"], df_sorted[\"Quality_of_Life_Score\"], color=\"#4C78A8\")\nplt.title(\"Quality of Life Score (Average Across Metrics) by City\")\nplt.xlabel(\"Average Score\")\nplt.ylabel(\"City\")\nplt.xlim(0, 100)\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses plt.barh() from the matplotlib library to render horizontal bars, which distinguishes it as a 'Bar chart' rather than a vertical 'Column chart' according to the taxonomy."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Metrics to include (exclude City)\nmetrics = [c for c in df.columns if c != \"City\"]\n\n# Simple composite: average across all metrics\ndf[\"Overall_Score\"] = df[metrics].mean(axis=1)\n\n# Sort for clearer comparison\ndf = df.sort_values(\"Overall_Score\", ascending=True)\n\n# Plot: horizontal bar chart\nplt.figure(figsize=(10, 5.5))\nplt.barh(df[\"City\"], df[\"Overall_Score\"], color=\"#4C78A8\")\n\nplt.title(\"Overall Quality of Life Score by City (Average of Metrics)\")\nplt.xlabel(\"Overall Score (0–100)\")\nplt.ylabel(\"City\")\nplt.xlim(0, 100)\n\n# Value labels\nfor y, v in enumerate(df[\"Overall_Score\"]):\n    plt.text(v + 0.8, y, f\"{v:.1f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The data is rendered using the plt.barh() function from the matplotlib.pyplot library, which creates horizontal bars. According to the taxonomy, horizontal bars representing a categorical variable and a quantitative variable are classified as a 'Bar chart'."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Metrics to include in the composite score\nmetrics = [\n    \"Safety\",\n    \"Healthcare\",\n    \"Education\",\n    \"Environment\",\n    \"Economy\",\n    \"Traffic\",\n    \"Culture\",\n    \"Housing_Affordability\",\n]\n\n# Compute composite score (simple mean of all metrics)\ndf[\"Quality_of_Life_Score\"] = df[metrics].mean(axis=1)\n\n# Sort for cleaner ranking view\ndf = df.sort_values(\"Quality_of_Life_Score\", ascending=True)\n\n# Plot: ranked horizontal bar chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9.5, 5.2))\n\nax.barh(df[\"City\"], df[\"Quality_of_Life_Score\"], color=\"#2a9d8f\")\nax.set_title(\"Composite Quality of Life Score by City (Average of All Metrics)\")\nax.set_xlabel(\"Score (0–100)\")\nax.set_xlim(0, 100)\n\n# Value labels\nfor y, v in enumerate(df[\"Quality_of_Life_Score\"]):\n    ax.text(v + 0.8, y, f\"{v:.1f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard Matplotlib axes function `ax.barh()` to draw the data, and per the hierarchy rules, this is classified as 'matplotlib'. Since the bars are oriented horizontally, it is classified as a 'Bar chart' rather than a 'Column chart'."}}
{"input_csv_file": "15_city_quality_of_life.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_city_quality_of_life.csv\")\n\n# Metrics to include (exclude City)\nmetrics = [c for c in df.columns if c != \"City\"]\n\n# Compute an overall index as the mean across metrics\ndf[\"Quality_of_Life_Index\"] = df[metrics].mean(axis=1)\n\n# Sort for a clean ranking chart\ndf_sorted = df.sort_values(\"Quality_of_Life_Index\", ascending=True)\n\n# Plot: ranked horizontal bar chart\nplt.figure(figsize=(10, 5.5))\nplt.barh(df_sorted[\"City\"], df_sorted[\"Quality_of_Life_Index\"], color=\"#2E86AB\")\n\n# Labels and styling\nplt.title(\"Overall Quality of Life Index by City (Mean of Indicators)\")\nplt.xlabel(\"Index Score (0–100)\")\nplt.ylabel(\"\")\nplt.xlim(0, 100)\n\n# Value labels\nfor i, v in enumerate(df_sorted[\"Quality_of_Life_Index\"]):\n    plt.text(v + 0.6, i, f\"{v:.1f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The data is rendered using the plt.barh() function from matplotlib, which creates horizontal bars. According to the taxonomy, horizontal bars are classified as a Bar chart."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare radar chart data\ncategories = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\nN = len(categories)\nangles = np.linspace(0, 2 * np.pi, N, endpoint=False).tolist()\nangles += angles[:1]  # close the loop\n\nfig = plt.figure(figsize=(8, 6))\nax = plt.subplot(111, polar=True)\n\n# Plot each class\nfor _, row in df.iterrows():\n    values = [row[c] for c in categories]\n    values += values[:1]  # close the loop\n    ax.plot(angles, values, linewidth=2, label=row[\"Character_Class\"])\n    ax.fill(angles, values, alpha=0.12)\n\n# Styling\nax.set_title(\"RPG Character Stats by Class\", pad=18)\nax.set_xticks(angles[:-1])\nax.set_xticklabels(categories)\nax.set_ylim(0, 100)\nax.set_yticks([20, 40, 60, 80, 100])\nax.set_yticklabels([\"20\", \"40\", \"60\", \"80\", \"100\"])\nax.grid(True, linestyle=\"--\", alpha=0.4)\nax.legend(loc=\"upper right\", bbox_to_anchor=(1.25, 1.10), frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Radar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `plt.subplot(polar=True)` and the `ax.plot()` and `ax.fill()` methods to draw a multi-variable comparison across circular axes, which defines a Radar chart. Since the plotting functions are called directly from matplotlib axes, the library is classified as matplotlib."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare chart data\nstats_cols = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\nclasses = df[\"Character_Class\"].tolist()\n\n# Plot: grouped bar chart\nx = range(len(stats_cols))\nbar_width = 0.25\n\nplt.figure(figsize=(10, 5))\nfor i, cls in enumerate(classes):\n    values = df.loc[df[\"Character_Class\"] == cls, stats_cols].iloc[0].values\n    plt.bar([v + i * bar_width for v in x], values, width=bar_width, label=cls)\n\nplt.xticks([v + bar_width for v in x], stats_cols)\nplt.ylabel(\"Stat Value\")\nplt.title(\"RPG Character Stats by Class\")\nplt.ylim(0, 100)\nplt.legend(title=\"Character Class\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib function `plt.bar()` to draw vertical bars. It creates a grouped layout by iterating through character classes and offsetting the x-positions, resulting in a Grouped column chart."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare data for plotting\nstats_cols = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\ndf_long = df.melt(id_vars=\"Character_Class\", value_vars=stats_cols,\n                  var_name=\"Stat\", value_name=\"Value\")\n\n# Plot: grouped bar chart (easy \"read the data\" level)\nplt.figure(figsize=(10, 5))\nfor cls in df[\"Character_Class\"].unique():\n    subset = df_long[df_long[\"Character_Class\"] == cls]\n    plt.bar(\n        [f\"{s}\\n({cls})\" for s in subset[\"Stat\"]],\n        subset[\"Value\"],\n        label=cls\n    )\n\nplt.title(\"RPG Character Stats by Class\")\nplt.ylabel(\"Stat Value\")\nplt.xticks(rotation=0)\nplt.ylim(0, 100)\nplt.legend(title=\"Class\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using standard Matplotlib (plt.bar), which renders vertical bars. Although it uses data from two categories (Stat and Class), the code treats them as a single concatenated categorical string on the X-axis for each vertical bar, making it a standard Column chart according to the taxonomy."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare data for plotting\nstats_cols = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\nclasses = df[\"Character_Class\"].tolist()\n\nx = np.arange(len(stats_cols))\nwidth = 0.25\n\n# Plot\nfig, ax = plt.subplots(figsize=(10, 5))\n\nfor i, cls in enumerate(classes):\n    values = df.loc[df[\"Character_Class\"] == cls, stats_cols].values.flatten()\n    ax.bar(x + (i - (len(classes)-1)/2) * width, values, width=width, label=cls)\n\n# Styling\nax.set_title(\"RPG Character Stats by Class\")\nax.set_xlabel(\"Stat\")\nax.set_ylabel(\"Value\")\nax.set_xticks(x)\nax.set_xticklabels(stats_cols)\nax.set_ylim(0, 100)\nax.legend(title=\"Class\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization is created using Matplotlib's `ax.bar()` method directly. The bars are oriented vertically (Column chart), and multiple bars representing different 'Character_Class' categories are plotted side-by-side for each 'Stat', which classifies it as a Grouped column chart."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare data\nclasses = df[\"Character_Class\"].tolist()\nstats_cols = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\ndata = df[stats_cols].to_numpy()\n\n# Radar chart setup\nN = len(stats_cols)\nangles = np.linspace(0, 2 * np.pi, N, endpoint=False).tolist()\nangles += angles[:1]  # close the loop\n\nfig = plt.figure(figsize=(8, 6))\nax = plt.subplot(111, polar=True)\n\nfor i, cls in enumerate(classes):\n    values = data[i].tolist()\n    values += values[:1]  # close the loop\n    ax.plot(angles, values, linewidth=2, label=cls)\n    ax.fill(angles, values, alpha=0.15)\n\nax.set_xticks(angles[:-1])\nax.set_xticklabels(stats_cols)\nax.set_ylim(0, 100)\nax.set_yticks([20, 40, 60, 80, 100])\nax.set_title(\"RPG Character Class Stat Comparison\", pad=18)\nax.legend(loc=\"upper right\", bbox_to_anchor=(1.25, 1.1))\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Radar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.plot` and `ax.fill` methods on a subplot with `polar=True` to draw the data. This circular visualization of multiple quantitative variables (stats) across categories (classes) defines a Radar chart."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare for plotting\nstats_cols = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\nplot_df = df.set_index(\"Character_Class\")[stats_cols]\n\n# Single chart: grouped bar chart\nax = plot_df.plot(kind=\"bar\", figsize=(10, 6), width=0.8)\n\nax.set_title(\"RPG Character Class Stats\")\nax.set_xlabel(\"Character Class\")\nax.set_ylabel(\"Stat Value\")\nax.set_ylim(0, 100)\nax.legend(title=\"Stats\", ncols=3, frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas .plot(kind='bar') method to render the data, which defaults to vertical bars (column chart). Because the DataFrame contains multiple columns (stats) plotted against a categorical index (Character_Class), it results in a grouped vertical bar layout."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n    stats_cols = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\n    classes = df[\"Character_Class\"].astype(str).tolist()\n\n    # Single chart: grouped bar chart of all stats per class\n    ax = df.set_index(\"Character_Class\")[stats_cols].plot(\n        kind=\"bar\",\n        figsize=(10, 5),\n        width=0.85\n    )\n\n    ax.set_title(\"RPG Character Stats by Class\")\n    ax.set_xlabel(\"Character Class\")\n    ax.set_ylabel(\"Stat Value\")\n    ax.set_ylim(0, 100)\n    ax.legend(title=\"Stats\", ncol=5, bbox_to_anchor=(0.5, 1.15), loc=\"upper center\", frameon=False)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas DataFrame plotting wrapper (df.plot(kind='bar')). Since it plots multiple columns ('Strength', 'Agility', etc.) against a single categorical index ('Character_Class') with vertical bars, it is classified as a Grouped column chart."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare data for plotting\nstats_cols = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\ndf_plot = df.set_index(\"Character_Class\")[stats_cols]\n\n# Single chart: grouped bar chart\nax = df_plot.plot(kind=\"bar\", figsize=(10, 5), width=0.8)\n\nax.set_title(\"RPG Character Class Stats Comparison\")\nax.set_xlabel(\"Character Class\")\nax.set_ylabel(\"Stat Value\")\nax.legend(title=\"Stats\", ncol=3, frameon=True)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization is created using the pandas DataFrame plotting method `df_plot.plot(kind='bar')`. Since the bars are vertical and represent multiple columns (stats) grouped by the index (Character_Class), it is classified as a Grouped column chart."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare data for a single grouped bar chart\nmetrics = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\nplot_df = df.set_index(\"Character_Class\")[metrics]\n\n# Plot\nax = plot_df.plot(kind=\"bar\", figsize=(10, 6), width=0.8)\nax.set_title(\"RPG Character Stats by Class\")\nax.set_xlabel(\"Character Class\")\nax.set_ylabel(\"Stat Value\")\nax.legend(title=\"Stat\", ncol=2, frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas DataFrame `.plot(kind='bar')` method, which renders vertical bars. Because the plot_df contains multiple quantitative columns (Strength, Agility, etc.) for each categorical index (Character_Class), pandas generates a Grouped column chart by default."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare data\nstats = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\nclasses = df[\"Character_Class\"].tolist()\nvalues = df[stats].values\n\n# Plot: grouped bar chart\nx = np.arange(len(stats))\nwidth = 0.25\n\nfig, ax = plt.subplots(figsize=(10, 5))\nfor i, cls in enumerate(classes):\n    ax.bar(x + (i - (len(classes) - 1) / 2) * width, values[i], width, label=cls)\n\nax.set_title(\"RPG Character Class Stats Comparison\")\nax.set_xlabel(\"Stat\")\nax.set_ylabel(\"Value\")\nax.set_xticks(x)\nax.set_xticklabels(stats)\nax.set_ylim(0, 100)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nax.legend(title=\"Class\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses standard matplotlib axes functions (`ax.bar()`) to render vertical bars. It uses an offset calculation on the x-axis to group the bars by 'Character_Class', which classifies it as a Grouped column chart according to the taxonomy."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare radar chart data\nstats = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\nlabels = stats\nN = len(stats)\n\nangles = np.linspace(0, 2 * np.pi, N, endpoint=False).tolist()\nangles += angles[:1]  # close the loop\n\n# Plot\nplt.figure(figsize=(8, 6))\nax = plt.subplot(111, polar=True)\n\nfor _, row in df.iterrows():\n    values = [row[s] for s in stats]\n    values += values[:1]  # close the loop\n    ax.plot(angles, values, linewidth=2, label=row[\"Character_Class\"])\n    ax.fill(angles, values, alpha=0.12)\n\n# Styling\nax.set_title(\"RPG Character Class Stats (Radar Chart)\", pad=18, fontsize=14)\nax.set_xticks(angles[:-1])\nax.set_xticklabels(labels)\nax.set_ylim(0, 100)\nax.set_yticks([20, 40, 60, 80, 100])\nax.set_yticklabels([\"20\", \"40\", \"60\", \"80\", \"100\"])\nax.grid(True, linestyle=\"--\", alpha=0.5)\nax.legend(loc=\"upper right\", bbox_to_anchor=(1.25, 1.10), frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Radar chart", "color_palette": null, "reasoning": "The code uses matplotlib's polar projection (plt.subplot(111, polar=True)) and direct calls to ax.plot() and ax.fill() to construct the visualization, rather than using high-level wrappers from pandas or seaborn."}}
{"input_csv_file": "15_rpg_character_stats.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_rpg_character_stats.csv\")\n\n# Prepare data for a single chart (radar/spider chart)\nstats = [\"Strength\", \"Agility\", \"Intelligence\", \"Defense\", \"Stamina\"]\nlabels = stats\n\n# Angles for each axis\nimport numpy as np\nangles = np.linspace(0, 2 * np.pi, len(labels), endpoint=False).tolist()\nangles += angles[:1]  # close loop\n\nfig = plt.figure(figsize=(9, 7))\nax = plt.subplot(111, polar=True)\n\n# Plot each class\nfor _, row in df.iterrows():\n    values = row[stats].tolist()\n    values += values[:1]  # close loop\n    ax.plot(angles, values, linewidth=2, label=row[\"Character_Class\"])\n    ax.fill(angles, values, alpha=0.12)\n\n# Axis styling\nax.set_theta_offset(np.pi / 2)\nax.set_theta_direction(-1)\nax.set_thetagrids(np.degrees(angles[:-1]), labels)\n\nax.set_ylim(0, 100)\nax.set_yticks([20, 40, 60, 80, 100])\nax.set_yticklabels([\"20\", \"40\", \"60\", \"80\", \"100\"])\n\nax.set_title(\"RPG Character Class Stat Profiles\", pad=18)\nax.legend(loc=\"upper right\", bbox_to_anchor=(1.25, 1.15), frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Radar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.plot()` and `ax.fill()` on a polar coordinate system (`polar=True`) to visualize categorical attributes across quantitative dimensions, which identifies it as a radar chart. Since the data is rendered via matplotlib axes methods rather than pandas or seaborn wrappers, the library is classified as matplotlib."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Prepare radar chart data\ncategories = [\"Battery_Life\", \"Camera_Quality\", \"Performance\", \"Display\", \"Design\", \"Value_for_Money\"]\nlabels = categories\nN = len(categories)\n\nangles = [n / float(N) * 2 * 3.141592653589793 for n in range(N)]\nangles += angles[:1]  # close the loop\n\n# Plot\nfig = plt.figure(figsize=(9, 7))\nax = plt.subplot(111, polar=True)\n\nfor _, row in df.iterrows():\n    values = [row[c] for c in categories]\n    values += values[:1]  # close the loop\n    ax.plot(angles, values, linewidth=2, label=row[\"Smartphone_Model\"])\n    ax.fill(angles, values, alpha=0.08)\n\n# Style\nax.set_xticks(angles[:-1])\nax.set_xticklabels(labels)\nax.set_ylim(0, 10)\nax.set_yticks([2, 4, 6, 8, 10])\nax.set_yticklabels([\"2\", \"4\", \"6\", \"8\", \"10\"])\nax.set_title(\"Smartphone Review Scores by Category (Radar Chart)\", pad=20)\n\nax.legend(loc=\"upper left\", bbox_to_anchor=(1.05, 1.05), frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Radar chart", "color_palette": null, "reasoning": "The code uses standard matplotlib functions (plt.subplot with polar=True, ax.plot, and ax.fill) to manually render a polar visualization based on multiple quantitative categories, fitting the definition of a Radar chart."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Select one metric for a simple, direct comparison (basic/reading-the-data level)\nmetric = \"Battery_Life\"\n\n# Sort for easier reading\ndf_sorted = df.sort_values(metric, ascending=False)\n\n# Plot\nplt.figure(figsize=(8, 4.5))\nplt.bar(df_sorted[\"Smartphone_Model\"], df_sorted[metric], color=\"#4C78A8\")\nplt.title(f\"{metric.replace('_', ' ')} by Smartphone Model\")\nplt.xlabel(\"Smartphone Model\")\nplt.ylabel(\"Rating (out of 10)\")\nplt.ylim(0, 10)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the plt.bar() function directly to render data, which identifies the library as matplotlib. Since the bars are vertical (standard for plt.bar), it is classified as a Column chart according to the taxonomy. A single hex color is used rather than a named palette."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Compute an overall average score across the six review categories\nscore_cols = [\"Battery_Life\", \"Camera_Quality\", \"Performance\", \"Display\", \"Design\", \"Value_for_Money\"]\ndf[\"Average_Score\"] = df[score_cols].mean(axis=1)\n\n# Sort for readability\ndf = df.sort_values(\"Average_Score\", ascending=False)\n\n# Plot: Average score by smartphone model\nplt.figure(figsize=(8, 4.5))\nbars = plt.bar(df[\"Smartphone_Model\"], df[\"Average_Score\"], color=\"#4C78A8\")\n\nplt.title(\"Average Review Score by Smartphone Model\")\nplt.xlabel(\"Smartphone Model\")\nplt.ylabel(\"Average Score (0–10)\")\nplt.ylim(0, 10)\n\n# Add value labels on bars\nfor bar in bars:\n    y = bar.get_height()\n    plt.text(bar.get_x() + bar.get_width() / 2, y + 0.1, f\"{y:.1f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard `plt.bar()` function to render vertical bars directly from data, which identifies the library as matplotlib and the chart type as a Column chart."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Create a simple comparison chart: overall average score by smartphone model\nscore_cols = [\"Battery_Life\", \"Camera_Quality\", \"Performance\", \"Display\", \"Design\", \"Value_for_Money\"]\ndf[\"Average_Score\"] = df[score_cols].mean(axis=1)\n\n# Plot\nplt.figure(figsize=(8, 4.5))\nplt.bar(df[\"Smartphone_Model\"], df[\"Average_Score\"], color=\"#4C78A8\")\nplt.title(\"Average Review Score by Smartphone Model\")\nplt.xlabel(\"Smartphone Model\")\nplt.ylabel(\"Average Score (0–10)\")\nplt.ylim(0, 10)\n\nfor i, v in enumerate(df[\"Average_Score\"]):\n    plt.text(i, v + 0.15, f\"{v:.2f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to draw vertical bars, which classifies the library as matplotlib and the chart type as a Column chart according to the taxonomy."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Compute overall average score per smartphone (across all rating columns)\nrating_cols = [\"Battery_Life\", \"Camera_Quality\", \"Performance\", \"Display\", \"Design\", \"Value_for_Money\"]\ndf[\"Overall_Score\"] = df[rating_cols].mean(axis=1)\n\n# Sort for cleaner visualization\ndf = df.sort_values(\"Overall_Score\", ascending=False)\n\n# Plot: Overall score by smartphone model\nplt.figure(figsize=(8, 4.5))\nbars = plt.bar(df[\"Smartphone_Model\"], df[\"Overall_Score\"], color=\"#4C78A8\")\n\nplt.title(\"Overall Smartphone Review Score (Average of All Categories)\")\nplt.xlabel(\"Smartphone Model\")\nplt.ylabel(\"Average Score\")\nplt.ylim(0, 10)\n\n# Add value labels\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h + 0.1, f\"{h:.2f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.bar() to render the data directly. Since plt.bar() produces vertical bars by default, it is classified as a Column chart."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Set index for plotting\ndf = df.set_index(\"Smartphone_Model\")\n\n# Create a single chart: grouped bar chart for all metrics by model\nax = df.plot(kind=\"bar\", figsize=(11, 6), width=0.85)\n\nax.set_title(\"Smartphone Review Scores by Model\")\nax.set_xlabel(\"Smartphone Model\")\nax.set_ylabel(\"Score\")\nax.set_ylim(0, 10)\nax.legend(title=\"Metric\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization is created using the pandas DataFrame plotting wrapper 'df.plot(kind=\"bar\")'. In pandas, 'kind=\"bar\"' defaults to vertical bars (which are 'Column charts' in this taxonomy), and because the DataFrame contains multiple columns plotted against the index, it produces a grouped layout."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Use Smartphone_Model as index for plotting\ndf = df.set_index(\"Smartphone_Model\")\n\n# Create a single chart: radar/spider chart comparing all models across review categories\ncategories = list(df.columns)\nN = len(categories)\n\n# Angles for each axis\nangles = [n / float(N) * 2 * 3.141592653589793 for n in range(N)]\nangles += angles[:1]  # close the loop\n\nfig = plt.figure(figsize=(9, 7))\nax = plt.subplot(111, polar=True)\n\n# Plot each smartphone model\nfor model, row in df.iterrows():\n    values = row.tolist()\n    values += values[:1]  # close the loop\n    ax.plot(angles, values, linewidth=2, label=model)\n    ax.fill(angles, values, alpha=0.08)\n\n# Axis labels\nax.set_xticks(angles[:-1])\nax.set_xticklabels(categories)\nax.set_ylim(0, 10)\nax.set_yticks([2, 4, 6, 8, 10])\nax.set_yticklabels([\"2\", \"4\", \"6\", \"8\", \"10\"])\n\nax.set_title(\"Smartphone Review Scores (Radar Chart)\", pad=18)\nax.legend(loc=\"upper right\", bbox_to_anchor=(1.25, 1.15), frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Radar chart", "color_palette": null, "reasoning": "The code creates a circular visualization using a polar coordinate system (polar=True) with multiple axes representing review categories, which matches the definition of a Radar chart. It uses matplotlib's direct plotting functions (ax.plot and ax.fill) rather than high-level wrappers."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n    metrics = [\"Battery_Life\", \"Camera_Quality\", \"Performance\", \"Display\", \"Design\", \"Value_for_Money\"]\n    df[\"Overall_Score\"] = df[metrics].mean(axis=1)\n\n    df_sorted = df.sort_values(\"Overall_Score\", ascending=False)\n\n    plt.figure(figsize=(10, 5))\n    plt.bar(df_sorted[\"Smartphone_Model\"], df_sorted[\"Overall_Score\"], color=\"#4C78A8\")\n    plt.title(\"Overall Smartphone Review Score (Average of Metrics)\")\n    plt.xlabel(\"Smartphone Model\")\n    plt.ylabel(\"Overall Score (0–10)\")\n    plt.ylim(0, 10)\n    plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render vertical bars from a categorical and quantitative variable, which classifies it as a Column chart using the matplotlib library."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Preparar datos: promedio de las métricas por smartphone\nmetrics = [\"Battery_Life\", \"Camera_Quality\", \"Performance\", \"Display\", \"Design\", \"Value_for_Money\"]\ndf[\"Average_Score\"] = df[metrics].mean(axis=1)\n\n# Ordenar para una visualización más clara\ndf = df.sort_values(\"Average_Score\", ascending=False)\n\n# Graficar (un solo gráfico)\nplt.figure(figsize=(9, 5))\nplt.bar(df[\"Smartphone_Model\"], df[\"Average_Score\"], color=\"#4C78A8\")\nplt.title(\"Puntuación promedio por modelo de smartphone\")\nplt.xlabel(\"Modelo\")\nplt.ylabel(\"Puntuación promedio (0–10)\")\nplt.ylim(0, 10)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C78A8", "reasoning": "The code uses the plt.bar() function directly from the matplotlib.pyplot library to render vertical bars, making it a Column chart. Although pandas is used for data manipulation, the rendering is done via matplotlib."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Prepare long-form for plotting\nmetrics = [\"Battery_Life\", \"Camera_Quality\", \"Performance\", \"Display\", \"Design\", \"Value_for_Money\"]\nlong = df.melt(id_vars=\"Smartphone_Model\", value_vars=metrics, var_name=\"Metric\", value_name=\"Score\")\n\n# Plot: heatmap of scores by model and metric (single chart)\npivot = long.pivot(index=\"Smartphone_Model\", columns=\"Metric\", values=\"Score\").loc[df[\"Smartphone_Model\"]]\n\nsns.set_theme(style=\"white\", context=\"notebook\")\nfig, ax = plt.subplots(figsize=(11, 3.6), dpi=160)\n\nsns.heatmap(\n    pivot,\n    ax=ax,\n    cmap=\"YlGnBu\",\n    vmin=5.5,\n    vmax=10.0,\n    annot=True,\n    fmt=\".1f\",\n    linewidths=0.8,\n    linecolor=\"white\",\n    cbar_kws={\"label\": \"Score (0–10)\", \"shrink\": 0.9},\n)\n\nax.set_title(\"Smartphone Review Scores by Category\", pad=10, weight=\"bold\")\nax.set_xlabel(\"\")\nax.set_ylabel(\"\")\nax.tick_params(axis=\"x\", rotation=25, labelsize=9)\nax.tick_params(axis=\"y\", rotation=0, labelsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "XY Heatmap chart", "color_palette": "YlGnBu", "reasoning": "The plot is rendered using the sns.heatmap() function from the seaborn library. The data structure consists of two categorical dimensions (Smartphone_Model and Metric) with quantitative values (Score) encoded via a color scale, which aligns with the XY Heatmap chart definition."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Prepare radar chart data\ncategories = [\"Battery_Life\", \"Camera_Quality\", \"Performance\", \"Display\", \"Design\", \"Value_for_Money\"]\nlabels = [\"Battery Life\", \"Camera Quality\", \"Performance\", \"Display\", \"Design\", \"Value for Money\"]\n\nangles = np.linspace(0, 2 * np.pi, len(categories), endpoint=False).tolist()\nangles += angles[:1]  # close the loop\n\nfig = plt.figure(figsize=(9, 7))\nax = plt.subplot(111, polar=True)\n\n# Style\nax.set_theta_offset(np.pi / 2)\nax.set_theta_direction(-1)\n\n# Axis labels\nax.set_xticks(angles[:-1])\nax.set_xticklabels(labels, fontsize=10)\nax.set_ylim(0, 10)\nax.set_yticks([2, 4, 6, 8, 10])\nax.set_yticklabels([\"2\", \"4\", \"6\", \"8\", \"10\"], fontsize=9)\nax.grid(True, alpha=0.35)\n\n# Plot each smartphone\ncolors = plt.cm.Set2(np.linspace(0, 1, df.shape[0]))\nfor (idx, row), c in zip(df.iterrows(), colors):\n    values = row[categories].tolist()\n    values += values[:1]\n    ax.plot(angles, values, linewidth=2, color=c, label=row[\"Smartphone_Model\"])\n    ax.fill(angles, values, color=c, alpha=0.12)\n\n# Title & legend\nax.set_title(\"Smartphone Review Scores by Category (0–10)\", fontsize=14, pad=18)\nax.legend(loc=\"upper left\", bbox_to_anchor=(1.05, 1.05), frameon=False, title=\"Model\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Radar chart", "color_palette": "Set2", "reasoning": "The visualization is constructed using standard Matplotlib functions (plt.subplot with polar=True, ax.plot, and ax.fill) rather than high-level wrappers from Pandas or Seaborn."}}
{"input_csv_file": "15_smartphone_reviews.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"15_smartphone_reviews.csv\")\n\n# Prepare radar chart data\ncategories = [\"Battery_Life\", \"Camera_Quality\", \"Performance\", \"Display\", \"Design\", \"Value_for_Money\"]\nN = len(categories)\nangles = np.linspace(0, 2 * np.pi, N, endpoint=False).tolist()\nangles += angles[:1]  # close the loop\n\nfig = plt.figure(figsize=(9, 7))\nax = plt.subplot(111, polar=True)\n\n# Plot each smartphone\nfor _, row in df.iterrows():\n    values = row[categories].tolist()\n    values += values[:1]  # close the loop\n    ax.plot(angles, values, linewidth=2, label=row[\"Smartphone_Model\"])\n    ax.fill(angles, values, alpha=0.08)\n\n# Styling\nax.set_theta_offset(np.pi / 2)\nax.set_theta_direction(-1)\nax.set_xticks(angles[:-1])\nax.set_xticklabels([c.replace(\"_\", \" \") for c in categories])\nax.set_ylim(0, 10)\nax.set_yticks([2, 4, 6, 8, 10])\nax.set_yticklabels([\"2\", \"4\", \"6\", \"8\", \"10\"])\nax.grid(True, linewidth=0.8, alpha=0.6)\n\nplt.title(\"Smartphone Review Ratings Comparison (Radar Chart)\", pad=18)\nplt.legend(loc=\"upper right\", bbox_to_anchor=(1.25, 1.15), frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Radar chart", "color_palette": null, "reasoning": "The visualization is constructed using standard matplotlib pyplot and axes functions (plt.subplot with polar=True, ax.plot, and ax.fill) to render the data manually on a polar coordinate system."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"16myfileDotPlot2Values_edit.csv\"\ndf = pd.read_csv(csv_path)\n\n# Basic validation\nrequired_cols = {\"A\", \"B\"}\nmissing = required_cols - set(df.columns)\nif missing:\n    raise ValueError(f\"Missing required columns: {missing}\")\n\n# Plot: dot plot (strip plot style) of B by category A\nfig, ax = plt.subplots(figsize=(8, 4.5))\nax.scatter(df[\"A\"], df[\"B\"], s=80, alpha=0.85)\n\nax.set_title(\"Dot Plot of B by Category A\")\nax.set_xlabel(\"A\")\nax.set_ylabel(\"B\")\nax.grid(axis=\"y\", linestyle=\"--\", linewidth=0.6, alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses the Matplotlib library directly via ax.scatter() to plot data. It is classified as a Dot plot because it uses a scatterplot-like representation where one dimension (A) is categorical and the other (B) is quantitative, aligning with the taxonomy definition for Dot plots."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Prepare categories in a sensible order and positions\ncats = sorted(df[\"A\"].unique())\ncat_to_x = {cat: i for i, cat in enumerate(cats)}\nx = df[\"A\"].map(cat_to_x).values\ny = df[\"B\"].values\n\n# Create a simple dot plot (strip plot)\nplt.figure(figsize=(8, 4.5))\nplt.scatter(x, y, s=80, alpha=0.85)\n\n# Format axes\nplt.xticks(range(len(cats)), cats)\nplt.xlabel(\"Category (A)\")\nplt.ylabel(\"Value (B)\")\nplt.title(\"Dot Plot of B by Category A\")\n\n# Light grid for readability\nplt.grid(axis=\"y\", linestyle=\"--\", linewidth=0.7, alpha=0.5)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses plt.scatter() directly to render the data points. The X-axis represents discrete categorical variables (mapped to integers) and the Y-axis represents quantitative values, which aligns with the taxonomy definition of a Dot plot as a scatterplot where one dimension is discrete/categorical."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Ensure numeric column\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"B\"])\n\n# Sort by category for cleaner reading\ndf = df.sort_values([\"A\", \"B\"]).reset_index(drop=True)\n\n# Dot plot: one dot per row, positioned by value (B) and grouped by category (A)\ncategories = sorted(df[\"A\"].astype(str).unique())\ncat_to_y = {cat: i for i, cat in enumerate(categories)}\ny = df[\"A\"].astype(str).map(cat_to_y)\n\nplt.figure(figsize=(8, 4.5))\nplt.scatter(df[\"B\"], y, s=80)\n\nplt.yticks(range(len(categories)), categories)\nplt.xlabel(\"B (value)\")\nplt.ylabel(\"A (category)\")\nplt.title(\"Dot Plot of B Values by Category A\")\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The visualization is created using the plt.scatter() function from the matplotlib library. It plots quantitative values (B) against discrete categorical values (A) mapped to an integer Y-axis, which matches the taxonomy definition for a Dot plot."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Ensure numeric\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\n\n# Create a dot plot (strip plot style) by category A\ncats = sorted(df[\"A\"].astype(str).unique())\nxpos = {c: i for i, c in enumerate(cats)}\n\nplt.figure(figsize=(8, 4.5))\nfor c in cats:\n    sub = df[df[\"A\"].astype(str) == c]\n    plt.scatter([xpos[c]] * len(sub), sub[\"B\"], s=70)\n\nplt.xticks(range(len(cats)), cats)\nplt.xlabel(\"A (category)\")\nplt.ylabel(\"B (value)\")\nplt.title(\"Dot Plot of B by Category A\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses plt.scatter() from matplotlib directly to render the data. The visualization displays a quantitative variable (B) against discrete categories (A), which fits the taxonomy definition of a Dot plot (a scatterplot where one axis is discrete)."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Ensure correct types\ndf[\"A\"] = df[\"A\"].astype(str)\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\n\n# Dot plot: one dot per row, grouped by category A\nfig, ax = plt.subplots(figsize=(7, 4))\n\ncategories = sorted(df[\"A\"].unique())\ncat_to_x = {cat: i for i, cat in enumerate(categories)}\n\nx = df[\"A\"].map(cat_to_x)\nax.scatter(x, df[\"B\"], s=60, alpha=0.85)\n\nax.set_xticks(range(len(categories)))\nax.set_xticklabels(categories)\nax.set_xlabel(\"A\")\nax.set_ylabel(\"B\")\nax.set_title(\"Dot Plot of B by A\")\nax.grid(axis=\"y\", linestyle=\"--\", linewidth=0.6, alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses ax.scatter() from matplotlib to visualize a categorical variable against a quantitative variable, which fits the taxonomy definition for a Dot plot. It is classified as matplotlib because it uses the library's axes-level functions directly rather than pandas or seaborn wrappers."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Create dot plot (strip plot style)\ncats = sorted(df[\"A\"].unique())\nx_map = {c: i for i, c in enumerate(cats)}\nx = df[\"A\"].map(x_map)\n\nplt.figure(figsize=(7, 4.5))\nplt.scatter(x, df[\"B\"], s=70, alpha=0.85)\n\nplt.xticks(range(len(cats)), cats)\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\nplt.title(\"Dot Plot of B by Category A\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The data is rendered using plt.scatter() directly from matplotlib. The x-axis is discrete (categorical values mapped to integers) and the y-axis is quantitative, which corresponds to the taxonomy definition of a Dot plot."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Ensure correct dtypes\ndf[\"A\"] = df[\"A\"].astype(str)\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\n\n# Plot (single chart): Dot plot / strip plot-like scatter by category\ncats = sorted(df[\"A\"].unique())\nx_map = {c: i for i, c in enumerate(cats)}\nx = df[\"A\"].map(x_map)\n\nplt.figure(figsize=(7, 4))\nplt.scatter(x, df[\"B\"], s=70)\n\nplt.xticks(range(len(cats)), cats)\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\nplt.title(\"Dot Plot of B by A\")\nplt.grid(axis=\"y\", alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses plt.scatter() directly to render the data, which falls under matplotlib according to the hierarchy. The visualization maps a categorical variable (A) to the X-axis and a quantitative variable (B) to the Y-axis using points, which matches the definition of a Dot plot."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Dot plot (strip plot-like) per category\norder = sorted(df[\"A\"].unique())\nx_pos = df[\"A\"].map({k: i for i, k in enumerate(order)})\n\nplt.figure(figsize=(7, 4))\nplt.scatter(x_pos, df[\"B\"], s=60, alpha=0.85)\n\nplt.xticks(range(len(order)), order)\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\nplt.title(\"Dot Plot of B by A\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses plt.scatter() directly to render the data points, which qualifies as matplotlib according to the hierarchy. The visualization maps a categorical variable (mapped to numerical positions on the X-axis) against a quantitative variable (Y-axis), which fits the taxonomy definition of a Dot plot."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Dot plot: B values per category A (strip-style with deterministic offsets)\ndf = df.copy()\ndf[\"A\"] = df[\"A\"].astype(str)\n\norder = sorted(df[\"A\"].unique())\nxpos = {cat: i for i, cat in enumerate(order)}\ndf[\"x\"] = df[\"A\"].map(xpos)\n\n# Add small deterministic horizontal offsets within each category\ndf[\"offset\"] = df.groupby(\"A\").cumcount()\ndf[\"offset_centered\"] = df.groupby(\"A\")[\"offset\"].transform(lambda s: s - (len(s) - 1) / 2)\njitter_width = 0.18\ndf[\"xj\"] = df[\"x\"] + df[\"offset_centered\"] * (jitter_width / max(df[\"offset_centered\"].abs().max(), 1))\n\n# Plot\nfig, ax = plt.subplots(figsize=(7.5, 4.5))\nax.scatter(df[\"xj\"], df[\"B\"], s=70)\n\nax.set_xticks(range(len(order)))\nax.set_xticklabels(order)\nax.set_xlabel(\"A\")\nax.set_ylabel(\"B\")\nax.set_title(\"Dot plot de B por categoría A\")\n\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The data is rendered using the matplotlib axes method `ax.scatter()` directly rather than a pandas or seaborn wrapper. The visualization maps a categorical variable (A) to the x-axis and a quantitative variable (B) to the y-axis, which corresponds to the Dot plot definition."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Preserve original order of categories as they appear in the CSV\norder = pd.unique(df[\"A\"])\ncat_to_x = {cat: i for i, cat in enumerate(order)}\nx = df[\"A\"].map(cat_to_x)\n\n# Plot: dot plot (strip plot style) with slight horizontal jitter\nplt.figure(figsize=(7.5, 4.5), dpi=140)\njitter = (pd.Series(range(len(df))) % 5 - 2) * 0.04  # deterministic jitter\nplt.scatter(x + jitter, df[\"B\"], s=60, alpha=0.85)\n\n# Styling\nplt.xticks(range(len(order)), order)\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\nplt.title(\"Dot Plot of B by A\")\nplt.grid(axis=\"y\", linestyle=\"--\", linewidth=0.7, alpha=0.35)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses matplotlib's plt.scatter() function to render the data. It maps a categorical variable (A) to the X-axis and a quantitative variable (B) to the Y-axis, which matches the taxonomy's definition for a Dot plot (a scatterplot involving a discrete dimension)."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Ensure correct dtypes\ndf[\"A\"] = df[\"A\"].astype(str)\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\n\n# Plot: dot plot with slight horizontal jitter for repeated categories\ncats = sorted(df[\"A\"].unique())\ncat_to_x = {c: i for i, c in enumerate(cats)}\n\nx = df[\"A\"].map(cat_to_x).astype(float)\n# deterministic jitter based on row order within each category\ndf[\"_rank\"] = df.groupby(\"A\").cumcount()\ndf[\"_n\"] = df.groupby(\"A\")[\"A\"].transform(\"size\")\njitter = (df[\"_rank\"] - (df[\"_n\"] - 1) / 2) * 0.10  # spread points if duplicates\nxj = x + jitter\n\nfig, ax = plt.subplots(figsize=(7.5, 4.5))\nax.scatter(xj, df[\"B\"], s=90, alpha=0.9, edgecolor=\"white\", linewidth=0.9)\n\nax.set_xticks(range(len(cats)))\nax.set_xticklabels(cats)\nax.set_xlabel(\"A\")\nax.set_ylabel(\"B\")\nax.set_title(\"Dot Plot of B by Category A\")\n\nax.grid(True, axis=\"y\", linestyle=\"--\", linewidth=0.8, alpha=0.35)\nax.set_axisbelow(True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses the standard matplotlib axes function ax.scatter() to plot categorical data (mapped to numeric indices with jitter) against quantitative values. According to the taxonomy, a scatterplot where one axis is discrete/categorical is classified as a Dot plot."}}
{"input_csv_file": "16myfileDotPlot2Values_edit.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot2Values_edit.csv\")\n\n# Preserve category order as it appears in the file\ncats = pd.Categorical(df[\"A\"], categories=pd.unique(df[\"A\"]), ordered=True)\ndf[\"A\"] = cats\n\n# Build dot plot (strip plot style)\nplt.figure(figsize=(7.5, 4.5), dpi=140)\nx = df[\"A\"].cat.codes\n\nplt.scatter(\n    x,\n    df[\"B\"],\n    s=90,\n    c=\"#1f77b4\",\n    alpha=0.9,\n    edgecolors=\"white\",\n    linewidths=0.8,\n)\n\n# Axis formatting\nplt.xticks(range(len(df[\"A\"].cat.categories)), df[\"A\"].cat.categories)\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\nplt.title(\"Dot plot of B by A\")\n\n# Subtle grid for readability\nplt.grid(axis=\"y\", color=\"#d9d9d9\", linewidth=0.8, alpha=0.8)\nplt.grid(axis=\"x\", visible=False)\n\n# Clean spines\nax = plt.gca()\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "Used plt.scatter() with categorical data mapped to numerical codes on the x-axis, creating a Dot plot as defined in the taxonomy. The use of plt.scatter() directly classifies the library as matplotlib."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Ensure correct types\ndf[\"A\"] = df[\"A\"].astype(str)\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\n\n# Plot: dot plot (strip plot) of B by category A\nplt.figure(figsize=(8, 4.8))\nsns.stripplot(\n    data=df,\n    x=\"A\",\n    y=\"B\",\n    order=sorted(df[\"A\"].unique()),\n    jitter=0.18,\n    size=7,\n    alpha=0.85,\n    color=\"#1f77b4\"\n)\n\nplt.title(\"Dot Plot of B by Category A\")\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The plot is created using seaborn's `sns.stripplot` function, which maps a categorical variable ('A') and a quantitative variable ('B'). This aligns with the 'Dot plot' definition (scatterplot where one dimension is discrete). According to the hierarchy rules, since an 'sns.' function is used to draw the data, the library is classified as 'seaborn'."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Order categories (A) alphabetically for an easy-to-read display\norder = sorted(df[\"A\"].unique())\ndf[\"A\"] = pd.Categorical(df[\"A\"], categories=order, ordered=True)\ndf = df.sort_values(\"A\")\n\n# Create dot plot (strip plot style)\nplt.figure(figsize=(7, 4.5))\nplt.scatter(df[\"B\"], df[\"A\"], s=60, alpha=0.8)\n\nplt.title(\"Dot Plot of B by Category A\")\nplt.xlabel(\"B\")\nplt.ylabel(\"A\")\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The data is plotted using the plt.scatter() function from the matplotlib library. Since the Y-axis ('A') represents discrete categories and the X-axis ('B') is quantitative, it fits the taxonomy definition of a Dot plot."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Ensure expected columns exist\nif not {\"A\", \"B\"}.issubset(df.columns):\n    raise ValueError(\"CSV must contain columns 'A' and 'B'.\")\n\n# Build dot-plot style chart (scatter) grouped by category A\ncats = sorted(df[\"A\"].astype(str).unique())\nx_map = {c: i for i, c in enumerate(cats)}\nx = df[\"A\"].astype(str).map(x_map)\n\nplt.figure(figsize=(8, 4.5))\nplt.scatter(x, df[\"B\"], s=70, alpha=0.85)\n\nplt.xticks(range(len(cats)), cats)\nplt.xlabel(\"Category (A)\")\nplt.ylabel(\"Value (B)\")\nplt.title(\"Dot Plot of B by Category A\")\n\nplt.grid(axis=\"y\", linestyle=\"--\", linewidth=0.6, alpha=0.5)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The visualization uses the `plt.scatter` function from the matplotlib library to render points. Since the X-axis is discrete/categorical (derived from mapping unique strings to indices) and the Y-axis is quantitative, it fits the taxonomy definition for a Dot plot."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Prepare a simple dot plot grouped by category in column A\ncategories = sorted(df[\"A\"].unique())\ny_map = {cat: i for i, cat in enumerate(categories)}\n\nx = df[\"B\"].values\ny = df[\"A\"].map(y_map).values\n\nplt.figure(figsize=(8, 4.5))\nplt.scatter(x, y, s=70, alpha=0.85)\n\nplt.yticks(range(len(categories)), categories)\nplt.xlabel(\"B\")\nplt.ylabel(\"A\")\nplt.title(\"Dot Plot of B by Category A\")\n\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The plot is rendered using the standard matplotlib.pyplot.scatter function. It is classified as a Dot plot because the Y-axis represents discrete categories (mapped from string labels to integers) and the X-axis is a quantitative variable."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Ensure expected columns\ndf = df[[\"A\", \"B\"]].copy()\ndf[\"A\"] = df[\"A\"].astype(str)\n\n# Order categories (alphabetical)\ncats = sorted(df[\"A\"].unique())\nxpos = {c: i for i, c in enumerate(cats)}\n\n# Jitter for dot plot\nrng = np.random.default_rng(42)\nx = df[\"A\"].map(xpos).to_numpy(dtype=float)\nx_jitter = x + rng.uniform(-0.12, 0.12, size=len(df))\n\n# Plot (single chart)\nfig, ax = plt.subplots(figsize=(7, 4))\nax.scatter(x_jitter, df[\"B\"], s=60, alpha=0.85)\n\nax.set_xticks(range(len(cats)))\nax.set_xticklabels(cats)\nax.set_xlabel(\"A\")\nax.set_ylabel(\"B\")\nax.set_title(\"Dot Plot of B by Category A\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The plot is rendered using the standard matplotlib `ax.scatter()` method. It visualizes a quantitative variable ('B') against categorical labels ('A') which are mapped to numerical positions with jitter, which aligns with the taxonomy definition of a Dot plot."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Dot plot (strip plot style)\norder = sorted(df[\"A\"].unique())\nx_pos = {cat: i for i, cat in enumerate(order)}\nx = df[\"A\"].map(x_pos)\n\nplt.figure(figsize=(8, 4.5))\nplt.scatter(x, df[\"B\"], s=70, alpha=0.85)\n\nplt.xticks(range(len(order)), order)\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\nplt.title(\"Dot Plot of B by A\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses the standard matplotlib function plt.scatter() to draw data points. Since one dimension (x) is derived from a categorical variable ('A') and the other is quantitative ('B'), it is classified as a Dot plot according to the taxonomy. It is categorized as 'matplotlib' because no seaborn or pandas plotting functions were used to render the data."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Ensure correct types\ndf[\"A\"] = df[\"A\"].astype(str)\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"B\"])\n\n# Keep a stable category order (alphabetical)\norder = sorted(df[\"A\"].unique())\ndf[\"A\"] = pd.Categorical(df[\"A\"], categories=order, ordered=True)\n\n# Dot plot (strip chart) with slight vertical jitter per category\ncat_to_y = {cat: i for i, cat in enumerate(order)}\ny = df[\"A\"].map(cat_to_y).astype(float)\njitter = 0.12\ny_jittered = y + (pd.Series(range(len(df))) % 7 - 3) * (jitter / 3)\n\nplt.figure(figsize=(8, 4.5))\nplt.scatter(df[\"B\"], y_jittered, s=55, alpha=0.85)\n\nplt.yticks(range(len(order)), order)\nplt.xlabel(\"B\")\nplt.ylabel(\"A\")\nplt.title(\"Dot Plot of B by A\")\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The data is rendered using the plt.scatter() function from matplotlib. The visualization maps a quantitative variable to the X-axis and a categorical variable (with jitter) to the Y-axis, which matches the definition of a Dot plot in the provided taxonomy."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Create a single dot plot (strip plot style) by category A vs numeric B\nplt.figure(figsize=(8, 4.5))\nplt.scatter(df[\"A\"], df[\"B\"], s=60, alpha=0.8)\n\nplt.title(\"Dot Plot of B by Category A\")\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses the plt.scatter() function from the matplotlib library to visualize the relationship between a categorical variable (A) and a quantitative variable (B), which fits the taxonomy definition for a Dot plot."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load CSV\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Ensure correct dtypes\ndf[\"A\"] = df[\"A\"].astype(str)\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\n\n# Plot: dot plot (strip plot) of B by category A\nplt.figure(figsize=(8, 4.5))\nsns.stripplot(\n    data=df,\n    x=\"A\",\n    y=\"B\",\n    jitter=0.18,\n    size=7,\n    alpha=0.85,\n    color=\"#1f77b4\"\n)\n\nplt.title(\"Dot Plot de B por categoría A\")\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\nplt.grid(axis=\"y\", linestyle=\"--\", linewidth=0.7, alpha=0.5)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses sns.stripplot() to visualize categorical data (A) against quantitative data (B). According to the taxonomy, scatterplots with a discrete axis are classified as Dot plots. Since the data rendering is performed by a seaborn function, it is classified as 'seaborn' regardless of matplotlib usage for styling."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Ensure correct dtypes\ndf[\"A\"] = df[\"A\"].astype(str)\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\n\n# Order categories by median B (ties broken alphabetically) for an informative dot plot\norder = (\n    df.groupby(\"A\")[\"B\"]\n      .median()\n      .sort_values(ascending=False)\n      .reset_index()\n)\norder = order.sort_values([\"B\", \"A\"], ascending=[False, True])[\"A\"].tolist()\n\n# Build the dot plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(8.5, 5))\n\nax.scatter(\n    df[\"B\"],\n    pd.Categorical(df[\"A\"], categories=order, ordered=True),\n    s=70,\n    color=\"#2A6F97\",\n    edgecolor=\"white\",\n    linewidth=0.7,\n    alpha=0.9,\n)\n\n# Formatting\nax.set_title(\"Dot Plot of B by Category A\", pad=10, fontsize=13, weight=\"semibold\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\n# Nice x-limits with padding\nbmin, bmax = df[\"B\"].min(), df[\"B\"].max()\npad = max(5, int((bmax - bmin) * 0.05))\nax.set_xlim(bmin - pad, bmax + pad)\n\n# Lighten spines\nfor spine in [\"top\", \"right\"]:\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses the matplotlib Axes method `ax.scatter()` to render data. Since the X-axis is quantitative and the Y-axis is categorical, it is classified as a Dot plot according to the taxonomy. Following the hierarchy rules, even though a seaborn style is used for the background, the direct use of a matplotlib function for plotting makes the library matplotlib."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Ensure correct dtypes\ndf[\"A\"] = df[\"A\"].astype(str)\ndf[\"B\"] = pd.to_numeric(df[\"B\"], errors=\"coerce\")\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(8, 4.5), dpi=140)\n\norder = sorted(df[\"A\"].unique())\nsns.stripplot(\n    data=df, x=\"A\", y=\"B\",\n    order=order,\n    jitter=0.18,\n    size=7,\n    alpha=0.9,\n    color=\"#2a6fbb\",\n    ax=ax\n)\n\nax.set_title(\"Dot Plot of B by Category A\", pad=10)\nax.set_xlabel(\"A\")\nax.set_ylabel(\"B\")\nax.set_ylim(0, max(105, df[\"B\"].max() + 5))\n\nsns.despine(left=False, bottom=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The data is rendered using sns.stripplot(), which identifies the library as 'seaborn' according to the hierarchy rules. The taxonomy defines a 'Dot plot' as a scatterplot where one axis (Y in the definition, X in this code) may be discrete/categorical, which is the exact behavior of a stripplot."}}
{"input_csv_file": "16myfileDotPlot_edit.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"16myfileDotPlot_edit.csv\")\n\n# Consistent category order\ncat_order = sorted(df[\"A\"].astype(str).unique())\n\n# Style\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\n\n# Single chart: dot plot (strip plot) of B by category A\nfig, ax = plt.subplots(figsize=(10, 5))\nsns.stripplot(\n    data=df,\n    x=\"A\",\n    y=\"B\",\n    order=cat_order,\n    jitter=0.22,\n    size=9,\n    alpha=0.9,\n    color=\"#1f77b4\",\n    ax=ax\n)\n\n# Labels and polish\nax.set_title(\"Dot Plot of B by Category A\")\nax.set_xlabel(\"A (Category)\")\nax.set_ylabel(\"B\")\nax.set_ylim(-2, max(df[\"B\"]) * 1.08)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses sns.stripplot to render categorical data points against a quantitative variable, which aligns with the taxonomy definition for a Dot plot. The library is classified as seaborn because the sns. plotting function is used for data visualization."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    # Load CSV\n    df = pd.read_csv(\"16us_census_edu.csv\")\n\n    # Prepare data\n    df[\"Difference (Men - Women)\"] = df[\"Men\"] - df[\"Women\"]\n\n    # Plot: grouped horizontal bars for Women vs Men\n    fig, ax = plt.subplots(figsize=(10, 5.8))\n    y = range(len(df))\n\n    bar_h = 0.38\n    ax.barh([i - bar_h/2 for i in y], df[\"Women\"], height=bar_h, label=\"Women\")\n    ax.barh([i + bar_h/2 for i in y], df[\"Men\"], height=bar_h, label=\"Men\")\n\n    ax.set_yticks(list(y))\n    ax.set_yticklabels(df[\"Education\"])\n    ax.invert_yaxis()  # top category at top\n\n    ax.set_xlabel(\"Median earnings (USD)\")\n    ax.set_title(\"US Median Earnings by Education Level and Gender\")\n\n    # Light formatting\n    ax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n    ax.legend(frameon=False)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.barh()` function directly to render data. It creates horizontal bars with manual offset calculations (`i - bar_h/2` and `i + bar_h/2`) to group two categories (Women and Men) per education level, fitting the 'Grouped bar chart' definition."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Plot: grouped bar chart comparing Women vs Men by education level\nx = range(len(df[\"Education\"]))\nwidth = 0.42\n\nplt.figure(figsize=(12, 6))\nplt.bar([i - width/2 for i in x], df[\"Women\"], width=width, label=\"Women\")\nplt.bar([i + width/2 for i in x], df[\"Men\"], width=width, label=\"Men\")\n\nplt.title(\"Median Earnings by Education Level (Women vs Men)\")\nplt.xlabel(\"Education Level\")\nplt.ylabel(\"Median Earnings (USD)\")\nplt.xticks(list(x), df[\"Education\"], rotation=35, ha=\"right\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses plt.bar() from matplotlib directly to draw vertical bars. By calculating offsets for the x-positions (i - width/2 and i + width/2), it creates a grouped layout comparing two series ('Women' and 'Men') across education levels."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Prepare plot data\nx = range(len(df[\"Education\"]))\nwomen = df[\"Women\"]\nmen = df[\"Men\"]\n\n# Create chart (single chart)\nplt.figure(figsize=(12, 6))\nplt.plot(x, women, marker=\"o\", linewidth=2, label=\"Women\")\nplt.plot(x, men, marker=\"o\", linewidth=2, label=\"Men\")\n\nplt.title(\"Median Earnings by Education Level (Women vs Men)\")\nplt.xlabel(\"Education Level\")\nplt.ylabel(\"Median Earnings (USD)\")\nplt.xticks(x, df[\"Education\"], rotation=35, ha=\"right\")\nplt.grid(True, axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses matplotlib's plt.plot() directly to render data as lines with markers, plotting categorical education levels against quantitative median earnings."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Plot: compare Women vs Men by education level\nplt.figure(figsize=(11, 6))\nx = range(len(df))\n\nplt.bar([i - 0.2 for i in x], df[\"Women\"], width=0.4, label=\"Women\")\nplt.bar([i + 0.2 for i in x], df[\"Men\"], width=0.4, label=\"Men\")\n\nplt.xticks(list(x), df[\"Education\"], rotation=30, ha=\"right\")\nplt.ylabel(\"Median earnings (USD)\")\nplt.title(\"2016 US Census: Median Earnings by Education Level and Gender\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's plt.bar() function directly to render data. Since it creates vertical bars grouped side-by-side using manual x-axis offsets for two categories (Women and Men), it is classified as a Grouped column chart."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Ensure correct order (as provided)\ndf[\"Education\"] = pd.Categorical(df[\"Education\"], categories=df[\"Education\"].tolist(), ordered=True)\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 5.5))\n\nax.plot(df[\"Education\"], df[\"Women\"], marker=\"o\", linewidth=2, label=\"Women\")\nax.plot(df[\"Education\"], df[\"Men\"], marker=\"o\", linewidth=2, label=\"Men\")\n\nax.set_title(\"Median Earnings by Education Level (2016 US Census)\")\nax.set_xlabel(\"Education\")\nax.set_ylabel(\"Median earnings (USD)\")\nax.tick_params(axis=\"x\", rotation=25)\nax.legend(frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is drawn using the matplotlib axes method ax.plot(). Although seaborn is used for styling with set_theme, the actual rendering of the quantitative earnings data across categorical education levels is done via matplotlib, classifying it as a Line chart."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Plot: grouped horizontal bar chart comparing Women vs Men by education level\ny = np.arange(len(df))\nbar_h = 0.38\n\nfig, ax = plt.subplots(figsize=(10, 5.5))\nax.barh(y - bar_h/2, df[\"Women\"], height=bar_h, label=\"Women\", color=\"#4C78A8\")\nax.barh(y + bar_h/2, df[\"Men\"], height=bar_h, label=\"Men\", color=\"#F58518\")\n\nax.set_yticks(y)\nax.set_yticklabels(df[\"Education\"])\nax.set_xlabel(\"Median earnings (USD)\")\nax.set_title(\"Median Earnings by Education Level (Women vs Men)\")\nax.legend(frameon=False)\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib function `ax.barh()` to render data. It plots two sets of horizontal bars (Men and Women) for each category on the Y-axis using an offset, which corresponds to the 'Grouped bar chart' definition."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Ensure expected columns exist\nrequired_cols = {\"Education\", \"Women\", \"Men\"}\nif not required_cols.issubset(df.columns):\n    raise ValueError(f\"CSV must contain columns {required_cols}, but got {set(df.columns)}\")\n\n# Plot: grouped horizontal bar chart\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\ny = range(len(df))\nbar_h = 0.4\n\nax.barh([i - bar_h/2 for i in y], df[\"Women\"], height=bar_h, label=\"Women\", color=\"#4C78A8\")\nax.barh([i + bar_h/2 for i in y], df[\"Men\"], height=bar_h, label=\"Men\", color=\"#F58518\")\n\nax.set_yticks(list(y))\nax.set_yticklabels(df[\"Education\"])\nax.invert_yaxis()  # top-to-bottom progression as listed in the file\nax.set_xlabel(\"Count\")\nax.set_title(\"US Census: Educational Attainment by Gender\")\nax.legend(frameon=False)\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() method to render the data directly. It creates a horizontal layout (barh) with two separate bars per category (Women and Men) shifted by a vertical offset, which classifies it as a Grouped bar chart."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Plot: grouped bar chart for Women vs Men by Education level\nfig, ax = plt.subplots(figsize=(11, 5.5))\n\nx = range(len(df))\nbar_width = 0.42\n\nax.bar([i - bar_width / 2 for i in x], df[\"Women\"], width=bar_width, label=\"Women\")\nax.bar([i + bar_width / 2 for i in x], df[\"Men\"], width=bar_width, label=\"Men\")\n\nax.set_title(\"U.S. Census: Income by Education Level (Women vs Men)\")\nax.set_xlabel(\"Education\")\nax.set_ylabel(\"Income\")\nax.set_xticks(list(x))\nax.set_xticklabels(df[\"Education\"], rotation=25, ha=\"right\")\nax.legend()\n\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the Matplotlib axes method ax.bar() to render vertical bars. It manually calculates offsets to group 'Women' and 'Men' bars side-by-side for each education level, making it a Grouped column chart."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Gráfico: comparación de ingresos por nivel educativo (Mujeres vs Hombres)\nplt.figure(figsize=(11, 5))\nx = range(len(df))\n\nplt.plot(x, df[\"Women\"], marker=\"o\", linewidth=2, label=\"Women\")\nplt.plot(x, df[\"Men\"], marker=\"o\", linewidth=2, label=\"Men\")\n\nplt.xticks(x, df[\"Education\"], rotation=35, ha=\"right\")\nplt.ylabel(\"Income\")\nplt.title(\"Income by Education Level (Women vs Men)\")\nplt.grid(True, axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered directly using matplotlib's 'plt.plot()' function. Based on the taxonomy, it is classified as a Line chart as it visualizes quantitative values across categorical variables (Education) using lines and markers."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Prepare\neducation = df[\"Education\"].tolist()\nwomen = df[\"Women\"].to_numpy()\nmen = df[\"Men\"].to_numpy()\n\nx = np.arange(len(education))\nwidth = 0.42\n\n# Plot\nplt.figure(figsize=(12, 6))\nplt.bar(x - width/2, women, width=width, label=\"Women\", color=\"#4C78A8\")\nplt.bar(x + width/2, men, width=width, label=\"Men\", color=\"#F58518\")\n\nplt.title(\"Median Earnings by Education Level (Women vs Men)\")\nplt.ylabel(\"Median earnings (USD)\")\nplt.xticks(x, education, rotation=25, ha=\"right\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.legend(frameon=False)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization uses plt.bar() directly to render data. The implementation includes manual x-axis offsets to place vertical bars for 'Women' and 'Men' side-by-side for each education level, which fits the definition of a Grouped column chart.", "is_correct": true}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Basic ordering as provided (top-to-bottom in CSV)\ndf[\"Education\"] = pd.Categorical(df[\"Education\"], categories=df[\"Education\"].tolist(), ordered=True)\ndf = df.sort_values(\"Education\")\n\n# Plot: horizontal grouped bars\nfig, ax = plt.subplots(figsize=(10, 5.5))\ny = range(len(df))\n\nbar_h = 0.38\nax.barh([i - bar_h/2 for i in y], df[\"Women\"], height=bar_h, label=\"Women\", color=\"#4C78A8\")\nax.barh([i + bar_h/2 for i in y], df[\"Men\"], height=bar_h, label=\"Men\", color=\"#F58518\")\n\n# Formatting\nax.set_yticks(list(y))\nax.set_yticklabels(df[\"Education\"])\nax.invert_yaxis()  # show lowest education at top, matching CSV order\nax.set_xlabel(\"Count\")\nax.set_title(\"Educational Attainment by Gender (US Census)\")\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.legend(frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped bar chart", "color_palette": null, "reasoning": "The code uses Matplotlib's ax.barh() function twice with manual Y-axis offsets to render horizontal bars representing two different categories (Men and Women) side-by-side for each education level."}}
{"input_csv_file": "16us_census_edu.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"16us_census_edu.csv\")\n\n# Ensure ordering as in file\ndf[\"Education\"] = pd.Categorical(df[\"Education\"], categories=df[\"Education\"].tolist(), ordered=True)\ndf = df.sort_values(\"Education\")\n\n# Plot: grouped horizontal bars\nfig, ax = plt.subplots(figsize=(10, 5.5))\ny = np.arange(len(df))\nbar_h = 0.38\n\nax.barh(y - bar_h / 2, df[\"Women\"], height=bar_h, label=\"Women\", color=\"#4C78A8\")\nax.barh(y + bar_h / 2, df[\"Men\"], height=bar_h, label=\"Men\", color=\"#F58518\")\n\nax.set_yticks(y)\nax.set_yticklabels(df[\"Education\"])\nax.invert_yaxis()  # Top = lowest education\nax.set_xlabel(\"Median annual earnings (USD)\")\nax.set_title(\"Median Annual Earnings by Education Level (2016 US Census)\")\nax.legend(frameon=False, loc=\"lower right\")\n\n# Formatting\nax.xaxis.set_major_formatter(lambda x, pos: f\"${x:,.0f}\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped bar chart", "color_palette": null, "reasoning": "Used standard matplotlib axes functions (ax.barh) to draw horizontal bars. Since multiple categories (Men and Women) are plotted side-by-side for each education level using coordinate offsets, it is classified as a grouped bar chart."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Create a single chart: student count by major (sorted by major code)\ncounts = df[\"major\"].value_counts().sort_index()\n\nplt.figure(figsize=(8, 4.8))\nplt.bar(counts.index.astype(str), counts.values, color=\"#4C72B0\")\nplt.title(\"Student Count by Major\")\nplt.xlabel(\"Major Code\")\nplt.ylabel(\"Number of Students\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C72B0", "reasoning": "The visualization uses the matplotlib.pyplot function plt.bar() directly to render data as vertical bars, which maps to the 'Column chart' category in the taxonomy. Even though pandas is used for data processing, the rendering is not done through a pandas plotting wrapper."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Count students by sex\nsex_counts = (\n    df[\"sex\"]\n    .astype(str)\n    .str.strip()\n    .replace({\"\": \"Unknown\", \"nan\": \"Unknown\", \"None\": \"Unknown\"})\n    .value_counts()\n    .sort_index()\n)\n\n# Plot: simple bar chart (accessible for early data literacy levels)\nplt.figure(figsize=(6, 4))\nsex_counts.plot(kind=\"bar\", color=[\"#4C78A8\", \"#F58518\", \"#54A24B\"])\n\nplt.title(\"Number of Students by Sex\")\nplt.xlabel(\"Sex\")\nplt.ylabel(\"Number of students\")\nplt.xticks(rotation=0)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the .plot(kind='bar') method on a pandas Series, which makes the library 'pandas' according to the hierarchy rules. In pandas, kind='bar' defaults to vertical bars, which the taxonomy classifies as a Column chart."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Count students by sex\ncounts = df[\"sex\"].value_counts().reindex([\"F\", \"M\"]).fillna(0).astype(int)\n\n# Plot: simple bar chart\nplt.figure(figsize=(6, 4))\nplt.bar(counts.index, counts.values, color=[\"#4C78A8\", \"#F58518\"])\nplt.title(\"Number of Students by Sex\")\nplt.xlabel(\"Sex\")\nplt.ylabel(\"Count\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the plt.bar() function from matplotlib to render the data directly. Since plt.bar() creates vertical bars by default and maps a categorical variable (sex) to a quantitative count, it is classified as a Column chart."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load the CSV\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Count students by city_code\ncity_counts = df[\"city_code\"].value_counts().sort_values(ascending=False)\n\n# Plot: number of students per city\nplt.figure(figsize=(10, 5))\ncity_counts.plot(kind=\"bar\", color=\"steelblue\")\nplt.title(\"Number of Students by City Code\")\nplt.xlabel(\"City Code\")\nplt.ylabel(\"Number of Students\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": "steelblue", "reasoning": "The data is rendered using the pandas Series.plot(kind='bar') wrapper. According to the taxonomy, vertical bars are classified as a 'Column chart' and the priority rules state that even if matplotlib is used for styling, using the .plot() method classifies the library as 'pandas'."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Single chart: Student count by major\ncounts = df[\"major\"].value_counts().sort_index()\n\nplt.figure(figsize=(8, 4.5))\nplt.bar(counts.index.astype(str), counts.values, color=\"#4C78A8\")\nplt.title(\"Number of Students by Major\")\nplt.xlabel(\"Major\")\nplt.ylabel(\"Student Count\")\nplt.grid(axis=\"y\", alpha=0.25)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() to render the data directly, which according to the hierarchy rules classifies the library as matplotlib. Since plt.bar() creates vertical bars, it is classified as a Column chart."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Single chart: count of students by city_code (sorted descending)\ncity_counts = df[\"city_code\"].value_counts().sort_values(ascending=False)\n\nplt.figure(figsize=(10, 5))\ncity_counts.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Number of Students by City Code\")\nplt.xlabel(\"City Code\")\nplt.ylabel(\"Student Count\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is generated using the pandas Series method `.plot(kind='bar')`. According to the hierarchy rules, even if matplotlib is used for styling, using the `.plot()` wrapper identifies the library as 'pandas'. In pandas, `kind='bar'` produces vertical bars, which corresponds to 'Column chart' in the provided taxonomy."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"17club_1Student.csv\")\n\n    # Single chart: count of students by major\n    major_counts = df[\"major\"].value_counts().sort_index()\n\n    plt.figure(figsize=(8, 4.5))\n    plt.bar(major_counts.index.astype(str), major_counts.values, color=\"#4C78A8\")\n    plt.title(\"Students by Major (Count)\")\n    plt.xlabel(\"Major\")\n    plt.ylabel(\"Number of Students\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function `plt.bar()` to render data, which draws vertical bars. According to the taxonomy, vertical bars are classified as a 'Column chart'. Since the data is not rendered through pandas `.plot()` or seaborn methods, the library is 'matplotlib'."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Single chart: count of students by city_code\ncounts = df[\"city_code\"].value_counts().sort_values(ascending=True)\n\nplt.figure(figsize=(10, 6))\nplt.barh(counts.index, counts.values, color=\"#4C78A8\")\nplt.title(\"Student Count by City Code\")\nplt.xlabel(\"Number of Students\")\nplt.ylabel(\"City Code\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the matplotlib function plt.barh() to render the data as horizontal bars. Based on the hierarchy rules, since the data is drawn using plt.barh() rather than a dataframe wrapper or seaborn, the library is matplotlib. Horizontal bars are classified as a Bar chart in the provided taxonomy."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Contar estudiantes por major (código de carrera)\ncounts = df[\"major\"].value_counts().sort_index()\n\n# Gráfico (un solo chart)\nplt.figure(figsize=(8, 4.5))\ncounts.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Número de estudiantes por major\")\nplt.xlabel(\"Major (código)\")\nplt.ylabel(\"Cantidad de estudiantes\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the .plot(kind='bar') method on a pandas Series. According to the hierarchy rules, this classifies the library as 'pandas'. Since pandas' kind='bar' produces vertical bars by default, it is classified as a 'Column chart' per the taxonomy."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MaxNLocator\n\n# Load data\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Age distribution by sex (single chart): stacked histogram\nbins = list(range(df[\"age\"].min(), df[\"age\"].max() + 2))  # 1-year bins\n\nfemale_ages = df.loc[df[\"sex\"] == \"F\", \"age\"].to_numpy()\nmale_ages = df.loc[df[\"sex\"] == \"M\", \"age\"].to_numpy()\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\nax.hist(\n    [female_ages, male_ages],\n    bins=bins,\n    stacked=True,\n    color=[\"#4C78A8\", \"#F58518\"],\n    edgecolor=\"white\",\n    linewidth=0.8,\n    label=[\"Female\", \"Male\"],\n)\n\nax.set_title(\"Student Age Distribution by Sex\", pad=10)\nax.set_xlabel(\"Age\")\nax.set_ylabel(\"Number of Students\")\nax.xaxis.set_major_locator(MaxNLocator(integer=True))\nax.legend(frameon=True, title=\"Sex\")\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The plot is created using the matplotlib Axes method `ax.hist()` with the `stacked=True` parameter. Because the bars are oriented vertically and represent categories (age bins and sex) stacked upon each other, it is classified as a Stacked column chart."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Aggregate: student count by city_code\ncity_counts = (\n    df[\"city_code\"]\n    .value_counts()\n    .sort_values(ascending=True)\n)\n\n# Plot: single chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nax.barh(city_counts.index, city_counts.values, color=\"#4C78A8\")\nax.set_title(\"Student Count by City Code\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Number of Students\")\nax.set_ylabel(\"City Code\")\n\n# Value labels\nfor y, v in enumerate(city_counts.values):\n    ax.text(v + 0.05, y, str(v), va=\"center\", ha=\"left\", fontsize=10)\n\nax.set_xlim(0, city_counts.values.max() + 1.5)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The data is rendered using the ax.barh() method, which is a standard matplotlib function for drawing horizontal bars. According to the taxonomy, horizontal bars with categorical and quantitative variables are classified as a Bar chart."}}
{"input_csv_file": "17club_1Student.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MaxNLocator\n\n# Load data\ndf = pd.read_csv(\"17club_1Student.csv\")\n\n# Prepare data: age distribution by sex (counts)\nage_sex_counts = (\n    df.groupby([\"age\", \"sex\"])\n      .size()\n      .unstack(fill_value=0)\n      .sort_index()\n)\n\n# Ensure consistent column order if present\nfor col in [\"F\", \"M\"]:\n    if col not in age_sex_counts.columns:\n        age_sex_counts[col] = 0\nage_sex_counts = age_sex_counts[[\"F\", \"M\"]]\n\n# Plot: single chart (stacked bars)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\ncolors = {\"F\": \"#4C78A8\", \"M\": \"#F58518\"}\nage_sex_counts.plot(\n    kind=\"bar\",\n    stacked=True,\n    ax=ax,\n    color=[colors[\"F\"], colors[\"M\"]],\n    width=0.85,\n    edgecolor=\"white\",\n    linewidth=0.6\n)\n\nax.set_title(\"Student Count by Age (Stacked by Sex)\", pad=10, weight=\"bold\")\nax.set_xlabel(\"Age\")\nax.set_ylabel(\"Number of Students\")\nax.yaxis.set_major_locator(MaxNLocator(integer=True))\nax.legend(title=\"Sex\", frameon=True, loc=\"upper left\", bbox_to_anchor=(1.02, 1.0))\n\n# Annotate totals on top of each bar\ntotals = age_sex_counts.sum(axis=1)\nfor i, total in enumerate(totals.values):\n    ax.text(i, total + 0.05, str(int(total)), ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas DataFrame plotting method `age_sex_counts.plot(kind='bar', stacked=True)`. Since the bars are vertical and the segments within each bar represent categories (Sex), it is classified as a Stacked column chart."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"17flight_1flight.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate: average price by route (origin -> destination)\nroute_stats = (\n    df.assign(route=df[\"origin\"] + \" → \" + df[\"destination\"])\n      .groupby(\"route\", as_index=False)[\"price\"]\n      .mean()\n      .sort_values(\"price\", ascending=False)\n)\n\n# Plot: horizontal bar chart\nplt.figure(figsize=(10, 5))\nplt.barh(route_stats[\"route\"], route_stats[\"price\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()\nplt.title(\"Average Flight Price by Route\")\nplt.xlabel(\"Average Price (USD)\")\nplt.ylabel(\"Route\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization is created using the matplotlib library via plt.barh(), which generates horizontal bars. This matches the 'Bar chart' definition in the taxonomy for horizontal layouts with categorical and quantitative data."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17flight_1flight.csv\")\n\n# Aggregate: average price by destination (simple, direct comparison)\ndest_avg = (\n    df.groupby(\"destination\", as_index=False)[\"price\"]\n    .mean()\n    .sort_values(\"price\", ascending=False)\n)\n\n# Plot: one chart\nplt.figure(figsize=(10, 5))\nplt.bar(dest_avg[\"destination\"], dest_avg[\"price\"], color=\"#4C78A8\")\nplt.title(\"Average Flight Price by Destination\")\nplt.xlabel(\"Destination\")\nplt.ylabel(\"Average Price (USD)\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.bar() to render the data, which creates vertical bars classified as a Column chart in the provided taxonomy. Although a specific hex color (#4C78A8) is provided, no named library palette (e.g., 'viridis') is invoked."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17flight_1flight.csv\")\n\n# Chart: Price by destination (average, in case of duplicates)\navg_price_by_dest = (\n    df.groupby(\"destination\", as_index=False)[\"price\"]\n      .mean()\n      .sort_values(\"price\", ascending=False)\n)\n\nplt.figure(figsize=(10, 5))\nplt.bar(avg_price_by_dest[\"destination\"], avg_price_by_dest[\"price\"], color=\"#4C78A8\")\nplt.title(\"Average Flight Price by Destination\")\nplt.xlabel(\"Destination\")\nplt.ylabel(\"Average Price (USD)\")\nplt.xticks(rotation=35, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib function 'plt.bar()' to render vertical bars, classifying it as a 'Column chart' according to the taxonomy. Since it calls the drawing function from matplotlib directly rather than through pandas wrapper or seaborn, the library is 'matplotlib'."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17flight_1flight.csv\")\n\n# Create a simple summary: average price by destination\navg_price_by_dest = (\n    df.groupby(\"destination\", as_index=False)[\"price\"]\n      .mean()\n      .sort_values(\"price\", ascending=False)\n)\n\n# Plot: one chart\nplt.figure(figsize=(10, 5))\nplt.bar(avg_price_by_dest[\"destination\"], avg_price_by_dest[\"price\"], color=\"#4C78A8\")\nplt.title(\"Average Flight Price by Destination\")\nplt.xlabel(\"Destination\")\nplt.ylabel(\"Average Price (USD)\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using plt.bar() directly from the matplotlib library, which generates vertical bars. According to the taxonomy, vertical bars are classified as a Column chart."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"17flight_1flight.csv\")\n\n# Basic cleanup\ndf[\"departure_date\"] = pd.to_datetime(df[\"departure_date\"], errors=\"coerce\")\ndf[\"arrival_date\"] = pd.to_datetime(df[\"arrival_date\"], errors=\"coerce\")\n\n# Aggregate: average price by destination (single chart)\navg_price_by_dest = (\n    df.groupby(\"destination\", as_index=False)[\"price\"]\n      .mean()\n      .sort_values(\"price\", ascending=False)\n)\n\n# Plot\nplt.figure(figsize=(10, 5))\nplt.bar(avg_price_by_dest[\"destination\"], avg_price_by_dest[\"price\"], color=\"#4C78A8\")\nplt.title(\"Average Flight Price by Destination\")\nplt.xlabel(\"Destination\")\nplt.ylabel(\"Average Price (USD)\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C78A8", "reasoning": "The code uses matplotlib's plt.bar() function directly to render data. Since plt.bar() creates vertical bars by default, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17flight_1flight.csv\")\n\n# Ensure numeric types (in case CSV parsing differs)\ndf[\"distance\"] = pd.to_numeric(df[\"distance\"], errors=\"coerce\")\ndf[\"price\"] = pd.to_numeric(df[\"price\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"distance\", \"price\", \"destination\"])\n\n# Aggregate: average price by destination\navg_price_by_dest = (\n    df.groupby(\"destination\", as_index=True)[\"price\"]\n      .mean()\n      .sort_values(ascending=False)\n)\n\n# Single chart: bar plot of average price per destination\nplt.figure(figsize=(10, 5))\navg_price_by_dest.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Average Flight Price by Destination\")\nplt.xlabel(\"Destination\")\nplt.ylabel(\"Average Price\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the .plot(kind='bar') method on a pandas Series to render the visualization. According to the taxonomy rules, pandas DataFrame/Series plotting methods classify the library as 'pandas'. Since the bars are vertical (the default for kind='bar'), it is classified as a Column chart."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    csv_path = \"17flight_1flight.csv\"\n    df = pd.read_csv(csv_path)\n\n    # 価格 vs 距離 の散布図（目的地で色分け）\n    plt.figure(figsize=(9, 5))\n    for dest, g in df.groupby(\"destination\"):\n        plt.scatter(g[\"distance\"], g[\"price\"], s=70, alpha=0.85, label=dest)\n\n    plt.title(\"Flight Price vs Distance (grouped by Destination)\")\n    plt.xlabel(\"Distance (miles)\")\n    plt.ylabel(\"Price\")\n    plt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\n    plt.legend(title=\"Destination\", fontsize=8, title_fontsize=9, loc=\"best\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The plot is created using the standard plt.scatter() function from matplotlib. Since it maps two quantitative variables (distance and price) and the marker size is constant (s=70), it is classified as a Scatterplot."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    csv_path = \"17flight_1flight.csv\"\n    df = pd.read_csv(csv_path)\n\n    # Average price by route (origin -> destination)\n    df[\"route\"] = df[\"origin\"].astype(str) + \" → \" + df[\"destination\"].astype(str)\n    route_avg = (\n        df.groupby(\"route\", as_index=False)[\"price\"]\n          .mean()\n          .sort_values(\"price\", ascending=False)\n    )\n\n    plt.figure(figsize=(10, 5))\n    plt.bar(route_avg[\"route\"], route_avg[\"price\"], color=\"#4C78A8\")\n    plt.title(\"Average Flight Price by Route\")\n    plt.xlabel(\"Route\")\n    plt.ylabel(\"Average Price\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the plt.bar() function from matplotlib to render vertical bars, which corresponds to the 'Column chart' category in the taxonomy. Even though pandas is used for data manipulation, the drawing function belongs to the matplotlib library."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"17flight_1flight.csv\")\n\n# Asegurar tipos de datos\ndf[\"distance\"] = pd.to_numeric(df[\"distance\"], errors=\"coerce\")\ndf[\"price\"] = pd.to_numeric(df[\"price\"], errors=\"coerce\")\n\n# Gráfico: Precio vs Distancia (dispersión)\nplt.figure(figsize=(9, 5.5))\nplt.scatter(df[\"distance\"], df[\"price\"], alpha=0.85)\n\nplt.title(\"Precio vs Distancia de vuelos (17flight_1flight.csv)\")\nplt.xlabel(\"Distancia (millas)\")\nplt.ylabel(\"Precio (USD)\")\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot (plt.scatter) to render data directly from two quantitative columns ('distance' and 'price')."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"17flight_1flight.csv\")\n\n# Clean/parse\ndf[\"departure_date\"] = pd.to_datetime(df[\"departure_date\"], errors=\"coerce\")\ndf[\"arrival_date\"] = pd.to_datetime(df[\"arrival_date\"], errors=\"coerce\")\n\n# Plot: Price vs Distance, colored by route (origin -> destination)\ndf[\"route\"] = df[\"origin\"].astype(str) + \" → \" + df[\"destination\"].astype(str)\n\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(9.5, 5.8), dpi=140)\n\nsns.scatterplot(\n    data=df,\n    x=\"distance\",\n    y=\"price\",\n    hue=\"route\",\n    s=90,\n    ax=ax\n)\n\n# Label points with flight number\nfor _, r in df.iterrows():\n    if pd.notna(r[\"distance\"]) and pd.notna(r[\"price\"]):\n        ax.annotate(\n            str(int(r[\"flno\"])),\n            (r[\"distance\"], r[\"price\"]),\n            textcoords=\"offset points\",\n            xytext=(6, 5),\n            fontsize=8,\n            alpha=0.9\n        )\n\nax.set_title(\"Flight Price vs Distance (labeled by flight number)\")\nax.set_xlabel(\"Distance (miles)\")\nax.set_ylabel(\"Price (USD)\")\n\n# Improve legend placement\nax.legend(title=\"Route\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", borderaxespad=0)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using sns.scatterplot() which maps two quantitative variables (distance and price) to the X and Y axes."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"17flight_1flight.csv\")\n\n# Parse datetimes\ndf[\"departure_date\"] = pd.to_datetime(df[\"departure_date\"])\ndf[\"arrival_date\"] = pd.to_datetime(df[\"arrival_date\"])\n\n# Compute flight duration in hours (handles same-day clock issues by allowing +1 day if negative)\ndur = (df[\"arrival_date\"] - df[\"departure_date\"]).dt.total_seconds() / 3600.0\ndur = dur.where(dur >= 0, dur + 24)\ndf[\"duration_hours\"] = dur\n\n# Scatter: Distance vs Price, colored by duration\ndf = df.sort_values(\"duration_hours\")\nfig, ax = plt.subplots(figsize=(9.5, 5.8))\n\nsc = ax.scatter(\n    df[\"distance\"],\n    df[\"price\"],\n    c=df[\"duration_hours\"],\n    cmap=\"viridis\",\n    s=120,\n    edgecolor=\"white\",\n    linewidth=0.9,\n    alpha=0.95,\n)\n\n# Annotate points with route labels\nfor _, r in df.iterrows():\n    label = f\"{r['origin']}→{r['destination']}\"\n    ax.annotate(\n        label,\n        (r[\"distance\"], r[\"price\"]),\n        xytext=(6, 6),\n        textcoords=\"offset points\",\n        fontsize=9,\n        color=\"#222222\",\n    )\n\nax.set_title(\"Flight Prices vs Distance (Color = Duration in Hours)\", pad=12)\nax.set_xlabel(\"Distance (miles)\")\nax.set_ylabel(\"Price (USD)\")\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x:,.0f}\"))\n\nax.grid(True, which=\"major\", linestyle=\"--\", linewidth=0.6, alpha=0.35)\nax.set_axisbelow(True)\n\ncbar = plt.colorbar(sc, ax=ax, pad=0.02)\ncbar.set_label(\"Duration (hours)\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "viridis", "reasoning": "The code uses the standard matplotlib axes function ax.scatter() to draw the data points, which prioritizes matplotlib over pandas/seaborn in the library hierarchy. The plot maps two quantitative variables (distance and price) to the x and y axes, which fits the definition of a Scatterplot. Although a third variable (duration) is encoded via color, the point size remains constant (s=120), so it is not classified as a Bubble chart."}}
{"input_csv_file": "17flight_1flight.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"17flight_1flight.csv\")\n\n# Ensure proper types\ndf[\"departure_date\"] = pd.to_datetime(df[\"departure_date\"], errors=\"coerce\")\ndf[\"arrival_date\"] = pd.to_datetime(df[\"arrival_date\"], errors=\"coerce\")\n\n# Build an easy-to-read route label\ndf[\"route\"] = df[\"origin\"].astype(str) + \" → \" + df[\"destination\"].astype(str)\n\n# Aggregate to one value per route (mean price) and keep count for context\nroute_stats = (\n    df.groupby(\"route\", as_index=False)\n      .agg(mean_price=(\"price\", \"mean\"), flights=(\"flno\", \"count\"))\n      .sort_values(\"mean_price\", ascending=False)\n)\n\n# Plot: Average price by route\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\nsns.barplot(\n    data=route_stats,\n    y=\"route\",\n    x=\"mean_price\",\n    color=\"#4C78A8\",\n    ax=ax\n)\n\n# Annotate bars with mean price and flight count\nfor i, row in route_stats.reset_index(drop=True).iterrows():\n    ax.text(\n        row[\"mean_price\"] + (route_stats[\"mean_price\"].max() * 0.01),\n        i,\n        f'${row[\"mean_price\"]:.2f}  (n={int(row[\"flights\"])})',\n        va=\"center\",\n        ha=\"left\",\n        fontsize=9\n    )\n\nax.set_title(\"Average Ticket Price by Route\")\nax.set_xlabel(\"Average Price (USD)\")\nax.set_ylabel(\"Route\")\n\n# Add some right padding for annotations\nax.set_xlim(0, route_stats[\"mean_price\"].max() * 1.25)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization uses sns.barplot with the 'y' parameter assigned to a categorical variable ('route') and the 'x' parameter to a quantitative variable ('mean_price'), resulting in a horizontal layout. According to the taxonomy, horizontal layouts are classified as 'Bar chart'. Seaborn is identified as the library because sns.barplot is used to render the data."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"17voter_2Voting_record.csv\")\n\n# Candidate columns (votes are stored as candidate IDs)\nvote_cols = [\n    \"president_vote\",\n    \"vice_president_vote\",\n    \"secretary_vote\",\n    \"treasurer_vote\",\n    \"class_president_vote\",\n    \"class_senator_vote\",\n]\n\n# Count total selections per candidate across all positions and election cycles\ncounts = (\n    df[vote_cols]\n    .melt(var_name=\"position\", value_name=\"candidate_id\")\n    .dropna()\n    .groupby(\"candidate_id\")\n    .size()\n    .sort_values(ascending=False)\n)\n\n# Plot: bar chart of candidate popularity (total votes across all offices)\nplt.figure(figsize=(10, 5))\nplt.bar(counts.index.astype(str), counts.values, color=\"#4C78A8\")\nplt.title(\"Total Selections per Candidate (All Offices & Cycles)\")\nplt.xlabel(\"Candidate ID\")\nplt.ylabel(\"Number of Selections\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.bar() to render the data. Following the taxonomy, plt.bar() creates vertical bars, which classifies it as a Column chart. Although a hex color '#4C78A8' is used, no named color palette was specified."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17voter_2Voting_record.csv\")\n\n# Count votes for president by election cycle\nvote_counts = (\n    df.groupby([\"election_cycle\", \"president_vote\"])\n      .size()\n      .reset_index(name=\"votes\")\n)\n\n# Create a pivot table for plotting (rows = candidate IDs, columns = cycles)\npivot = vote_counts.pivot(index=\"president_vote\", columns=\"election_cycle\", values=\"votes\").fillna(0)\n\n# Ensure consistent column order if present\ncols = [c for c in [\"Spring\", \"Fall\"] if c in pivot.columns]\npivot = pivot[cols]\n\n# Plot: grouped bar chart\nax = pivot.plot(kind=\"bar\", figsize=(9, 5), width=0.85)\n\nax.set_title(\"Number of Votes per President Candidate (by Election Cycle)\")\nax.set_xlabel(\"President Candidate ID\")\nax.set_ylabel(\"Number of Votes\")\nax.legend(title=\"Election Cycle\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas DataFrame plotting method `pivot.plot(kind='bar')`. Because the pivot table contains two columns ('Spring' and 'Fall') representing different election cycles for each candidate, pandas automatically renders a grouped vertical bar layout, which is classified as a Grouped column chart."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17voter_2Voting_record.csv\")\n\n# Count how many votes each president candidate received (simple, \"read the data\" level)\npres_counts = (\n    df[\"president_vote\"]\n    .value_counts()\n    .sort_index()\n)\n\n# Plot: bar chart of president vote counts\nplt.figure(figsize=(8, 4.5))\nplt.bar(pres_counts.index.astype(str), pres_counts.values, color=\"#4C78A8\")\nplt.title(\"Number of Votes per President Candidate\")\nplt.xlabel(\"President Candidate ID\")\nplt.ylabel(\"Number of Votes\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, which produces vertical bars. According to the hierarchy rules, since matplotlib's native functions are used instead of pandas or seaborn wrappers, the library is 'matplotlib' and the vertical orientation makes it a 'Column chart'."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"17voter_2Voting_record.csv\")\n\n# Count how many votes each candidate received for president, split by election cycle\npres_counts = (\n    df.groupby([\"election_cycle\", \"president_vote\"])\n      .size()\n      .unstack(fill_value=0)\n)\n\n# Make a single chart (grouped bar chart)\nax = pres_counts.plot(kind=\"bar\", figsize=(10, 5), width=0.85)\n\nax.set_title(\"President Vote Counts by Election Cycle\")\nax.set_xlabel(\"Election Cycle\")\nax.set_ylabel(\"Number of Votes\")\nax.legend(title=\"Candidate ID\", bbox_to_anchor=(1.02, 1), loc=\"upper left\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the `df.plot(kind='bar')` method, which identifies the library as pandas. Since the bars are vertical and the DataFrame was unstacked to create groups for each election cycle, it is classified as a Grouped column chart."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ncsv_path = \"17voter_2Voting_record.csv\"\ndf = pd.read_csv(csv_path)\n\n# Columns representing votes for each position\nvote_cols = [\n    \"president_vote\",\n    \"vice_president_vote\",\n    \"secretary_vote\",\n    \"treasurer_vote\",\n    \"class_president_vote\",\n    \"class_senator_vote\",\n]\n\n# Reshape and count votes per candidate per position\nlong = df.melt(id_vars=[\"election_cycle\"], value_vars=vote_cols, var_name=\"position\", value_name=\"candidate_id\")\ncounts = (\n    long.groupby([\"position\", \"candidate_id\"])\n        .size()\n        .reset_index(name=\"votes\")\n)\n\n# For readability: show top N candidates per position\ntop_n = 5\ncounts[\"rank_within_position\"] = counts.groupby(\"position\")[\"votes\"].rank(method=\"first\", ascending=False)\ntop = counts[counts[\"rank_within_position\"] <= top_n].copy()\n\n# Create labels and plot a single chart (horizontal bar chart)\ntop[\"label\"] = top[\"position\"].str.replace(\"_vote\", \"\", regex=False).str.replace(\"_\", \" \", regex=False).str.title() \\\n               + \" — \" + top[\"candidate_id\"].astype(str)\n\ntop = top.sort_values([\"position\", \"votes\", \"candidate_id\"], ascending=[True, False, True])\n\nplt.figure(figsize=(11, 6))\nplt.barh(top[\"label\"], top[\"votes\"], color=\"#4C78A8\")\nplt.xlabel(\"Number of Votes\")\nplt.ylabel(\"Position — Candidate ID\")\nplt.title(f\"Top {top_n} Vote-Getters per Position (All Records)\")\nplt.gca().invert_yaxis()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the 'plt.barh()' function from matplotlib to render horizontal bars, which classifies it as a 'Bar chart' according to the taxonomy. Although pandas is used for data manipulation, the rendering is performed directly by pyplot functions rather than DataFrame plotting methods, so the library is classified as 'matplotlib'."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"17voter_2Voting_record.csv\"\ndf = pd.read_csv(csv_path)\n\n# Count votes per position and election cycle (one chart with grouped bars)\npositions = [\n    \"president_vote\",\n    \"vice_president_vote\",\n    \"secretary_vote\",\n    \"treasurer_vote\",\n    \"class_president_vote\",\n    \"class_senator_vote\",\n]\n\n# Unique candidate counts per position within each election cycle\ncounts = (\n    df.groupby(\"election_cycle\")[positions]\n      .nunique()\n      .reindex([\"Spring\", \"Fall\"])  # consistent order (if present)\n)\n\n# Plot: grouped bar chart\nfig, ax = plt.subplots(figsize=(11, 5.5))\ncounts.plot(kind=\"bar\", ax=ax)\n\nax.set_title(\"Unique Candidate IDs Voted For by Position and Election Cycle\")\nax.set_xlabel(\"Election Cycle\")\nax.set_ylabel(\"Number of Unique Candidate IDs\")\nax.legend(title=\"Position\", bbox_to_anchor=(1.02, 1), loc=\"upper left\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas DataFrame plotting method `counts.plot(kind='bar')`. Because it renders vertical bars with multiple columns grouped by a categorical index ('election_cycle'), it is classified as a Grouped column chart."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    path = \"17voter_2Voting_record.csv\"\n    df = pd.read_csv(path)\n\n    vote_cols = [\n        \"president_vote\",\n        \"vice_president_vote\",\n        \"secretary_vote\",\n        \"treasurer_vote\",\n        \"class_president_vote\",\n        \"class_senator_vote\",\n    ]\n\n    # Count how many votes each candidate ID received per position\n    counts = {}\n    for col in vote_cols:\n        counts[col] = df[col].value_counts().sort_index()\n\n    counts_df = pd.DataFrame(counts).fillna(0).astype(int)\n\n    # Single chart: stacked bar chart of votes received by candidate (across positions)\n    ax = counts_df.plot(kind=\"bar\", stacked=True, figsize=(10, 5), width=0.85)\n\n    ax.set_title(\"Votes Received by Candidate ID (Stacked by Position)\")\n    ax.set_xlabel(\"Candidate ID\")\n    ax.set_ylabel(\"Number of Votes\")\n    ax.legend(title=\"Position\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", borderaxespad=0)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The plot is generated using the pandas DataFrame method `counts_df.plot(kind='bar', stacked=True)`. Following the taxonomy and priority rules, pandas is the library. Because the bars are vertical (default 'bar' in pandas/matplotlib) and stacked, it is classified as a Stacked column chart."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    csv_path = \"17voter_2Voting_record.csv\"\n    df = pd.read_csv(csv_path)\n\n    vote_cols = [\n        \"president_vote\",\n        \"vice_president_vote\",\n        \"secretary_vote\",\n        \"treasurer_vote\",\n        \"class_president_vote\",\n        \"class_senator_vote\",\n    ]\n\n    # Count votes per candidate across each position\n    counts = {col: df[col].value_counts().sort_index() for col in vote_cols}\n    counts_df = pd.DataFrame(counts).fillna(0).astype(int)\n\n    # Plot a single chart: heatmap of candidate vote counts by position\n    fig, ax = plt.subplots(figsize=(10, 5))\n    im = ax.imshow(counts_df.values, aspect=\"auto\", interpolation=\"nearest\", cmap=\"Blues\")\n\n    ax.set_title(\"Vote counts per candidate by position\")\n    ax.set_xlabel(\"Position\")\n    ax.set_ylabel(\"Candidate ID\")\n\n    ax.set_xticks(range(len(counts_df.columns)))\n    ax.set_xticklabels(counts_df.columns, rotation=30, ha=\"right\")\n    ax.set_yticks(range(len(counts_df.index)))\n    ax.set_yticklabels(counts_df.index)\n\n    cbar = fig.colorbar(im, ax=ax)\n    cbar.set_label(\"Votes\")\n\n    # Annotate cells\n    for i in range(counts_df.shape[0]):\n        for j in range(counts_df.shape[1]):\n            v = counts_df.iat[i, j]\n            if v != 0:\n                ax.text(j, i, str(v), ha=\"center\", va=\"center\", fontsize=9, color=\"black\")\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "Blues", "reasoning": "The visualization uses Matplotlib's ax.imshow() to represent two categorical dimensions (candidates and positions) against a quantitative value (vote counts) encoded by color. Since it uses an axes method directly rather than a dataframe wrapper or seaborn function, it is classified as matplotlib."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\nfile_path = \"17voter_2Voting_record.csv\"\ndf = pd.read_csv(file_path)\n\n# Contar votos por ciclo electoral (Spring/Fall) para el cargo de presidente\ncounts = (\n    df.groupby([\"election_cycle\", \"president_vote\"])\n      .size()\n      .reset_index(name=\"votes\")\n)\n\n# Pivot para graficar como barras agrupadas\npivot = counts.pivot(index=\"president_vote\", columns=\"election_cycle\", values=\"votes\").fillna(0).astype(int)\n\n# Ordenar por total de votos (opcional, mejora la legibilidad)\npivot = pivot.loc[pivot.sum(axis=1).sort_values(ascending=False).index]\n\n# Gráfico: votos para presidente por ciclo electoral\nax = pivot.plot(kind=\"bar\", figsize=(10, 5), width=0.85)\n\nax.set_title(\"Distribución de votos para Presidente por ciclo electoral\")\nax.set_xlabel(\"ID del candidato (president_vote)\")\nax.set_ylabel(\"Número de votos\")\nax.legend(title=\"Ciclo electoral\")\nplt.xticks(rotation=0)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization is generated using the pivot.plot(kind='bar') method, which identifies the library as pandas. The chart features vertical bars grouped by the 'election_cycle' variable across the 'president_vote' category, making it a grouped column chart."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\npath = \"17voter_2Voting_record.csv\"\ndf = pd.read_csv(path)\n\n# Identify vote columns\nvote_cols = [\n    \"president_vote\",\n    \"vice_president_vote\",\n    \"secretary_vote\",\n    \"treasurer_vote\",\n    \"class_president_vote\",\n    \"class_senator_vote\",\n]\n\n# Long format for counting selections\nlong_df = df.melt(\n    id_vars=[\"stuid\", \"registration_date\", \"election_cycle\"],\n    value_vars=vote_cols,\n    var_name=\"office\",\n    value_name=\"candidate_id\",\n)\n\n# Count votes per office and candidate\ncounts = (\n    long_df.groupby([\"office\", \"candidate_id\"])\n    .size()\n    .reset_index(name=\"votes\")\n    .sort_values([\"office\", \"votes\", \"candidate_id\"], ascending=[True, False, True])\n)\n\n# Plot: vote distribution across offices (candidate IDs colored)\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(12, 6))\nax = sns.barplot(\n    data=counts,\n    x=\"office\",\n    y=\"votes\",\n    hue=\"candidate_id\",\n    palette=\"tab20\",\n    edgecolor=\"white\",\n    linewidth=0.6,\n)\n\nax.set_title(\"Vote Counts by Office and Candidate (All Election Cycles Combined)\")\nax.set_xlabel(\"Office\")\nax.set_ylabel(\"Number of Votes\")\n\n# Improve readability\nax.set_xticklabels([t.get_text().replace(\"_vote\", \"\").replace(\"_\", \" \").title() for t in ax.get_xticklabels()])\nax.legend(title=\"Candidate ID\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", borderaxespad=0)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Grouped column chart", "color_palette": "tab20", "reasoning": "The code uses seaborn's sns.barplot to create vertical bars. Because it includes a 'hue' parameter (candidate_id) along with a categorical x-axis (office), it is classified as a Grouped column chart."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"17voter_2Voting_record.csv\"\ndf = pd.read_csv(csv_path)\n\n# Columns that represent votes for offices\noffice_cols = [\n    \"president_vote\",\n    \"vice_president_vote\",\n    \"secretary_vote\",\n    \"treasurer_vote\",\n    \"class_president_vote\",\n    \"class_senator_vote\",\n]\n\n# Reshape to long format and count votes per candidate per office within election cycle\nlong_df = df.melt(\n    id_vars=[\"election_cycle\"],\n    value_vars=office_cols,\n    var_name=\"office\",\n    value_name=\"candidate_id\",\n)\n\ncounts = (\n    long_df.groupby([\"election_cycle\", \"office\", \"candidate_id\"])\n    .size()\n    .reset_index(name=\"votes\")\n)\n\n# For readability, plot only top-N candidates per office per cycle\nTOP_N = 3\ncounts[\"rank\"] = counts.groupby([\"election_cycle\", \"office\"])[\"votes\"].rank(\n    method=\"first\", ascending=False\n)\nplot_df = counts[counts[\"rank\"] <= TOP_N].copy()\n\n# Create categorical label for x-axis: \"Cycle | Office | Candidate\"\nplot_df[\"label\"] = (\n    plot_df[\"election_cycle\"].astype(str)\n    + \" | \"\n    + plot_df[\"office\"].str.replace(\"_vote\", \"\", regex=False).str.replace(\"_\", \" \").str.title()\n    + \" | \"\n    + plot_df[\"candidate_id\"].astype(str)\n)\n\n# Order labels by cycle -> office -> votes desc\nplot_df = plot_df.sort_values(\n    by=[\"election_cycle\", \"office\", \"votes\", \"candidate_id\"],\n    ascending=[True, True, False, True],\n)\n\n# Plot: single chart (bar)\nplt.figure(figsize=(14, 6))\nplt.bar(plot_df[\"label\"], plot_df[\"votes\"], color=\"#2A6F97\")\nplt.title(\"Top Candidate Vote Counts by Office and Election Cycle (Top 3 per Office)\")\nplt.ylabel(\"Number of Votes\")\nplt.xlabel(\"Election Cycle | Office | Candidate ID\")\nplt.xticks(rotation=60, ha=\"right\")\nplt.ylim(0, max(1, plot_df[\"votes\"].max() + 1))\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the matplotlib.pyplot library's `plt.bar()` function to render data. According to the taxonomy, vertical bars are classified as a Column chart."}}
{"input_csv_file": "17voter_2Voting_record.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"17voter_2Voting_record.csv\"\ndf = pd.read_csv(csv_path)\n\n# Offices and corresponding vote columns\nvote_cols = [\n    (\"President\", \"president_vote\"),\n    (\"Vice President\", \"vice_president_vote\"),\n    (\"Secretary\", \"secretary_vote\"),\n    (\"Treasurer\", \"treasurer_vote\"),\n    (\"Class President\", \"class_president_vote\"),\n    (\"Class Senator\", \"class_senator_vote\"),\n]\n\n# Compute unique candidate counts by election cycle (Spring/Fall) for each office\ncounts = (\n    df.groupby(\"election_cycle\")[[c for _, c in vote_cols]]\n      .nunique()\n      .rename(columns={c: name for name, c in vote_cols})\n      .reindex([\"Spring\", \"Fall\"])\n)\n\n# Plot: grouped bar chart (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\ncounts.plot(kind=\"bar\", ax=ax, width=0.85)\n\nax.set_title(\"Unique Candidates Voted For by Office and Election Cycle\", pad=12)\nax.set_xlabel(\"Election Cycle\")\nax.set_ylabel(\"Unique candidate IDs (count)\")\nax.legend(title=\"Office\", ncols=3, frameon=True, bbox_to_anchor=(0, 1.02), loc=\"lower left\")\n\n# Value labels\nfor container in ax.containers:\n    ax.bar_label(container, padding=2, fontsize=9)\n\nax.set_ylim(0, max(1, int(counts.max().max()) + 1))\nplt.tight_layout()\nplt.show()\n```", "judgment": {"error": "JSON Parsing Failed: Expecting property name enclosed in double quotes: line 6 column 1 (char 435)", "raw_text": "{\n    \"library\": \"pandas\",\n    \"chart_type\": \"Grouped column chart\",\n    \"color_palette\": null,\n    \"reasoning\": \"The data is rendered using the `counts.plot(kind='bar')` method, which identifies the library as pandas. Because the bars are vertical (kind='bar' in pandas/matplotlib defaults to vertical) and represent multiple series (offices) grouped by the election cycle on the X-axis, it is classified as a grouped column chart.\",\n}"}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Ensure consistent semester ordering\nsemester_order = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\ndf[\"Semester\"] = pd.Categorical(df[\"Semester\"], categories=semester_order, ordered=True)\n\n# Pivot for plotting\npivot = df.pivot(index=\"Semester\", columns=\"Course\", values=\"Students\").sort_index()\n\n# Plot\nfig, ax = plt.subplots(figsize=(10, 5))\npivot.plot(kind=\"bar\", ax=ax)\n\nax.set_title(\"Course Enrollment by Semester\")\nax.set_xlabel(\"Semester\")\nax.set_ylabel(\"Number of Students\")\nax.legend(title=\"Course\", ncol=2, frameon=False)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas DataFrame plotting method `pivot.plot(kind='bar')`, which categorizes the library as 'pandas' despite the use of matplotlib for styling. Because the pivoted DataFrame has multiple columns representing the 'Course' dimension alongside the 'Semester' index, and the layout is vertical (default for 'bar'), it results in a Grouped column chart."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Pivot to get semesters on x-axis and courses as separate lines\npivot = df.pivot(index=\"Semester\", columns=\"Course\", values=\"Students\")\n\n# Keep semesters in chronological order\norder = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\npivot = pivot.reindex(order)\n\n# Plot\nplt.figure(figsize=(10, 5))\nfor course in pivot.columns:\n    plt.plot(pivot.index, pivot[course], marker=\"o\", linewidth=2, label=course)\n\nplt.title(\"Course Enrollment by Semester\")\nplt.xlabel(\"Semester\")\nplt.ylabel(\"Number of Students\")\nplt.legend(title=\"Course\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered directly using the 'plt.plot()' function from the matplotlib.pyplot library, rather than a pandas or seaborn wrapper. The visualization uses lines to connect temporal categories (Semesters) to quantitative values (Students) for different groups (Courses), matching the definition of a Line chart."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Pivot to compare courses across semesters\npivot = df.pivot(index=\"Course\", columns=\"Semester\", values=\"Students\")\n\n# Plot: grouped bar chart\nax = pivot.plot(kind=\"bar\", figsize=(10, 6))\n\nax.set_title(\"Course Enrollment by Semester\")\nax.set_xlabel(\"Course\")\nax.set_ylabel(\"Number of Students\")\nax.legend(title=\"Semester\", frameon=False)\n\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization uses the DataFrame method '.plot(kind=\"bar\")', which classifies the library as 'pandas'. Since the bars are vertical and the DataFrame is a pivot table with multiple columns (Semesters) per index entry (Course), it results in a Grouped column chart."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Pivot to compare courses across semesters\npivot = df.pivot(index=\"Semester\", columns=\"Course\", values=\"Students\")\npivot = pivot.reindex([\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"])  # keep chronological order\n\n# Plot (single chart)\nplt.figure(figsize=(10, 5))\npivot.plot(kind=\"bar\", ax=plt.gca())\n\nplt.title(\"Course Enrollment by Semester\")\nplt.xlabel(\"Semester\")\nplt.ylabel(\"Number of Students\")\nplt.legend(title=\"Course\", bbox_to_anchor=(1.02, 1), loc=\"upper left\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas plotting wrapper `pivot.plot(kind='bar')`. Since the DataFrame consists of multiple columns (Courses) for each index row (Semester), the resulting visualization is a grouped vertical bar chart. According to the taxonomy, vertical bars are classified as 'Column charts', and with two categorical dimensions, it is a 'Grouped column chart'."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Ensure semester order\nsemester_order = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\ndf[\"Semester\"] = pd.Categorical(df[\"Semester\"], categories=semester_order, ordered=True)\n\n# Pivot for plotting\npivot = df.pivot_table(index=\"Semester\", columns=\"Course\", values=\"Students\", aggfunc=\"sum\").sort_index()\n\n# Plot (single chart)\nax = pivot.plot(kind=\"bar\", figsize=(10, 5))\nax.set_title(\"Course Enrollment by Semester\")\nax.set_xlabel(\"Semester\")\nax.set_ylabel(\"Number of Students\")\nax.legend(title=\"Course\", bbox_to_anchor=(1.02, 1), loc=\"upper left\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas DataFrame wrapper 'pivot.plot(kind=\"bar\")' to render the data, which defaults to vertical bars. Since the pivot table has multiple columns (Courses) for each index entry (Semester), it creates a grouped vertical bar layout."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Pivot for plotting: rows=Semester, columns=Course, values=Students\npivot = df.pivot(index=\"Semester\", columns=\"Course\", values=\"Students\")\n\n# Keep semesters in chronological order\nsemester_order = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\npivot = pivot.reindex([s for s in semester_order if s in pivot.index])\n\n# Plot a single chart\nplt.figure(figsize=(10, 5))\nax = pivot.plot(kind=\"line\", marker=\"o\", linewidth=2)\n\nax.set_title(\"Course Enrollment Over Semesters\")\nax.set_xlabel(\"Semester\")\nax.set_ylabel(\"Number of Students\")\nax.grid(True, linestyle=\"--\", alpha=0.4)\nax.legend(title=\"Course\", frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data rendering is performed using the pandas DataFrame method `pivot.plot(kind='line')`. According to the hierarchy rules, even if matplotlib is used for styling (labels, grid, show), the use of the .plot() wrapper classifies the library as pandas. The chart maps a temporal/ordinal dimension (Semester) and categorical dimension (Course) to a quantitative one (Students) using lines."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"18course_enrollment.csv\")\n\n    # Pivot to get semesters on x-axis and courses as separate lines\n    pivot = df.pivot(index=\"Semester\", columns=\"Course\", values=\"Students\")\n\n    # Keep a sensible chronological order if present\n    semester_order = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\n    existing_order = [s for s in semester_order if s in pivot.index]\n    if existing_order:\n        pivot = pivot.reindex(existing_order)\n\n    ax = pivot.plot(kind=\"line\", marker=\"o\", linewidth=2, figsize=(10, 6))\n\n    ax.set_title(\"Course Enrollment by Semester\")\n    ax.set_xlabel(\"Semester\")\n    ax.set_ylabel(\"Number of Students\")\n    ax.grid(True, linestyle=\"--\", alpha=0.4)\n    ax.legend(title=\"Course\", bbox_to_anchor=(1.02, 1), loc=\"upper left\")\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the pandas DataFrame method pivot.plot(kind='line'), which follows the hierarchy rule for classification as 'pandas'. The chart tracks student enrollment (quantitative) across semesters (temporal/ordinal) for multiple courses, matching the definition of a Line chart."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Ensure semester order\nsemester_order = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\ndf[\"Semester\"] = pd.Categorical(df[\"Semester\"], categories=semester_order, ordered=True)\n\n# Pivot for plotting\npivot = df.pivot(index=\"Semester\", columns=\"Course\", values=\"Students\").sort_index()\n\n# Single chart: grouped bar chart\nax = pivot.plot(kind=\"bar\", figsize=(10, 5), width=0.8)\n\nax.set_title(\"Course Enrollment by Semester\")\nax.set_xlabel(\"Semester\")\nax.set_ylabel(\"Number of Students\")\nax.legend(title=\"Course\", frameon=False)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas plotting wrapper `pivot.plot(kind='bar')` to render the data. Because it uses vertical bars and has two categorical dimensions (Semester and Course) resulting in multiple bars per X-axis tick, it is classified as a grouped column chart."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Pivot for plotting: semesters on x-axis, courses as series\npivot = df.pivot(index=\"Semester\", columns=\"Course\", values=\"Students\")\n\n# Keep semesters in chronological order\nsemester_order = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\npivot = pivot.reindex([s for s in semester_order if s in pivot.index])\n\n# Plot (single chart)\nax = pivot.plot(kind=\"bar\", figsize=(10, 6))\nax.set_title(\"Inscripción de estudiantes por curso y semestre\")\nax.set_xlabel(\"Semestre\")\nax.set_ylabel(\"Número de estudiantes\")\nax.legend(title=\"Curso\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas wrapper 'pivot.plot(kind=\"bar\")'. In pandas/matplotlib, 'bar' refers to vertical bars (Column chart). Because the DataFrame was pivoted to have multiple columns ('Course'), it results in groups of bars for each Semester, making it a Grouped column chart."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Ensure semester order\nsemester_order = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\ndf[\"Semester\"] = pd.Categorical(df[\"Semester\"], categories=semester_order, ordered=True)\n\n# Plot\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\nfig, ax = plt.subplots(figsize=(11, 6))\n\nsns.lineplot(\n    data=df.sort_values([\"Course\", \"Semester\"]),\n    x=\"Semester\",\n    y=\"Students\",\n    hue=\"Course\",\n    marker=\"o\",\n    linewidth=2.5,\n    markersize=8,\n    ax=ax,\n)\n\nax.set_title(\"Course Enrollment by Semester\")\nax.set_xlabel(\"Semester\")\nax.set_ylabel(\"Students Enrolled\")\nax.legend(title=\"Course\", frameon=True, loc=\"upper left\", bbox_to_anchor=(1.02, 1))\nax.margins(x=0.05)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Line chart", "color_palette": null, "reasoning": "The plot is generated using sns.lineplot() which renders temporal/ordinal (Semester), categorical (Course), and quantitative (Students) data. Following the library classification rules, the use of sns. functions designates the library as seaborn."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Ensure semester order\nsemester_order = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\ndf[\"Semester\"] = pd.Categorical(df[\"Semester\"], categories=semester_order, ordered=True)\n\n# Pivot for grouped bars\npivot = df.pivot(index=\"Course\", columns=\"Semester\", values=\"Students\").loc[\n    [\"Computer Science\", \"Mathematics\", \"Physics\", \"Chemistry\"]\n]\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\npivot.plot(kind=\"bar\", ax=ax, width=0.85)\n\nax.set_title(\"Course Enrollment by Semester\", pad=10, weight=\"bold\")\nax.set_xlabel(\"Course\")\nax.set_ylabel(\"Number of Students\")\nax.legend(title=\"Semester\", frameon=True)\nax.set_axisbelow(True)\n\n# Annotate values\nfor container in ax.containers:\n    ax.bar_label(container, fmt=\"%d\", padding=2, fontsize=9)\n\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the DataFrame.plot() method (pivot.plot), which identifies the library as pandas. The chart uses vertical bars (kind='bar') grouped by the 'Semester' column across the 'Course' index, which classifies it as a Grouped column chart."}}
{"input_csv_file": "18course_enrollment.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18course_enrollment.csv\")\n\n# Keep a logical semester order\nsemester_order = [\"Fall 2022\", \"Spring 2023\", \"Fall 2023\"]\ndf[\"Semester\"] = pd.Categorical(df[\"Semester\"], categories=semester_order, ordered=True)\n\n# Pivot for plotting\npivot = df.pivot(index=\"Semester\", columns=\"Course\", values=\"Students\").sort_index()\n\n# Plot: multi-series line chart (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\npivot.plot(ax=ax, marker=\"o\", linewidth=2)\n\nax.set_title(\"Course Enrollment by Semester\", pad=12)\nax.set_xlabel(\"Semester\")\nax.set_ylabel(\"Number of Students\")\nax.legend(title=\"Course\", ncol=2, frameon=True)\n\n# Improve readability\nax.set_ylim(0, max(pivot.max()) * 1.15)\nfor line in ax.lines:\n    for x, y in zip(line.get_xdata(), line.get_ydata()):\n        ax.annotate(\n            f\"{int(y)}\",\n            (x, y),\n            textcoords=\"offset points\",\n            xytext=(0, 6),\n            ha=\"center\",\n            fontsize=9,\n            color=line.get_color(),\n        )\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Line chart", "color_palette": null, "reasoning": "The plot is generated using the pandas DataFrame method `pivot.plot()`. Since it maps categorical variables (Courses) and temporal/ordinal data (Semesters) against a quantitative variable (Students) using lines and markers, it is classified as a Line chart."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Pivot to Department x Position matrix\npivot = df.pivot_table(index=\"Department\", columns=\"Position\", values=\"Employees\", aggfunc=\"sum\").fillna(0)\n\n# Ensure a sensible position order (present columns only)\npreferred_order = [\"Junior\", \"Mid-level\", \"Senior\", \"Manager\", \"Director\", \"VP\"]\ncol_order = [c for c in preferred_order if c in pivot.columns] + [c for c in pivot.columns if c not in preferred_order]\npivot = pivot[col_order]\n\n# Plot: stacked bar chart\nsns.set_theme(style=\"whitegrid\")\nax = pivot.plot(kind=\"bar\", stacked=True, figsize=(12, 6), colormap=\"tab20\")\n\nax.set_title(\"Employees by Department and Position\")\nax.set_xlabel(\"Department\")\nax.set_ylabel(\"Employees\")\nax.legend(title=\"Position\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked column chart", "color_palette": "tab20", "reasoning": "The plot is generated using the pandas .plot() method on a DataFrame (pivot.plot). Since kind='bar' defaults to a vertical orientation and stacked=True is specified, it is classified as a Stacked column chart according to the taxonomy."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Aggregate to a simple, readable view: total employees per department\ndept_totals = (\n    df.groupby(\"Department\", as_index=False)[\"Employees\"]\n      .sum()\n      .sort_values(\"Employees\", ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 5))\nplt.bar(dept_totals[\"Department\"], dept_totals[\"Employees\"], color=\"#4C78A8\")\nplt.title(\"Total Employees by Department\")\nplt.xlabel(\"Department\")\nplt.ylabel(\"Employees\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C78A8", "reasoning": "The visualization uses plt.bar() directly to render data, which according to the hierarchy rules classifies the library as matplotlib. Since plt.bar() creates vertical bars, it is classified as a Column chart per the taxonomy."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Aggregate: total employees per department\ndept_totals = (\n    df.groupby(\"Department\", as_index=False)[\"Employees\"]\n      .sum()\n      .sort_values(\"Employees\", ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 6))\nplt.bar(dept_totals[\"Department\"], dept_totals[\"Employees\"], color=\"#4C78A8\")\nplt.title(\"Total Employees by Department\")\nplt.xlabel(\"Department\")\nplt.ylabel(\"Employees\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() to render the data directly, which according to the hierarchy rules classifies the library as matplotlib. Since plt.bar() creates vertical bars, the chart type is classified as a Column chart."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Summarize: total employees per department\ndept_totals = (\n    df.groupby(\"Department\", as_index=False)[\"Employees\"]\n      .sum()\n      .sort_values(\"Employees\", ascending=False)\n)\n\n# Plot: simple bar chart (read the data level)\nplt.figure(figsize=(10, 5))\nplt.bar(dept_totals[\"Department\"], dept_totals[\"Employees\"], color=\"#4C78A8\")\nplt.title(\"Total Employees by Department\")\nplt.xlabel(\"Department\")\nplt.ylabel(\"Employees\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.bar() to render the data directly. Since plt.bar() creates vertical bars by default, it is classified as a Column chart."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Aggregate: total employees per department\ndept_totals = (\n    df.groupby(\"Department\", as_index=False)[\"Employees\"]\n      .sum()\n      .sort_values(\"Employees\", ascending=True)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 6))\nplt.barh(dept_totals[\"Department\"], dept_totals[\"Employees\"], color=\"#4C78A8\")\nplt.title(\"Total Employees by Department\")\nplt.xlabel(\"Employees\")\nplt.ylabel(\"Department\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the matplotlib.pyplot function 'plt.barh()' to draw the data, which creates horizontal bars. According to the taxonomy, horizontal bars are classified as a 'Bar chart'."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Pivot to show Employees by Department and Position\npivot = df.pivot_table(index=\"Department\", columns=\"Position\", values=\"Employees\", aggfunc=\"sum\", fill_value=0)\n\n# Order positions (common career progression)\nposition_order = [\"Junior\", \"Mid-level\", \"Senior\", \"Manager\", \"Director\", \"VP\"]\npivot = pivot[[p for p in position_order if p in pivot.columns]]\n\n# Plot: stacked bar chart\nplt.figure(figsize=(12, 6))\nax = pivot.plot(kind=\"bar\", stacked=True, width=0.85)\n\nax.set_title(\"Employees by Department and Position\")\nax.set_xlabel(\"Department\")\nax.set_ylabel(\"Number of Employees\")\nax.legend(title=\"Position\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", frameon=False)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The visualization is created using the pandas DataFrame plotting wrapper `pivot.plot(kind='bar', stacked=True)`. Per the hierarchy rules, even though matplotlib is used for styling, the primary rendering method identifies the library as 'pandas'. The `kind='bar'` argument produces vertical bars (Column chart), and `stacked=True` organizes the two categorical dimensions (Department and Position) into a 'Stacked column chart'."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"18employee_department.csv\")\n\n    pivot = (\n        df.pivot_table(index=\"Department\", columns=\"Position\", values=\"Employees\", aggfunc=\"sum\")\n        .fillna(0)\n        .astype(int)\n    )\n\n    departments = pivot.index.tolist()\n    positions = list(pivot.columns)\n\n    fig, ax = plt.subplots(figsize=(12, 6))\n\n    bottom = [0] * len(departments)\n    for pos in positions:\n        vals = pivot[pos].values\n        ax.bar(departments, vals, bottom=bottom, label=pos)\n        bottom = [b + v for b, v in zip(bottom, vals)]\n\n    ax.set_title(\"Employees by Department and Position\")\n    ax.set_xlabel(\"Department\")\n    ax.set_ylabel(\"Employees\")\n    ax.legend(title=\"Position\", ncols=3, frameon=False)\n    ax.tick_params(axis=\"x\", rotation=45, labelsize=10)\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.3)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The code uses 'ax.bar()' to create vertical bars and implements a stacking logic manually using the 'bottom' parameter in a loop over positions. Since it uses the matplotlib axes object directly to render data rather than pandas or seaborn wrappers, the library is matplotlib."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"18employee_department.csv\")\n\n    # Pivot to Department x Position for a single heatmap chart\n    pivot = df.pivot_table(\n        index=\"Department\",\n        columns=\"Position\",\n        values=\"Employees\",\n        aggfunc=\"sum\",\n        fill_value=0\n    )\n\n    # Keep a sensible position order (others, if any, appended)\n    desired_order = [\"Junior\", \"Mid-level\", \"Senior\", \"Manager\", \"Director\", \"VP\"]\n    cols = [c for c in desired_order if c in pivot.columns] + [c for c in pivot.columns if c not in desired_order]\n    pivot = pivot[cols]\n\n    fig, ax = plt.subplots(figsize=(11, 6))\n    im = ax.imshow(pivot.values, aspect=\"auto\", cmap=\"YlGnBu\")\n\n    ax.set_title(\"Employees by Department and Position\", pad=12)\n    ax.set_xlabel(\"Position\")\n    ax.set_ylabel(\"Department\")\n\n    ax.set_xticks(range(len(pivot.columns)))\n    ax.set_xticklabels(pivot.columns, rotation=30, ha=\"right\")\n    ax.set_yticks(range(len(pivot.index)))\n    ax.set_yticklabels(pivot.index)\n\n    # Annotate counts in each cell\n    for i in range(pivot.shape[0]):\n        for j in range(pivot.shape[1]):\n            val = int(pivot.iat[i, j])\n            ax.text(j, i, str(val), ha=\"center\", va=\"center\", fontsize=8, color=\"black\")\n\n    cbar = fig.colorbar(im, ax=ax)\n    cbar.set_label(\"Employees\")\n\n    fig.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "YlGnBu", "reasoning": "The code uses the matplotlib axes method ax.imshow() to visualize a 2D matrix (pivot table) where rows and columns represent categorical dimensions and the color represents a quantitative value."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Total employees by department\ndept_totals = (\n    df.groupby(\"Department\", as_index=False)[\"Employees\"]\n      .sum()\n      .sort_values(\"Employees\", ascending=True)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 6))\nplt.barh(dept_totals[\"Department\"], dept_totals[\"Employees\"], color=\"#4C78A8\")\nplt.title(\"Total de empleados por departamento\")\nplt.xlabel(\"Empleados\")\nplt.ylabel(\"Departamento\")\n\n# Value labels\nfor i, v in enumerate(dept_totals[\"Employees\"]):\n    plt.text(v + max(dept_totals[\"Employees\"]) * 0.01, i, str(v), va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses 'plt.barh()' to render horizontal bars representing categorical departments and quantitative employee counts, which classifies it as a 'Bar chart' in the taxonomy. Since the data is rendered using the pyplot module directly rather than through dataframe plotting methods, the library is 'matplotlib'."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Pivot to Department x Position matrix\npivot = df.pivot_table(index=\"Department\", columns=\"Position\", values=\"Employees\", aggfunc=\"sum\", fill_value=0)\n\n# Order positions for readability (only those present)\npreferred_order = [\"Junior\", \"Mid-level\", \"Senior\", \"Manager\", \"Director\", \"VP\"]\npos_order = [p for p in preferred_order if p in pivot.columns] + [p for p in pivot.columns if p not in preferred_order]\npivot = pivot[pos_order]\n\n# Order departments by total employees (descending)\ndept_order = pivot.sum(axis=1).sort_values(ascending=False).index\npivot = pivot.loc[dept_order]\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 7))\n\nbottom = None\npalette = sns.color_palette(\"Set2\", n_colors=len(pivot.columns))\n\nfor i, col in enumerate(pivot.columns):\n    if bottom is None:\n        ax.bar(pivot.index, pivot[col].values, label=col, color=palette[i], edgecolor=\"white\", linewidth=0.7)\n        bottom = pivot[col].values\n    else:\n        ax.bar(pivot.index, pivot[col].values, bottom=bottom, label=col, color=palette[i], edgecolor=\"white\", linewidth=0.7)\n        bottom = bottom + pivot[col].values\n\nax.set_title(\"Employees by Department and Position (Stacked)\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Department\")\nax.set_ylabel(\"Employees\")\n\nax.tick_params(axis=\"x\", rotation=35, labelsize=10)\nax.tick_params(axis=\"y\", labelsize=10)\n\n# Legend\nax.legend(title=\"Position\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", frameon=True)\n\n# Tight layout to fit legend\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked column chart", "color_palette": "Set2", "reasoning": "The code uses ax.bar() inside a loop to render vertical bars stacked on top of one another using the 'bottom' parameter. Following the hierarchy rules, even though Seaborn is used for styling and palette generation, the data rendering is performed via Matplotlib axes functions."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Pivot to Department x Position\npivot = (\n    df.pivot_table(index=\"Department\", columns=\"Position\", values=\"Employees\", aggfunc=\"sum\", fill_value=0)\n)\n\n# Order positions in a sensible hierarchy (keep any unexpected positions at the end)\npreferred_order = [\"Junior\", \"Mid-level\", \"Senior\", \"Manager\", \"Director\", \"VP\"]\npos_order = [p for p in preferred_order if p in pivot.columns] + [p for p in pivot.columns if p not in preferred_order]\npivot = pivot[pos_order]\n\n# Sort departments by total headcount\npivot = pivot.loc[pivot.sum(axis=1).sort_values(ascending=False).index]\n\n# Plot: stacked horizontal bar chart\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 7))\n\ncolors = sns.color_palette(\"viridis\", n_colors=pivot.shape[1])\npivot.plot(kind=\"barh\", stacked=True, ax=ax, color=colors, edgecolor=\"white\", linewidth=0.6)\n\nax.set_title(\"Employee Counts by Department and Position\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Employees\")\nax.set_ylabel(\"Department\")\n\n# Legend on the right\nax.legend(title=\"Position\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", frameon=True)\n\n# Clean up\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked bar chart", "color_palette": "viridis", "reasoning": "The data is rendered using the `pivot.plot()` method (a pandas wrapper) with `kind='barh'` for horizontal bars and `stacked=True`, which classifies it as a Stacked bar chart."}}
{"input_csv_file": "18employee_department.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"18employee_department.csv\")\n\n# Aggregate employees per department\ndept_totals = (\n    df.groupby(\"Department\", as_index=False)[\"Employees\"]\n      .sum()\n      .sort_values(\"Employees\", ascending=True)\n)\n\n# Style\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6.5))\n\n# Single chart: employees by department (horizontal bar)\npalette = sns.color_palette(\"viridis\", n_colors=len(dept_totals))\nax.barh(dept_totals[\"Department\"], dept_totals[\"Employees\"], color=palette)\n\n# Labels and title\nax.set_title(\"Total Employees by Department\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Employees\")\nax.set_ylabel(\"Department\")\n\n# Value labels\nxmax = dept_totals[\"Employees\"].max()\nax.set_xlim(0, xmax * 1.12)\nfor y, v in enumerate(dept_totals[\"Employees\"]):\n    ax.text(v + xmax * 0.02, y, f\"{v}\", va=\"center\", ha=\"left\", fontsize=10)\n\nsns.despine(left=False, bottom=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "viridis", "reasoning": "The data is rendered using ax.barh(), which is a standard Matplotlib Axes method for drawing horizontal bars. Although Seaborn is used for styling and defining the color palette, it does not perform the drawing action. Per the taxonomy, horizontal bars are classified as a 'Bar chart'."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Prepare data for grouped bar chart\nquarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\nregions = df[\"Region\"].tolist()\nvalues = df[quarters].to_numpy()\n\nx = np.arange(len(regions))\nwidth = 0.2\n\n# Plot\nplt.figure(figsize=(12, 6))\nfor i, q in enumerate(quarters):\n    plt.bar(x + (i - 1.5) * width, values[:, i], width=width, label=q)\n\nplt.title(\"Quarterly Sales by Region\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Sales\")\nplt.xticks(x, regions, rotation=25, ha=\"right\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.legend(title=\"Quarter\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses plt.bar() within a loop and manually calculates offsets to group the vertical bars by category (Quarter) for each region. Since it uses the standard matplotlib.pyplot function to render the data directly, the library is classified as matplotlib."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Prepare data: total annual sales per region\nquarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\ndf[\"Annual_Total\"] = df[quarters].sum(axis=1)\ndf = df.sort_values(\"Annual_Total\", ascending=False)\n\n# Plot: single chart (bar chart)\nplt.figure(figsize=(10, 5))\nbars = plt.bar(df[\"Region\"], df[\"Annual_Total\"], color=\"#4C78A8\")\n\nplt.title(\"Total Annual Sales by Region (Q1–Q4)\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Sales (Total)\")\n\n# Value labels\nfor b in bars:\n    y = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, y, f\"{y:,.0f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.xticks(rotation=25, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C78A8", "reasoning": "The code uses plt.bar() to render the data directly, which identifies the library as matplotlib. Because the bars are vertical (the default for plt.bar) and represent a categorical dimension (Region) against a quantitative dimension (Annual_Total), it is classified as a Column chart."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Compute annual total per region\nquarter_cols = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\ndf[\"Annual Total\"] = df[quarter_cols].sum(axis=1)\n\n# Sort for readability\ndf = df.sort_values(\"Annual Total\", ascending=False)\n\n# Plot: single chart (bar chart)\nplt.figure(figsize=(10, 5))\nplt.bar(df[\"Region\"], df[\"Annual Total\"], color=\"#4C78A8\")\n\nplt.title(\"Total Annual Sales by Region (Q1–Q4)\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Total Sales\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using plt.bar() directly rather than a pandas or seaborn wrapper, which classifies the library as 'matplotlib'. Since the bars are vertical (plt.bar), it is classified as a 'Column chart' according to the taxonomy."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Reshape to long format for plotting\nlong_df = df.melt(id_vars=\"Region\", var_name=\"Quarter\", value_name=\"Sales\")\n\n# Plot: grouped bar chart (one chart)\nquarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\nregions = df[\"Region\"].tolist()\n\npivot = long_df.pivot(index=\"Region\", columns=\"Quarter\", values=\"Sales\").loc[regions, quarters]\n\nax = pivot.plot(kind=\"bar\", figsize=(11, 6), width=0.85)\n\nax.set_title(\"Quarterly Sales by Region\")\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Sales ($)\")\nax.legend(title=\"Quarter\", ncols=4, loc=\"upper left\", bbox_to_anchor=(0, 1.02))\n\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.xticks(rotation=25, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas DataFrame method `.plot(kind='bar')`. Since the bars are vertical (default for 'bar') and the data involves two categories (Region and Quarter) grouped together for one quantitative value (Sales), it is classified as a Grouped column chart."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Prepare long-form data for plotting\nlong_df = df.melt(id_vars=\"Region\", var_name=\"Quarter\", value_name=\"Sales\")\nquarter_order = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\nlong_df[\"Quarter\"] = pd.Categorical(long_df[\"Quarter\"], categories=quarter_order, ordered=True)\nlong_df = long_df.sort_values([\"Quarter\", \"Region\"])\n\n# Plot: multi-line chart (one line per region)\nplt.figure(figsize=(11, 6))\nfor region, g in long_df.groupby(\"Region\"):\n    g = g.sort_values(\"Quarter\")\n    plt.plot(g[\"Quarter\"], g[\"Sales\"], marker=\"o\", linewidth=2, label=region)\n\nplt.title(\"Quarterly Sales by Region\")\nplt.xlabel(\"Quarter\")\nplt.ylabel(\"Sales\")\nplt.grid(True, axis=\"y\", alpha=0.3)\nplt.legend(title=\"Region\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", borderaxespad=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib pyplot function plt.plot() inside a loop to draw temporal data (Quarters) against quantitative data (Sales) for multiple regions, making it a Line chart rendered directly through matplotlib."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Prepare data for a single chart (stacked bar by quarter)\nquarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\ndata = df.set_index(\"Region\")[quarters]\n\n# Plot\nplt.figure(figsize=(10, 6))\nax = data.plot(kind=\"bar\", stacked=True)\n\nax.set_title(\"Regional Sales by Quarter (Stacked)\")\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Sales\")\nax.legend(title=\"Quarter\", bbox_to_anchor=(1.02, 1), loc=\"upper left\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The plot is rendered using the pandas DataFrame method `data.plot()`. The parameter `kind='bar'` generates vertical bars (Column chart) and `stacked=True` combines multiple categories (Quarters) per region, making it a Stacked column chart."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"18region_sales.csv\")\n\n    quarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\n    df[\"Total\"] = df[quarters].sum(axis=1)\n    df = df.sort_values(\"Total\", ascending=False)\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.barh(df[\"Region\"], df[\"Total\"], color=\"#4C78A8\")\n    ax.invert_yaxis()\n\n    ax.set_title(\"Total Annual Sales by Region (Q1–Q4)\")\n    ax.set_xlabel(\"Total Sales\")\n    ax.set_ylabel(\"Region\")\n\n    for i, v in enumerate(df[\"Total\"].values):\n        ax.text(v, i, f\"  {v:,.0f}\", va=\"center\", ha=\"left\", fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the matplotlib axes method `ax.barh()` to render the data directly, which classifies the library as matplotlib and the chart type as a horizontal Bar chart according to the provided taxonomy."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"18region_sales.csv\")\n\n    quarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\n    totals = df[quarters].sum().reindex(quarters)\n\n    plt.figure(figsize=(8, 5))\n    plt.bar(totals.index, totals.values, color=\"#4C78A8\")\n    plt.title(\"Total Sales by Quarter (All Regions)\")\n    plt.xlabel(\"Quarter\")\n    plt.ylabel(\"Total Sales\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the `plt.bar()` function directly from the matplotlib library, which produces vertical bars by default. Therefore, it is classified as a Column chart and the library is matplotlib."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Ensure numeric columns are numeric\nquarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\ndf[quarters] = df[quarters].apply(pd.to_numeric, errors=\"coerce\")\n\n# Plot: grouped bar chart of quarterly sales by region\nplt.figure(figsize=(11, 6))\ndf.set_index(\"Region\")[quarters].plot(kind=\"bar\", width=0.85, ax=plt.gca())\n\nplt.title(\"Ventas trimestrales por región\")\nplt.xlabel(\"Región\")\nplt.ylabel(\"Ventas\")\nplt.xticks(rotation=25, ha=\"right\")\nplt.legend(title=\"Trimestre\", ncol=4, frameon=False)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data rendering is performed via the 'df.plot(kind=\"bar\")' method, which identifies the library as pandas. Because the bars are vertical and represent multiple categories (Q1-Q4) for each index (Region), it is classified as a Grouped column chart."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Prepare data\nquarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\nregions = df[\"Region\"].tolist()\nvalues = df[quarters].values\n\n# Style\nplt.rcParams.update({\n    \"figure.figsize\": (11, 6.5),\n    \"axes.titlesize\": 14,\n    \"axes.labelsize\": 11,\n    \"xtick.labelsize\": 10,\n    \"ytick.labelsize\": 10,\n})\n\nfig, ax = plt.subplots()\n\n# Grouped bars\nx = np.arange(len(regions))\nbar_w = 0.18\ncolors = [\"#4C78A8\", \"#F58518\", \"#54A24B\", \"#B279A2\"]\n\nfor i, q in enumerate(quarters):\n    ax.bar(x + (i - 1.5) * bar_w, values[:, i], width=bar_w, label=q, color=colors[i])\n\n# Formatting\nax.set_title(\"Quarterly Sales by Region\")\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Sales (USD)\")\nax.set_xticks(x)\nax.set_xticklabels(regions, rotation=20, ha=\"right\")\nax.yaxis.set_major_formatter(mtick.StrMethodFormatter(\"${x:,.0f}\"))\nax.grid(axis=\"y\", linestyle=\"--\", linewidth=0.8, alpha=0.35)\nax.set_axisbelow(True)\n\n# Legend\nax.legend(title=\"Quarter\", ncols=4, frameon=False, bbox_to_anchor=(0.5, 1.02), loc=\"lower center\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.bar() function within a loop to plot vertical bars for different quarters side-by-side for each region. Since there are two categorical dimensions (Region and Quarter) and one quantitative value (Sales) arranged vertically, it is classified as a Grouped column chart."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Prepare data\nquarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\ndf[\"Total\"] = df[quarters].sum(axis=1)\ndf = df.sort_values(\"Total\", ascending=False)\n\n# Plot: stacked bars by quarter per region\nfig, ax = plt.subplots(figsize=(10.5, 6.2))\n\ncolors = [\"#4C78A8\", \"#F58518\", \"#54A24B\", \"#E45756\"]\nbottom = pd.Series([0] * len(df), index=df.index)\n\nfor q, c in zip(quarters, colors):\n    ax.bar(df[\"Region\"], df[q], bottom=bottom, label=q, color=c, edgecolor=\"white\", linewidth=0.6)\n    bottom += df[q]\n\n# Styling\nax.set_title(\"Regional Sales by Quarter (Stacked)\", pad=12)\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Sales (USD)\")\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x:,.0f}\"))\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\n\n# Legend\nax.legend(title=\"Quarter\", ncols=4, frameon=False, loc=\"upper center\", bbox_to_anchor=(0.5, 1.08))\n\n# Layout\nplt.xticks(rotation=25, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The code uses the Matplotlib axes method `ax.bar()` to render data. Since the bars are vertical (default for `ax.bar`) and use the 'bottom' parameter to layer multiple categorical values (Quarters) per region, it is classified as a Stacked column chart."}}
{"input_csv_file": "18region_sales.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"18region_sales.csv\")\n\n# Prepare for grouped bars\nquarters = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\nregions = df[\"Region\"].tolist()\nvalues = df[quarters].to_numpy()\n\nx = np.arange(len(regions))\nbar_w = 0.18\noffsets = (np.arange(len(quarters)) - (len(quarters) - 1) / 2) * bar_w\n\n# Figure\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 6.5))\n\ncolors = [\"#4E79A7\", \"#F28E2B\", \"#59A14F\", \"#E15759\"]\n\nfor i, q in enumerate(quarters):\n    ax.bar(x + offsets[i], values[:, i], width=bar_w, label=q, color=colors[i], edgecolor=\"white\", linewidth=0.8)\n\n# Labels & title\nax.set_title(\"Regional Sales by Quarter\", fontsize=14, pad=12, weight=\"semibold\")\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Sales\")\n\n# Ticks\nax.set_xticks(x)\nax.set_xticklabels(regions, rotation=20, ha=\"right\")\n\n# Y formatting\nymax = values.max()\nax.set_ylim(0, ymax * 1.18)\nax.yaxis.set_major_formatter(lambda v, pos: f\"{v:,.0f}\")\n\n# Legend\nax.legend(title=\"Quarter\", ncols=4, frameon=True, loc=\"upper center\", bbox_to_anchor=(0.5, 1.08))\n\n# Clean spines\nfor s in [\"top\", \"right\"]:\n    ax.spines[s].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.bar() function to render vertical bars. By iterating through the 'quarters' and applying manual offsets to the x-coordinates, it creates a grouped layout for vertical bars, which classifies it as a Grouped column chart."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Aggregate: average price by Type\ntype_avg = (\n    df.groupby(\"Type\", as_index=False)[\"Price\"]\n      .mean()\n      .sort_values(\"Price\", ascending=False)\n)\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(10, 6))\nax = sns.barplot(data=type_avg, x=\"Type\", y=\"Price\", color=\"#4C72B0\")\n\nax.set_title(\"Average Car Price by Type\")\nax.set_xlabel(\"Car Type\")\nax.set_ylabel(\"Average Price (USD)\")\n\n# Format y-axis with thousands separators\nax.get_yaxis().set_major_formatter(\n    plt.FuncFormatter(lambda x, pos: f\"{int(x):,}\")\n)\n\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses sns.barplot with the category 'Type' on the x-axis and the quantitative value 'Price' on the y-axis, which creates vertical bars (classified as a Column chart). The library is identified as seaborn because the rendering function sns.barplot is used."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Make sure Price is numeric\ndf[\"Price\"] = pd.to_numeric(df[\"Price\"], errors=\"coerce\")\n\n# Average price by car Type (simple, \"read the data\" level summary)\navg_by_type = df.groupby(\"Type\", as_index=False)[\"Price\"].mean().sort_values(\"Price\", ascending=False)\n\n# Plot: one clear chart\nplt.figure(figsize=(10, 5))\nplt.bar(avg_by_type[\"Type\"], avg_by_type[\"Price\"], color=\"#4C78A8\")\nplt.title(\"Average Car Price by Type\")\nplt.xlabel(\"Car Type\")\nplt.ylabel(\"Average Price (USD)\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the 'plt.bar' function from matplotlib to render vertical bars, which classifies it as a 'Column chart' according to the taxonomy. Because it uses pyplot directly rather than a pandas wrapper (df.plot) or seaborn, the library is identified as 'matplotlib'."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Summarize: average price by car type\navg_by_type = df.groupby(\"Type\", as_index=True)[\"Price\"].mean().sort_values(ascending=False)\n\n# Plot: bar chart of average price by type\nplt.figure(figsize=(10, 5))\navg_by_type.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\n\nplt.title(\"Average Car Price by Type\")\nplt.xlabel(\"Type\")\nplt.ylabel(\"Average Price (USD)\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, this classifies the library as 'pandas'. The resulting bars are vertical, which corresponds to the 'Column chart' category in the taxonomy."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Summarize: average price by car type\navg_by_type = df.groupby(\"Type\", as_index=True)[\"Price\"].mean().sort_values(ascending=False)\n\n# Plot: single chart (bar chart)\nplt.figure(figsize=(10, 5))\navg_by_type.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Average Car Price by Type\")\nplt.xlabel(\"Car Type\")\nplt.ylabel(\"Average Price (USD)\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas Series.plot() method, which categorizes the library as 'pandas' per the hierarchy rules. The kind='bar' parameter generates vertical bars, which fits the taxonomy definition for a 'Column chart'."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Aggregate: average price by car Type\navg_by_type = (\n    df.groupby(\"Type\", as_index=False)[\"Price\"]\n      .mean()\n      .sort_values(\"Price\", ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 6))\nplt.bar(avg_by_type[\"Type\"], avg_by_type[\"Price\"], color=\"#4C78A8\")\nplt.title(\"Average Car Price by Type\")\nplt.xlabel(\"Type\")\nplt.ylabel(\"Average Price\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render data, which draws vertical bars. According to the hierarchy rules, since plt functions are used for drawing instead of sns or pandas wrappers, the library is matplotlib."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Aggregate: average price by car Type\ntype_avg = df.groupby(\"Type\", as_index=False)[\"Price\"].mean().sort_values(\"Price\", ascending=False)\n\n# Plot: single chart\nplt.figure(figsize=(10, 5))\nplt.bar(type_avg[\"Type\"], type_avg[\"Price\"], color=\"#4C78A8\")\nplt.title(\"Average Car Price by Type\")\nplt.xlabel(\"Type\")\nplt.ylabel(\"Average Price\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() which renders vertical bars, identifying it as a Column chart according to the taxonomy. Since the data is rendered using the pyplot function directly rather than a pandas or seaborn wrapper method, the library is classified as matplotlib. A single hex color was provided rather than a named palette."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Aggregate: average price by Type\ntype_stats = (\n    df.groupby(\"Type\", as_index=False)\n      .agg(AveragePrice=(\"Price\", \"mean\"), Count=(\"Price\", \"size\"))\n      .sort_values(\"AveragePrice\", ascending=False)\n)\n\n# Plot: single chart\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.barplot(\n    data=type_stats,\n    x=\"AveragePrice\",\n    y=\"Type\",\n    ax=ax,\n    color=\"#4C78A8\"\n)\n\nax.set_title(\"Average Car Price by Type\")\nax.set_xlabel(\"Average Price\")\nax.set_ylabel(\"Type\")\n\n# Add count labels at the end of each bar\nxmax = type_stats[\"AveragePrice\"].max()\nfor i, row in enumerate(type_stats.itertuples(index=False)):\n    ax.text(\n        row.AveragePrice + xmax * 0.01,\n        i,\n        f\"n={row.Count}\",\n        va=\"center\",\n        ha=\"left\",\n        fontsize=10\n    )\n\nax.set_xlim(0, xmax * 1.15)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the `sns.barplot` function from the seaborn library. Because the categorical variable ('Type') is mapped to the y-axis and the quantitative variable ('AveragePrice') is mapped to the x-axis, the resulting bars are horizontal, classifying it as a Bar chart. Although matplotlib is used for subplot management and text annotations, the primary data rendering is done by seaborn."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Aggregate: average price by car Type\navg_by_type = df.groupby(\"Type\", as_index=True)[\"Price\"].mean().sort_values(ascending=False)\n\n# Plot: single chart\nplt.figure(figsize=(10, 5.5))\nax = avg_by_type.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\n\nax.set_title(\"Average Car Price by Type\")\nax.set_xlabel(\"Type\")\nax.set_ylabel(\"Average Price\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.xticks(rotation=30, ha=\"right\")\n\n# Annotate values\nfor p in ax.patches:\n    val = p.get_height()\n    ax.annotate(f\"{val:,.0f}\", (p.get_x() + p.get_width() / 2, val),\n                ha=\"center\", va=\"bottom\", fontsize=9, xytext=(0, 3),\n                textcoords=\"offset points\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas Series `.plot()` method with `kind='bar'`. According to the hierarchy rules, usage of `.plot()` classifies the library as 'pandas' even if matplotlib is used for styling. Because the bars are vertical, it is classified as a Column chart."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Promedio de precio por tipo de vehículo\navg_by_type = df.groupby(\"Type\", as_index=False)[\"Price\"].mean().sort_values(\"Price\", ascending=False)\n\n# Gráfico (un solo chart)\nplt.figure(figsize=(10, 5))\nplt.bar(avg_by_type[\"Type\"], avg_by_type[\"Price\"], color=\"#4C72B0\")\nplt.title(\"Precio promedio por tipo de vehículo\")\nplt.xlabel(\"Tipo\")\nplt.ylabel(\"Precio promedio\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses `plt.bar()` to render data directly from a DataFrame's columns. According to the hierarchy rules, direct use of pyplot functions (plt.bar) identifies the library as matplotlib. Since `plt.bar()` creates vertical bars by default, it is classified as a Column chart."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ncsv_path = \"19mycarsUnique.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate: average price by Type\ntype_stats = (\n    df.groupby(\"Type\", as_index=False)\n      .agg(AvgPrice=(\"Price\", \"mean\"), Count=(\"Price\", \"size\"))\n      .sort_values(\"AvgPrice\", ascending=True)\n)\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 6.2))\n\nbars = ax.barh(\n    type_stats[\"Type\"],\n    type_stats[\"AvgPrice\"],\n    color=sns.color_palette(\"Blues\", n_colors=len(type_stats))\n)\n\nax.set_title(\"Average Car Price by Vehicle Type\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Average Price (USD)\")\nax.set_ylabel(\"Vehicle Type\")\n\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x:,.0f}\"))\n\n# Label values + sample size\nxmax = type_stats[\"AvgPrice\"].max()\npad = xmax * 0.015\nfor bar, avg, n in zip(bars, type_stats[\"AvgPrice\"], type_stats[\"Count\"]):\n    ax.text(\n        bar.get_width() + pad,\n        bar.get_y() + bar.get_height() / 2,\n        f\"${avg:,.0f}  (n={n})\",\n        va=\"center\",\n        ha=\"left\",\n        fontsize=10\n    )\n\nax.set_xlim(0, xmax * 1.18)\nsns.despine(left=True, bottom=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "Blues", "reasoning": "The data is rendered using the ax.barh() method from the matplotlib library. Because the bars are oriented horizontally, it is classified as a Bar chart according to the taxonomy."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"19mycarsUnique.csv\")\n\n# Aggregate: average price by car Type (robust to missing combinations)\ntype_stats = (\n    df.groupby(\"Type\", as_index=False)\n      .agg(avg_price=(\"Price\", \"mean\"), n=(\"Price\", \"size\"))\n      .sort_values(\"avg_price\", ascending=False)\n)\n\n# Plot\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\nfig, ax = plt.subplots(figsize=(11, 6.5))\n\npalette = sns.color_palette(\"viridis\", n_colors=len(type_stats))\nbars = ax.bar(type_stats[\"Type\"], type_stats[\"avg_price\"], color=palette, edgecolor=\"none\")\n\n# Formatting\nax.set_title(\"Average Car Price by Vehicle Type\")\nax.set_xlabel(\"Vehicle Type\")\nax.set_ylabel(\"Average Price (USD)\")\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x:,.0f}\"))\n\n# Label bars with avg price and sample size\nfor rect, avg, n in zip(bars, type_stats[\"avg_price\"], type_stats[\"n\"]):\n    ax.text(\n        rect.get_x() + rect.get_width() / 2,\n        rect.get_height(),\n        f\"${avg:,.0f}\\n(n={n})\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=11,\n        color=\"#1f2937\",\n        clip_on=False\n    )\n\nax.margins(y=0.12)\nplt.xticks(rotation=25, ha=\"right\")\nsns.despine(left=True, bottom=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "viridis", "reasoning": "The data is rendered using 'ax.bar()', which is a matplotlib function. Although seaborn is used for styling (set_theme, despine) and to generate the color palette, the core data rendering is handled directly by matplotlib axes. Since 'ax.bar' produces vertical bars, it is classified as a Column chart."}}
{"input_csv_file": "19mycarsUnique.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"19mycarsUnique.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate: average price by Brand (Name)\nbrand_avg = (\n    df.groupby(\"Name\", as_index=False)[\"Price\"]\n      .mean()\n      .sort_values(\"Price\", ascending=True)\n)\n\n# Plot: horizontal bar chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nax.barh(brand_avg[\"Name\"], brand_avg[\"Price\"], color=\"#2E86AB\")\n\nax.set_title(\"Average Car Price by Brand\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Average Price (USD)\")\nax.set_ylabel(\"Brand\")\n\n# Format x-axis ticks as dollars\nax.xaxis.set_major_formatter(lambda x, pos: f\"${x:,.0f}\")\n\n# Value labels\nxmax = brand_avg[\"Price\"].max()\nfor y, v in enumerate(brand_avg[\"Price\"]):\n    ax.text(v + 0.01 * xmax, y, f\"${v:,.0f}\", va=\"center\", ha=\"left\", fontsize=9)\n\nax.margins(x=0.12)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib axes function ax.barh() to render the data directly, which produces horizontal bars for a categorical variable and a quantitative variable."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"19store_item.csv\")\n\n    categories = [\"Clothing\", \"Equipment\", \"Accessories\"]\n    ax = df.set_index(\"Store\")[categories].plot(kind=\"bar\", figsize=(10, 5), width=0.8)\n\n    ax.set_title(\"Sales by Category and Store\")\n    ax.set_xlabel(\"Store\")\n    ax.set_ylabel(\"Sales ($)\")\n    ax.legend(title=\"Category\", frameon=False)\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n    plt.xticks(rotation=25, ha=\"right\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The plot is generated using the pandas DataFrame wrapper `df.plot(kind='bar')`. Since the bars are vertical and the code plots multiple quantitative categories (Clothing, Equipment, Accessories) per Store categorical index, it is classified as a Grouped column chart."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19store_item.csv\")\n\n# Plot: grouped bar chart for each store by category\ncategories = [\"Clothing\", \"Equipment\", \"Accessories\"]\nax = df.set_index(\"Store\")[categories].plot(kind=\"bar\", figsize=(10, 5))\n\nax.set_title(\"Sales by Category Across Stores\")\nax.set_xlabel(\"Store\")\nax.set_ylabel(\"Sales ($)\")\nax.legend(title=\"Category\")\nax.tick_params(axis=\"x\", rotation=20)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas '.plot()' method on a DataFrame. The 'kind=\"bar\"' parameter produces vertical bars, and because multiple columns (categories) are plotted for each index (Store), it results in a Grouped column chart."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19store_item.csv\")\n\n# Prepare stacked bar chart\nstores = df[\"Store\"]\ncategories = [\"Clothing\", \"Equipment\", \"Accessories\"]\n\nplt.figure(figsize=(10, 6))\nbottom = None\nfor cat in categories:\n    if bottom is None:\n        plt.bar(stores, df[cat], label=cat)\n        bottom = df[cat].copy()\n    else:\n        plt.bar(stores, df[cat], bottom=bottom, label=cat)\n        bottom = bottom + df[cat]\n\nplt.title(\"Sales by Category per Store (Stacked)\")\nplt.xlabel(\"Store\")\nplt.ylabel(\"Sales ($)\")\nplt.xticks(rotation=25, ha=\"right\")\nplt.legend(title=\"Category\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render data rather than pandas or seaborn wrappers. Because the bars are vertical and stacked using the 'bottom' parameter across two categorical dimensions (Store and Category), it is classified as a Stacked column chart."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19store_item.csv\")\n\n# Prepare chart: stacked bar to show composition per store\ndf_plot = df.set_index(\"Store\")[[\"Clothing\", \"Equipment\", \"Accessories\"]]\n\nax = df_plot.plot(\n    kind=\"bar\",\n    stacked=True,\n    figsize=(10, 5),\n    color=[\"#4C78A8\", \"#F58518\", \"#54A24B\"],\n    edgecolor=\"white\",\n    linewidth=0.7,\n)\n\nax.set_title(\"Sales by Category per Store (Stacked)\")\nax.set_xlabel(\"Store\")\nax.set_ylabel(\"Sales ($)\")\nax.legend(title=\"Category\", frameon=False, ncols=3, loc=\"upper center\", bbox_to_anchor=(0.5, 1.15))\n\n# Improve readability\nplt.xticks(rotation=25, ha=\"right\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas .plot() method with kind='bar' and stacked=True. In accordance with the taxonomy, vertical bars are classified as 'Column charts', and because stacked=True is used, it is a 'Stacked column chart'. The colors are provided as a list of hex codes rather than a named palette."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19store_item.csv\")\n\n# Prepare plot\nstores = df[\"Store\"]\ncategories = [\"Clothing\", \"Equipment\", \"Accessories\"]\n\nfig, ax = plt.subplots(figsize=(10, 5))\n\nbottom = [0] * len(df)\nfor cat in categories:\n    ax.bar(stores, df[cat], bottom=bottom, label=cat)\n    bottom = [b + v for b, v in zip(bottom, df[cat].tolist())]\n\nax.set_title(\"Sales by Category per Store (Stacked)\")\nax.set_xlabel(\"Store\")\nax.set_ylabel(\"Sales\")\nax.legend(title=\"Category\")\nplt.xticks(rotation=25, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib axes method `ax.bar()` inside a loop. The bars are vertical and the 'bottom' parameter is used to stack different categories, making it a Stacked column chart."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"19store_item.csv\")\n\n    items = [\"Clothing\", \"Equipment\", \"Accessories\"]\n    df[\"Total\"] = df[items].sum(axis=1)\n    df_sorted = df.sort_values(\"Total\", ascending=False)\n\n    plt.figure(figsize=(9, 5))\n    plt.barh(df_sorted[\"Store\"], df_sorted[\"Total\"], color=\"#4C78A8\")\n    plt.gca().invert_yaxis()\n    plt.title(\"Total Sales by Store (Clothing + Equipment + Accessories)\")\n    plt.xlabel(\"Total Sales\")\n    plt.ylabel(\"Store\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "#4C78A8", "reasoning": "The code uses plt.barh() from the matplotlib library to draw data directly. Because plt.barh() creates horizontal bars representing a categorical variable (Store) and a quantitative variable (Total), it is classified as a Bar chart according to the taxonomy."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"19store_item.csv\")\n\n    categories = [\"Clothing\", \"Equipment\", \"Accessories\"]\n    ax = df.set_index(\"Store\")[categories].plot(kind=\"bar\", figsize=(10, 6))\n\n    ax.set_title(\"Sales by Store and Category\")\n    ax.set_xlabel(\"Store\")\n    ax.set_ylabel(\"Sales\")\n    ax.legend(title=\"Category\", frameon=False)\n    plt.xticks(rotation=25, ha=\"right\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The plot is generated using the pandas DataFrame '.plot()' wrapper with 'kind=\"bar\"'. Because the DataFrame contains multiple quantitative columns ('Clothing', 'Equipment', 'Accessories') indexed by a categorical variable ('Store'), pandas renders these as vertical grouped bars (Grouped column chart)."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19store_item.csv\")\n\n# Prepare data for plotting\ndf = df.set_index(\"Store\")[[\"Clothing\", \"Equipment\", \"Accessories\"]]\n\n# Single chart: stacked bar chart by store\nax = df.plot(kind=\"bar\", stacked=True, figsize=(10, 5), width=0.75)\n\nax.set_title(\"Sales by Category per Store (Stacked)\")\nax.set_xlabel(\"Store\")\nax.set_ylabel(\"Sales\")\nax.legend(title=\"Category\", bbox_to_anchor=(1.02, 1), loc=\"upper left\")\nplt.xticks(rotation=25, ha=\"right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The visualization is generated using the pandas wrapper `df.plot(kind='bar', stacked=True)`. According to the taxonomy, vertical bars are classified as Column charts, and since `stacked=True` is used to represent multiple categories ('Clothing', 'Equipment', 'Accessories') per store, it is a Stacked column chart."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19store_item.csv\")\n\n# Prepare totals for a single chart\ncategories = [\"Clothing\", \"Equipment\", \"Accessories\"]\ntotals = df[categories].sum().reindex(categories)\n\n# Plot\nplt.figure(figsize=(8, 5))\nplt.bar(totals.index, totals.values)\nplt.title(\"Total Sales by Category (All Stores)\")\nplt.xlabel(\"Category\")\nplt.ylabel(\"Sales\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render data as vertical bars, which corresponds to the 'Column chart' category in the provided taxonomy."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19store_item.csv\")\n\n# Ensure consistent ordering and formatting\ncategories = [\"Clothing\", \"Equipment\", \"Accessories\"]\ndf[categories] = df[categories].astype(float)\n\n# Plot: stacked horizontal bars for clear composition per store\nfig, ax = plt.subplots(figsize=(10, 5.5))\ncolors = {\"Clothing\": \"#4C78A8\", \"Equipment\": \"#F58518\", \"Accessories\": \"#54A24B\"}\n\nleft = pd.Series([0] * len(df))\nfor cat in categories:\n    ax.barh(\n        df[\"Store\"],\n        df[cat],\n        left=left,\n        color=colors[cat],\n        edgecolor=\"white\",\n        linewidth=0.8,\n        label=cat,\n    )\n    left += df[cat]\n\n# Labels and styling\nax.set_title(\"Sales by Category per Store (Stacked)\", pad=12)\nax.set_xlabel(\"Sales ($)\")\nax.set_ylabel(\"Store\")\n\n# Add total labels at end of each bar\ntotals = df[categories].sum(axis=1)\nfor i, (store, total) in enumerate(zip(df[\"Store\"], totals)):\n    ax.text(total + totals.max() * 0.01, i, f\"${total:,.0f}\", va=\"center\", ha=\"left\", fontsize=9)\n\nax.legend(title=\"Category\", frameon=False, ncols=3, loc=\"upper right\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's 'ax.barh' function to draw horizontal bars. It creates a stacked layout by iterating through categories and using the 'left' parameter to offset subsequent segments, which fits the definition of a Stacked bar chart."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"19store_item.csv\")\n\n# Prepare\ncategories = [\"Clothing\", \"Equipment\", \"Accessories\"]\nstores = df[\"Store\"].astype(str).tolist()\ny = np.arange(len(stores))\n\n# Plot: horizontal stacked bar chart\nfig, ax = plt.subplots(figsize=(10, 5))\nleft = np.zeros(len(df))\n\ncolors = [\"#2A9D8F\", \"#E9C46A\", \"#F4A261\"]\nfor cat, color in zip(categories, colors):\n    ax.barh(y, df[cat].values, left=left, label=cat, color=color, edgecolor=\"white\", linewidth=0.8)\n    left += df[cat].values\n\n# Labels & formatting\nax.set_yticks(y)\nax.set_yticklabels(stores)\nax.invert_yaxis()  # highest at top\n\nax.set_xlabel(\"Sales ($)\")\nax.set_title(\"Store Sales by Category (Stacked)\")\n\nax.xaxis.set_major_formatter(lambda x, pos: f\"${x:,.0f}\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\n\n# Total annotations\ntotals = df[categories].sum(axis=1).values\nfor i, total in enumerate(totals):\n    ax.text(total + totals.max() * 0.01, i, f\"${total:,.0f}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#333333\")\n\nax.legend(ncols=3, frameon=False, loc=\"upper right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's axes-level function `ax.barh()` directly to render the data. The chart is horizontal and segments are stacked using the 'left' parameter to offset subsequent categories, mapping to a 'Stacked bar chart' according to the taxonomy."}}
{"input_csv_file": "19store_item.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"19store_item.csv\")\n\n# Prepare\ncategories = [\"Clothing\", \"Equipment\", \"Accessories\"]\nstores = df[\"Store\"].tolist()\nvals = df[categories].to_numpy()\n\n# Plot: stacked horizontal bars for clear store comparison + category contribution\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\ny = np.arange(len(stores))\nleft = np.zeros(len(stores))\n\ncolors = {\n    \"Clothing\": \"#1f77b4\",\n    \"Equipment\": \"#ff7f0e\",\n    \"Accessories\": \"#2ca02c\",\n}\n\nfor i, cat in enumerate(categories):\n    ax.barh(\n        y,\n        vals[:, i],\n        left=left,\n        height=0.68,\n        color=colors[cat],\n        edgecolor=\"white\",\n        linewidth=0.8,\n        label=cat,\n    )\n    left += vals[:, i]\n\n# Labels & formatting\nax.set_yticks(y)\nax.set_yticklabels(stores)\nax.invert_yaxis()\n\ntotals = vals.sum(axis=1)\nax.set_xlabel(\"Sales ($)\")\nax.set_title(\"Store Sales by Item Category (Stacked)\")\n\nax.xaxis.grid(True, linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\n\n# Total annotations at bar end\nxmax = totals.max()\nfor yi, total in zip(y, totals):\n    ax.text(\n        total + 0.01 * xmax,\n        yi,\n        f\"${total:,.0f}\",\n        va=\"center\",\n        ha=\"left\",\n        fontsize=9,\n        color=\"#333333\",\n    )\n\nax.legend(ncol=3, loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() function directly to render horizontal bars. It implements a stacked layout by iterating through categories and using the 'left' parameter to offset subsequent segments, which aligns with the taxonomy definition for a Stacked bar chart (horizontal orientation)."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Create a proper time-like ordering for Month and sort\nmonth_order = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\ndf = df.sort_values([\"Year\", \"Month\"]).reset_index(drop=True)\n\n# Create a label for x-axis\ndf[\"Period\"] = df[\"Year\"].astype(str) + \"-\" + df[\"Month\"].astype(str)\n\n# Plot\nplt.figure(figsize=(10, 4.5))\nplt.plot(df[\"Period\"], df[\"Value\"], marker=\"o\", linewidth=2)\nplt.title(\"Value by Year-Month\")\nplt.xlabel(\"Year-Month\")\nplt.ylabel(\"Value\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot command 'plt.plot()' to render the data. The visualization maps a temporal dimension (Year-Month) to a quantitative value using a connected line, which matches the definition of a Line chart."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Ensure month order for plotting\nmonth_order = [\"Jan\", \"Feb\", \"Mar\"]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\ndf = df.sort_values([\"Year\", \"Month\"])\n\n# Plot: one line per year across months\nfig, ax = plt.subplots(figsize=(8, 4.5))\n\nfor year, g in df.groupby(\"Year\"):\n    ax.plot(g[\"Month\"], g[\"Value\"], marker=\"o\", linewidth=2, label=str(year))\n\nax.set_title(\"Value by Month for Each Year\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Value\")\nax.legend(title=\"Year\")\nax.grid(True, linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib function ax.plot() to draw data. The visualization displays temporal data (months) and quantitative values for different categories (years), which fits the taxonomy for a Line chart."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Create a time-like label for easy reading\ndf[\"Period\"] = df[\"Year\"].astype(str) + \"-\" + df[\"Month\"]\n\n# Plot (single chart)\nplt.figure(figsize=(9, 4))\nplt.plot(df[\"Period\"], df[\"Value\"], marker=\"o\", linewidth=2)\nplt.title(\"Value by Month (2000–2002)\")\nplt.xlabel(\"Year-Month\")\nplt.ylabel(\"Value\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The plot is created using plt.plot() directly from the matplotlib.pyplot library, visualizing a sequence of quantitative values over a temporal categorical axis (Year-Month)."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Ensure months are in the intended order\nmonth_order = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\n\n# Create a single chart: grouped bar chart by Year with Month on x-axis\npivot = df.pivot_table(index=\"Month\", columns=\"Year\", values=\"Value\", aggfunc=\"sum\").sort_index()\n\nax = pivot.plot(kind=\"bar\", figsize=(8, 4), width=0.8)\nax.set_title(\"Values by Month and Year\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Value\")\nax.legend(title=\"Year\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization is generated using the pandas DataFrame '.plot()' method with 'kind=\"bar\"'. Since it is plotting a pivot table with multiple columns (Years) against an index (Month) in a vertical orientation, it is classified as a Grouped column chart."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Ensure Month order\nmonth_order = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\n\n# Create a sortable time index\ndf[\"Date\"] = pd.to_datetime(df[\"Year\"].astype(str) + \"-\" + df[\"Month\"].astype(str), format=\"%Y-%b\")\ndf = df.sort_values(\"Date\")\n\n# Plot\nplt.figure(figsize=(9, 4.5))\nplt.plot(df[\"Date\"], df[\"Value\"], marker=\"o\", linewidth=2)\n\nplt.title(\"Value Over Time (Year-Month)\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Value\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.plot() to render the data. The visualization displays quantitative values against a temporal dimension (Date), which classifies it as a Line chart according to the taxonomy."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Ensure month order\nmonth_order = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\n\n# Sort and create a time-like label\ndf = df.sort_values([\"Year\", \"Month\"]).reset_index(drop=True)\ndf[\"Period\"] = df[\"Year\"].astype(str) + \"-\" + df[\"Month\"].astype(str)\n\n# Plot: single line chart\nplt.figure(figsize=(10, 4.5))\nplt.plot(df[\"Period\"], df[\"Value\"], marker=\"o\", linewidth=2)\nplt.title(\"Value by Year-Month\")\nplt.xlabel(\"Year-Month\")\nplt.ylabel(\"Value\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib.pyplot function plt.plot() rather than a seaborn or pandas wrapper. It maps temporal/categorical periods (Year-Month) to quantitative values, fitting the Line chart definition."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"19year_month.csv\")\n\n    # Ensure correct month order\n    month_order = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                   \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n    df[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\n\n    # Create a time-like label for x-axis (Year-Month)\n    df = df.sort_values([\"Year\", \"Month\"])\n    df[\"YearMonth\"] = df[\"Year\"].astype(str) + \"-\" + df[\"Month\"].astype(str)\n\n    plt.figure(figsize=(9, 4.5))\n    plt.plot(df[\"YearMonth\"], df[\"Value\"], marker=\"o\", linewidth=2)\n    plt.title(\"Value by Year-Month\")\n    plt.xlabel(\"Year-Month\")\n    plt.ylabel(\"Value\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.grid(True, linestyle=\"--\", alpha=0.4)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses the direct matplotlib.pyplot function 'plt.plot()' to render data representing quantitative values across a temporal/categorical sequence (Year-Month)."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport calendar\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Map month abbreviations to month numbers and create a sortable date\nmonth_map = {calendar.month_abbr[i]: i for i in range(1, 13)}\ndf[\"MonthNum\"] = df[\"Month\"].map(month_map)\ndf[\"Date\"] = pd.to_datetime(dict(year=df[\"Year\"], month=df[\"MonthNum\"], day=1))\n\n# Sort by date\ndf = df.sort_values(\"Date\")\n\n# Plot single chart\nplt.figure(figsize=(8, 4.5))\nplt.plot(df[\"Date\"], df[\"Value\"], marker=\"o\", linewidth=2)\n\nplt.title(\"Value Over Time (Year-Month)\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Value\")\nplt.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses plt.plot() directly to render a quantitative value against a temporal dimension (Date), which classifies it as a Line chart within the matplotlib library."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Asegurar orden correcto de meses y ordenamiento\nmonth_order = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\ndf = df.sort_values([\"Year\", \"Month\"]).reset_index(drop=True)\n\n# Crear etiqueta temporal (Year-Month) para el eje X\ndf[\"Period\"] = df[\"Year\"].astype(str) + \"-\" + df[\"Month\"].astype(str)\n\n# Graficar\nplt.figure(figsize=(10, 4))\nplt.plot(df[\"Period\"], df[\"Value\"], marker=\"o\", linewidth=2)\nplt.title(\"Value por Mes (Year-Month)\")\nplt.xlabel(\"Periodo\")\nplt.ylabel(\"Value\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib.pyplot function `plt.plot()`. The visualization maps a temporal/categorical dimension (Period) against a quantitative dimension (Value), which fits the definition of a Line chart."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Ensure month order and create a time-like label for plotting\nmonth_order = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\ndf = df.sort_values([\"Year\", \"Month\"])\n\ndf[\"Period\"] = df[\"Year\"].astype(str) + \"-\" + df[\"Month\"].astype(str)\n\n# Plot: single chart\nplt.figure(figsize=(9, 4.5))\nplt.plot(df[\"Period\"], df[\"Value\"], marker=\"o\", linewidth=2)\n\nplt.title(\"Value by Year-Month\")\nplt.xlabel(\"Year-Month\")\nplt.ylabel(\"Value\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.grid(True, axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard pyplot functions (plt.plot) to render the data directly, fitting the matplotlib classification. The visualization represents a temporal sequence (Year-Month) against a quantitative value using connected points, which classifies it as a Line chart."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Ensure month order and create a sortable datetime index\nmonth_order = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\n\nmonth_num = {m: i + 1 for i, m in enumerate(month_order)}\ndf[\"MonthNum\"] = df[\"Month\"].map(month_num).astype(int)\ndf[\"Date\"] = pd.to_datetime(dict(year=df[\"Year\"], month=df[\"MonthNum\"], day=1))\ndf = df.sort_values(\"Date\")\n\n# Plot: single chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 4.5))\n\nax.plot(df[\"Date\"], df[\"Value\"], marker=\"o\", linewidth=2)\n\nax.set_title(\"Value Over Time (Year-Month)\")\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Value\")\n\n# Ticks formatted as YYYY-Mon\nax.set_xticks(df[\"Date\"])\nax.set_xticklabels([d.strftime(\"%Y-%b\") for d in df[\"Date\"]], rotation=45, ha=\"right\")\n\nax.margins(x=0.02)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using ax.plot() directly from the matplotlib library. The visualization maps a temporal dimension (Date) and a quantitative dimension (Value), which identifies it as a Line chart."}}
{"input_csv_file": "19year_month.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"19year_month.csv\")\n\n# Ensure correct month order for sorting\nmonth_order = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n               \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\ndf[\"Month\"] = pd.Categorical(df[\"Month\"], categories=month_order, ordered=True)\n\n# Create a single time-like index (Year-Month) and sort\ndf[\"Period\"] = df[\"Year\"].astype(str) + \"-\" + df[\"Month\"].astype(str)\ndf = df.sort_values([\"Year\", \"Month\"])\n\n# Plot: single line chart across Year-Month\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 4.5))\n\nax.plot(df[\"Period\"], df[\"Value\"], marker=\"o\", linewidth=2, color=\"#1f77b4\")\n\nax.set_title(\"Value by Year-Month\", pad=10)\nax.set_xlabel(\"Year-Month\")\nax.set_ylabel(\"Value\")\n\n# Improve x-axis readability\nax.set_xticks(range(len(df)))\nax.set_xticklabels(df[\"Period\"], rotation=45, ha=\"right\")\n\n# Clean up spines for a crisp look\nfor spine in [\"top\", \"right\"]:\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the ax.plot() method from the matplotlib library. The visualization displays a quantitative variable over a temporal/categorical index (Year-Month), which classifies it as a Line chart."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\n\n# Parse year and clean types\ndf[\"year\"] = pd.to_datetime(df[\"year\"], errors=\"coerce\").dt.year\ndf = df.dropna(subset=[\"year\"])\ndf[\"year\"] = df[\"year\"].astype(int)\n\n# Pivot to wide format for plotting\nwide = df.pivot_table(index=\"year\", columns=\"source\", values=\"net_generation\", aggfunc=\"sum\").sort_index()\n\n# Plot\nplt.figure(figsize=(10, 5.5))\nfor col in wide.columns:\n    plt.plot(wide.index, wide[col], linewidth=2, label=col)\n\nplt.title(\"Iowa Net Electricity Generation by Source (2001–2017)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Net generation\")\nplt.grid(True, alpha=0.3)\nplt.legend(title=\"Source\", frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses the standard 'plt.plot' function from the matplotlib library to draw data points across time (years) for various categories (sources), representing a quantitative value (net_generation)."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\n\n# Prepare time column (use year for clean x-axis)\ndf[\"year\"] = pd.to_datetime(df[\"year\"]).dt.year\n\n# Pivot to wide format for a single multi-line chart\nwide = df.pivot(index=\"year\", columns=\"source\", values=\"net_generation\").sort_index()\n\n# Plot\nplt.figure(figsize=(10, 5))\nfor col in wide.columns:\n    plt.plot(wide.index, wide[col], linewidth=2, label=col)\n\nplt.title(\"Iowa Net Electricity Generation by Source (2001–2017)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Net generation\")\nplt.xticks(wide.index, rotation=45)\nplt.legend(title=\"Source\", frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard matplotlib functions (plt.plot()) to draw the data rather than pandas wrappers or seaborn. The visualization tracks quantitative values over a temporal dimension across categories, defining it as a line chart."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\n\n# Parse year and keep just the year number for clean labels\ndf[\"year\"] = pd.to_datetime(df[\"year\"])\ndf[\"year_num\"] = df[\"year\"].dt.year\n\n# Pivot to wide form: one column per energy source\nwide = df.pivot(index=\"year_num\", columns=\"source\", values=\"net_generation\").sort_index()\n\n# Plot: one clear chart with three lines\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\nfor col in wide.columns:\n    ax.plot(wide.index, wide[col], linewidth=2.5, label=col)\n\nax.set_title(\"Iowa Electricity Net Generation by Source (2001–2017)\")\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Net generation (MWh)\")\nax.yaxis.set_major_formatter(mtick.StrMethodFormatter(\"{x:,.0f}\"))\n\nax.set_xticks(wide.index)\nax.set_xlim(wide.index.min(), wide.index.max())\n\nax.legend(title=\"Source\", frameon=True)\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The plot is generated using the standard matplotlib axes function `ax.plot()` inside a loop to render multiple lines. It visualizes temporal data (years) against quantitative values (net generation) for multiple categories (energy sources)."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\n\n# Parse year and keep just the year number for cleaner axis labels\ndf[\"year\"] = pd.to_datetime(df[\"year\"]).dt.year\n\n# Pivot to wide format for a single multi-line chart\nwide = df.pivot(index=\"year\", columns=\"source\", values=\"net_generation\").sort_index()\n\n# Plot: one chart showing trends over time by source\nplt.figure(figsize=(10, 5))\nfor col in wide.columns:\n    plt.plot(wide.index, wide[col], linewidth=2, label=col)\n\nplt.title(\"Iowa Electricity Net Generation by Source (2001–2017)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Net generation\")\nplt.xticks(wide.index, rotation=45)\nplt.grid(True, alpha=0.25)\nplt.legend(title=\"Source\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly within a loop to render data, classifying it as matplotlib. The chart displays temporal trends over years with categories represented by separate lines."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ncsv_path = \"1iowa-electricity.csv\"\ndf = pd.read_csv(csv_path)\n\n# Parse year and clean\ndf[\"year\"] = pd.to_datetime(df[\"year\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"year\"])\n\n# Pivot to wide format for a single multi-line chart\nwide = df.pivot_table(index=\"year\", columns=\"source\", values=\"net_generation\", aggfunc=\"sum\").sort_index()\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5))\n\nfor col in wide.columns:\n    ax.plot(wide.index, wide[col], linewidth=2, label=col)\n\nax.set_title(\"Iowa Net Electricity Generation by Source (2001–2017)\")\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Net generation\")\nax.xaxis.set_major_locator(mdates.YearLocator(base=2))\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\n\nax.legend(title=\"Source\", frameon=True)\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib axes function `ax.plot()` to plot multiple temporal series across categories ('source'), which fits the 'Line chart' taxonomy. Since matplotlib's direct API is used rather than seaborn or pandas wrappers, the library is classified as matplotlib."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\n\n# Parse year and keep just the year for clean axis labels\ndf[\"year\"] = pd.to_datetime(df[\"year\"]).dt.year\n\n# Pivot for plotting\nwide = df.pivot(index=\"year\", columns=\"source\", values=\"net_generation\").sort_index()\n\n# Plot (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nwide.plot(ax=ax, linewidth=2)\n\nax.set_title(\"Iowa Electricity Net Generation by Source (2001–2017)\")\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Net Generation\")\nax.legend(title=\"Source\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the `.plot()` method on a pandas DataFrame (`wide.plot()`). According to the hierarchy rules, even though matplotlib is used for axes and figure setup, the rendering method determines the library as 'pandas'. The resulting visualization is a line chart as it maps temporal data (year) and multiple categories (source) to quantitative values (net_generation)."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\n\n# Parse year and keep only the year component for clean x-axis labels\ndf[\"year\"] = pd.to_datetime(df[\"year\"])\ndf[\"year_num\"] = df[\"year\"].dt.year\n\n# Pivot to wide format: one column per source\nwide = df.pivot_table(index=\"year_num\", columns=\"source\", values=\"net_generation\", aggfunc=\"sum\").sort_index()\n\n# Plot (single chart)\nplt.figure(figsize=(10, 5.5))\nfor col in wide.columns:\n    plt.plot(wide.index, wide[col], linewidth=2, label=col)\n\nplt.title(\"Iowa Electricity Net Generation by Source (2001–2017)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Net generation\")\nplt.grid(True, alpha=0.25)\nplt.legend(title=\"Source\", frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly within a loop to render the data, which identifies the library as 'matplotlib' rather than 'pandas' or 'seaborn'. The chart displays quantitative values over a temporal dimension (years) for various categories, fitting the 'Line chart' taxonomy."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\n\n# Parse year as datetime and ensure numeric generation\ndf[\"year\"] = pd.to_datetime(df[\"year\"], errors=\"coerce\")\ndf[\"net_generation\"] = pd.to_numeric(df[\"net_generation\"], errors=\"coerce\")\n\n# Pivot to wide format: one line per source\nwide = df.pivot_table(index=\"year\", columns=\"source\", values=\"net_generation\", aggfunc=\"sum\").sort_index()\n\n# Plot: single chart with three lines\nplt.figure(figsize=(10, 5.5))\nax = plt.gca()\n\nwide.plot(ax=ax, linewidth=2)\n\nax.set_title(\"Iowa Electricity Net Generation by Source (2001–2017)\")\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Net generation (GWh)\")\nax.grid(True, which=\"major\", linestyle=\"--\", alpha=0.35)\n\nax.xaxis.set_major_locator(mdates.YearLocator(2))\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\n\nax.legend(title=\"Source\", frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is generated using the 'wide.plot()' method, which is a pandas plotting wrapper. Since the DataFrame index consists of temporal data (years) and multiple columns (sources) representing quantitative values, it produces a line chart by default."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\n\n# Parse year and pivot to wide format for plotting\ndf[\"year\"] = pd.to_datetime(df[\"year\"]).dt.year\nwide = df.pivot(index=\"year\", columns=\"source\", values=\"net_generation\").sort_index()\n\n# Plot (single chart)\nplt.figure(figsize=(10, 5))\nfor col in wide.columns:\n    plt.plot(wide.index, wide[col], linewidth=2, label=col)\n\nplt.title(\"Iowa Electricity Net Generation by Source (2001–2017)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Net generation\")\nplt.grid(True, alpha=0.3)\nplt.legend(title=\"Source\", frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using plt.plot() in a loop directly from the DataFrame columns, rather than using pandas plotting wrappers. The chart maps temporal (year), quantitative (net_generation), and categorical (source) variables to a series of connected points, identifying it as a Line chart."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\ndf[\"year\"] = pd.to_datetime(df[\"year\"]).dt.year\n\n# Pivot to wide format for a single multi-series line chart\nwide = df.pivot_table(index=\"year\", columns=\"source\", values=\"net_generation\", aggfunc=\"sum\").sort_index()\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 6))\n\ncolors = {\n    \"Fossil Fuels\": \"#4C78A8\",\n    \"Nuclear Energy\": \"#F58518\",\n    \"Renewables\": \"#54A24B\",\n}\n\nfor col in [\"Fossil Fuels\", \"Nuclear Energy\", \"Renewables\"]:\n    ax.plot(\n        wide.index,\n        wide[col],\n        linewidth=2.6,\n        marker=\"o\",\n        markersize=4.5,\n        label=col,\n        color=colors.get(col, None),\n    )\n\nax.set_title(\"Iowa Net Electricity Generation by Source (2001–2017)\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Net generation (MWh)\")\n\nax.yaxis.set_major_formatter(mtick.StrMethodFormatter(\"{x:,.0f}\"))\nax.set_xlim(wide.index.min(), wide.index.max())\nax.set_xticks(wide.index)\nax.tick_params(axis=\"x\", labelrotation=45)\n\nleg = ax.legend(title=\"Source\", frameon=True, loc=\"upper left\")\nleg.get_frame().set_alpha(0.95)\n\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard matplotlib axes plotting functions (ax.plot) to render data directly from a pivoted DataFrame. Following the hierarchy rules, since it does not use seaborn functions or pandas .plot() wrappers, it is classified as matplotlib."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\n\n# Parse year and pivot to wide format\ndf[\"year\"] = pd.to_datetime(df[\"year\"]).dt.year\nwide = df.pivot_table(index=\"year\", columns=\"source\", values=\"net_generation\", aggfunc=\"sum\").sort_index()\n\n# Ensure consistent column order (if present)\norder = [\"Fossil Fuels\", \"Nuclear Energy\", \"Renewables\"]\ncols = [c for c in order if c in wide.columns] + [c for c in wide.columns if c not in order]\nwide = wide[cols]\n\n# Plot: stacked area chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 6.2))\n\ncolors = {\n    \"Fossil Fuels\": \"#4C78A8\",\n    \"Nuclear Energy\": \"#F58518\",\n    \"Renewables\": \"#54A24B\",\n}\nplot_colors = [colors.get(c, None) for c in wide.columns]\n\nax.stackplot(wide.index, [wide[c].values for c in wide.columns], labels=wide.columns, colors=plot_colors, alpha=0.9)\n\nax.set_title(\"Iowa Net Electricity Generation by Source (2001–2017)\", pad=10)\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Net generation (MWh)\")\n\nax.xaxis.set_major_locator(plt.MaxNLocator(integer=True))\nax.yaxis.set_major_formatter(mtick.StrMethodFormatter(\"{x:,.0f}\"))\n\nax.legend(title=\"Source\", ncol=3, frameon=True, loc=\"upper left\", bbox_to_anchor=(0.01, 1.02))\nax.margins(x=0)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Area chart", "color_palette": null, "reasoning": "The plot is rendered using the ax.stackplot() function from matplotlib directly. According to the taxonomy, an Area chart uses temporal, categorical, and quantitative dimensions, which matches the use of years, energy sources, and net generation values here."}}
{"input_csv_file": "1iowa-electricity.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ndf = pd.read_csv(\"1iowa-electricity.csv\")\ndf[\"year\"] = pd.to_datetime(df[\"year\"])\n\n# Prepare for plotting (one line per source)\npivot = (\n    df.pivot_table(index=\"year\", columns=\"source\", values=\"net_generation\", aggfunc=\"sum\")\n    .sort_index()\n)\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 6.2))\n\ncolors = {\n    \"Fossil Fuels\": \"#6c757d\",\n    \"Nuclear Energy\": \"#3b5bdb\",\n    \"Renewables\": \"#2f9e44\",\n}\n\nfor col in pivot.columns:\n    ax.plot(\n        pivot.index,\n        pivot[col],\n        label=col,\n        linewidth=2.6,\n        color=colors.get(col, None),\n    )\n\nax.set_title(\"Iowa Net Electricity Generation by Source (2001–2017)\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Net generation (MWh)\")\n\nax.yaxis.set_major_formatter(mtick.StrMethodFormatter(\"{x:,.0f}\"))\nax.legend(title=\"Source\", frameon=True, loc=\"upper left\")\n\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard Matplotlib axes functions (ax.plot) within a loop to draw lines for each category. It visualizes temporal data (years) against quantitative values (net generation), fitting the definition of a Line chart."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1simple_timeseries.csv\")\n\n# Plot\nplt.figure(figsize=(9, 5))\nplt.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2, label=\"Category A\")\nplt.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2, label=\"Category B\")\nplt.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2, label=\"Category C\")\n\n# Styling\nplt.title(\"Simple Time Series by Category (2018–2023)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Value\")\nplt.xticks(df[\"year\"])\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard matplotlib.pyplot functions (plt.plot) to render temporal data across multiple categories, identifying it as a Line chart."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1simple_timeseries.csv\")\n\n# Plot a single chart: multi-line time series by category\nplt.figure(figsize=(9, 5))\nplt.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2, label=\"Category A\")\nplt.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2, label=\"Category B\")\nplt.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2, label=\"Category C\")\n\nplt.title(\"Category Values Over Time (2018–2023)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Value\")\nplt.xticks(df[\"year\"])\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib.pyplot.plot() function directly. It displays temporal data (years) on the x-axis and quantitative values on the y-axis for multiple categories, fitting the definition of a Line chart."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1simple_timeseries.csv\")\n\n# Plot\nplt.figure(figsize=(9, 5))\nplt.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2, label=\"Category A\")\nplt.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2, label=\"Category B\")\nplt.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2, label=\"Category C\")\n\n# Formatting\nplt.title(\"Simple Time Series by Category (2018–2023)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Value\")\nplt.xticks(df[\"year\"])\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot.plot function to draw data points connected by lines, representing temporal trends across multiple categories. Since the plotting logic is handled by plt.plot() rather than a pandas or seaborn wrapper, the library is classified as matplotlib."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1simple_timeseries.csv\")\n\n# Create a single chart: multi-line time series\nplt.figure(figsize=(9, 5))\nplt.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2, label=\"Category A\")\nplt.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2, label=\"Category B\")\nplt.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2, label=\"Category C\")\n\nplt.title(\"Category Values Over Time (2018–2023)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Value\")\nplt.xticks(df[\"year\"])\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly from the matplotlib library to render multiple data series. The chart maps temporal/ordinal data (years) to quantitative values across multiple categories, which aligns with the Line chart definition."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1simple_timeseries.csv\")\n\n# Plot\nplt.figure(figsize=(9, 5))\nplt.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2, label=\"Category A\")\nplt.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2, label=\"Category B\")\nplt.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2, label=\"Category C\")\n\n# Styling\nplt.title(\"Simple Time Series by Category (2018–2023)\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Value\")\nplt.xticks(df[\"year\"])\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "Used plt.plot() directly to draw quantitative values over a temporal dimension (years) for multiple categories, which identifies it as a matplotlib Line chart."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"1simple_timeseries.csv\")\n\n    plt.figure(figsize=(9, 5))\n    plt.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2, label=\"Category A\")\n    plt.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2, label=\"Category B\")\n    plt.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2, label=\"Category C\")\n\n    plt.title(\"Time Series by Category (2018–2023)\")\n    plt.xlabel(\"Year\")\n    plt.ylabel(\"Value\")\n    plt.xticks(df[\"year\"])\n    plt.grid(True, linestyle=\"--\", alpha=0.4)\n    plt.legend()\n    plt.tight_layout()\n\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard plt.plot() calls from the matplotlib.pyplot library to render lines connecting temporal data points (year) with quantitative values across three categories. It does not use pandas' .plot() wrapper or seaborn."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"1simple_timeseries.csv\")\n\n    plt.figure(figsize=(9, 5))\n    plt.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2, label=\"category_a\")\n    plt.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2, label=\"category_b\")\n    plt.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2, label=\"category_c\")\n\n    plt.title(\"Simple Time Series (2018–2023)\")\n    plt.xlabel(\"Year\")\n    plt.ylabel(\"Value\")\n    plt.xticks(df[\"year\"])\n    plt.grid(True, alpha=0.3)\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard plt.plot() functions from the matplotlib library to render a temporal dataset across three categories, classifying it as a Line chart."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"1simple_timeseries.csv\")\n\n    plt.figure(figsize=(9, 5))\n    plt.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2, label=\"Category A\")\n    plt.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2, label=\"Category B\")\n    plt.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2, label=\"Category C\")\n\n    plt.title(\"Simple Time Series by Category (2018–2023)\")\n    plt.xlabel(\"Year\")\n    plt.ylabel(\"Value\")\n    plt.xticks(df[\"year\"])\n    plt.grid(True, linestyle=\"--\", alpha=0.4)\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly to render the data, which falls under the matplotlib classification. The visualization displays categorical variables (Category A, B, C) over a temporal variable (year), fitting the definition of a Line chart."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"1simple_timeseries.csv\")\n\n# Crear gráfico (una sola figura)\nplt.figure(figsize=(9, 5))\nplt.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2, label=\"Category A\")\nplt.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2, label=\"Category B\")\nplt.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2, label=\"Category C\")\n\nplt.title(\"Evolución por categoría (2018–2023)\")\nplt.xlabel(\"Año\")\nplt.ylabel(\"Valor\")\nplt.xticks(df[\"year\"])\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses plt.plot() to display quantitative values across temporal (years) and categorical dimensions. Following the hierarchy rules, since data is rendered directly via pyplot and not through Seaborn or Pandas plot wrappers, the library is classified as matplotlib."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1simple_timeseries.csv\")\n\n# Ensure proper ordering\ndf = df.sort_values(\"year\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5))\n\nax.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2.5, label=\"Category A\")\nax.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2.5, label=\"Category B\")\nax.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2.5, label=\"Category C\")\n\nax.set_title(\"Category Trends Over Time (2018–2023)\", pad=12)\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Value\")\n\nax.set_xticks(df[\"year\"])\nax.margins(x=0.03)\n\nax.legend(frameon=True, title=\"Series\", loc=\"upper left\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib axes function ax.plot() to render quantitative values against a temporal variable (year) for multiple categories. It does not use seaborn functions or pandas .plot() wrappers for rendering the data."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1simple_timeseries.csv\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5))\n\nax.plot(df[\"year\"], df[\"category_a\"], marker=\"o\", linewidth=2.5, label=\"Category A\")\nax.plot(df[\"year\"], df[\"category_b\"], marker=\"o\", linewidth=2.5, label=\"Category B\")\nax.plot(df[\"year\"], df[\"category_c\"], marker=\"o\", linewidth=2.5, label=\"Category C\")\n\nax.set_title(\"Category Trends Over Time (2018–2023)\", pad=12)\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Value\")\n\nax.set_xticks(df[\"year\"])\nax.legend(frameon=True, title=\"Series\", loc=\"upper left\")\n\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses standard matplotlib axes methods (ax.plot) to render the data directly, fitting the 'matplotlib' classification priority. It visualizes quantitative categories over a temporal dimension (year), which aligns with the 'Line chart' taxonomy."}}
{"input_csv_file": "1simple_timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1simple_timeseries.csv\")\n\n# Prepare\nx = df[\"year\"]\nseries = {\n    \"Category A\": df[\"category_a\"],\n    \"Category B\": df[\"category_b\"],\n    \"Category C\": df[\"category_c\"],\n}\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5))\n\ncolors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\"]\nfor (label, y), c in zip(series.items(), colors):\n    ax.plot(x, y, marker=\"o\", linewidth=2.5, markersize=6, label=label, color=c)\n\n# Formatting\nax.set_title(\"Category Trends Over Time (2018–2023)\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Value\")\nax.set_xticks(x)\n\nax.legend(frameon=False, ncols=3, loc=\"upper left\")\nax.margins(x=0.03)\n\n# Subtle end labels for quick reading\nfor (label, y), c in zip(series.items(), colors):\n    ax.annotate(\n        f\"{int(y.iloc[-1])}\",\n        xy=(x.iloc[-1], y.iloc[-1]),\n        xytext=(8, 0),\n        textcoords=\"offset points\",\n        va=\"center\",\n        fontsize=10,\n        color=c,\n        weight=\"bold\",\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard Matplotlib Axes API (ax.plot) to render the data. It visualizes quantitative values across a temporal dimension (year) for different categories, which fits the definition of a line chart."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1timeseries.csv\")\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"])\ndf = df.sort_values(\"Date\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5))\n\nvalue_cols = [c for c in df.columns if c != \"Date\"]\nfor col in value_cols:\n    ax.plot(df[\"Date\"], df[col], linewidth=2, label=col)\n\nax.set_title(\"Time Series from 1timeseries.csv\")\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Value\")\nax.legend(ncol=4, frameon=True, fontsize=9)\nfig.autofmt_xdate()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using matplotlib's 'ax.plot()' method in a loop. Since the x-axis consists of temporal data (Dates) and the y-axis contains quantitative values, it is classified as a line chart. Although a seaborn style is used for aesthetics, the rendering library is matplotlib."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1timeseries.csv\")\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"])\ndf = df.sort_values(\"Date\")\n\n# Single chart: time series lines for A–G\nplt.figure(figsize=(10, 5))\nfor col in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]:\n    plt.plot(df[\"Date\"], df[col], marker=\"o\", linewidth=1.5, label=col)\n\nplt.title(\"Time Series for Columns A–G\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Value\")\nplt.grid(True, alpha=0.3)\nplt.legend(ncol=4, frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses the standard 'plt.plot()' function from the matplotlib library. The data mapping involves a temporal dimension (Date), categorical series (A-G), and quantitative values, which aligns with the taxonomy definition for a Line chart."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1timeseries.csv\")\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"])\ndf = df.sort_values(\"Date\")\n\n# Single, clear chart: all series over time\nplt.figure(figsize=(10, 5))\nfor col in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]:\n    plt.plot(df[\"Date\"], df[col], marker=\"o\", linewidth=1.8, label=col)\n\nplt.title(\"Time Series (A–G) from 1timeseries.csv\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Value\")\nplt.grid(True, alpha=0.3)\nplt.legend(ncol=4, frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib `plt.plot()` function to render quantitative values over a temporal x-axis ('Date'). No high-level pandas or seaborn plotting wrappers were used for data rendering."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1timeseries.csv\")\n\n# Parse dates and sort\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"])\ndf = df.sort_values(\"Date\")\n\n# Plot\nplt.figure(figsize=(10, 5))\nplt.plot(df[\"Date\"], df[\"A\"], marker=\"o\", linewidth=2, label=\"A\")\n\nplt.title(\"Time Series of A\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Value\")\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly to render the data points connected by lines. Since the x-axis contains dates and the y-axis contains quantitative values, it fits the definition of a Line chart."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1timeseries.csv\")\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"])\ndf = df.sort_values(\"Date\")\n\n# Plot all series on one chart\nplt.figure(figsize=(10, 5))\nfor col in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]:\n    plt.plot(df[\"Date\"], df[col], marker=\"o\", linewidth=1.5, label=col)\n\nplt.title(\"Time Series from 1timeseries.csv\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Value\")\nplt.grid(True, alpha=0.3)\nplt.legend(ncol=4, frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly for data rendering, making the library matplotlib. It visualizes quantitative variables against a temporal dimension (Date) for multiple categories (A-G), which fits the taxonomy for a line chart."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"1timeseries.csv\")\n    df[\"Date\"] = pd.to_datetime(df[\"Date\"])\n    df = df.sort_values(\"Date\").set_index(\"Date\")\n\n    ax = df.plot(figsize=(10, 5), linewidth=2)\n    ax.set_title(\"Time Series (A-G)\")\n    ax.set_xlabel(\"Date\")\n    ax.set_ylabel(\"Value\")\n    ax.grid(True, linestyle=\"--\", alpha=0.4)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is generated using the pandas method `df.plot()`, which defaults to a line chart when plotting temporal data (Date index) against quantitative values."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"1timeseries.csv\")\n    df[\"Date\"] = pd.to_datetime(df[\"Date\"])\n    df = df.sort_values(\"Date\")\n\n    cols = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]\n\n    plt.figure(figsize=(10, 5))\n    for c in cols:\n        plt.plot(df[\"Date\"], df[c], marker=\"o\", linewidth=1.6, label=c)\n\n    plt.title(\"Time Series (A–G) from 1timeseries.csv\")\n    plt.xlabel(\"Date\")\n    plt.ylabel(\"Value\")\n    plt.grid(True, linestyle=\"--\", alpha=0.35)\n    plt.legend(ncol=4, frameon=False)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the plt.plot() function directly from the matplotlib.pyplot library to render data points over a temporal dimension (Date)."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"1timeseries.csv\")\n    df[\"Date\"] = pd.to_datetime(df[\"Date\"])\n    df = df.sort_values(\"Date\")\n\n    plt.style.use(\"seaborn-v0_8-whitegrid\")\n    fig, ax = plt.subplots(figsize=(10, 5))\n\n    series_cols = [c for c in df.columns if c != \"Date\"]\n    for col in series_cols:\n        ax.plot(df[\"Date\"], df[col], marker=\"o\", linewidth=1.8, label=col)\n\n    ax.set_title(\"Time Series (A–G)\")\n    ax.set_xlabel(\"Date\")\n    ax.set_ylabel(\"Value\")\n    ax.legend(ncol=4, frameon=True, fontsize=9)\n    fig.autofmt_xdate()\n    fig.tight_layout()\n\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses 'ax.plot()' from matplotlib to render the data. The chart visualizes temporal data ('Date') against quantitative values ('df[col]') across multiple categories (series_cols), which corresponds to the definition of a Line chart."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"1timeseries.csv\")\n    df[\"Date\"] = pd.to_datetime(df[\"Date\"])\n    df = df.sort_values(\"Date\").set_index(\"Date\")\n\n    plt.figure(figsize=(10, 5))\n    for col in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]:\n        plt.plot(df.index, df[col], marker=\"o\", linewidth=1.5, label=col)\n\n    plt.title(\"Series temporales (A–G) desde 1timeseries.csv\")\n    plt.xlabel(\"Fecha\")\n    plt.ylabel(\"Valor\")\n    plt.grid(True, alpha=0.3)\n    plt.legend(ncol=4, frameon=False)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the plt.plot() function from matplotlib to visualize quantitative variables over a temporal (Date) index, which corresponds to the 'Line chart' taxonomy definition."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"1timeseries.csv\")\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"])\ndf = df.sort_values(\"Date\").set_index(\"Date\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 5.5), dpi=120)\n\ncolors = plt.cm.tab10.colors\nfor i, col in enumerate(df.columns):\n    ax.plot(\n        df.index, df[col],\n        label=col,\n        linewidth=2.0 if col == \"B\" else 1.4,\n        alpha=0.95 if col == \"B\" else 0.85,\n        color=colors[i % len(colors)]\n    )\n\n# Formatting\nax.set_title(\"Time Series (A–G) — March–April 2008\", pad=10)\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Value\")\n\nax.xaxis.set_major_locator(mdates.DayLocator(interval=2))\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y-%m-%d\"))\nplt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\")\n\nax.legend(title=\"Series\", ncols=4, frameon=True, loc=\"upper center\", bbox_to_anchor=(0.5, 1.18))\nax.margins(x=0.01)\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": "tab10", "reasoning": "The code uses the standard Matplotlib axes method `ax.plot()` to render data rather than seaborn or pandas wrappers. It visualizes temporal data (dates) vs quantitative data for multiple series, fitting the definition of a Line chart. The palette 'tab10' is explicitly referenced via `plt.cm.tab10`."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"1timeseries.csv\")\ndf[\"Date\"] = pd.to_datetime(df[\"Date\"])\ndf = df.sort_values(\"Date\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6))\n\nfor col in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]:\n    ax.plot(df[\"Date\"], df[col], linewidth=2, marker=\"o\", markersize=4, label=col)\n\nax.set_title(\"Time Series (A–G) from 1timeseries.csv\", pad=12, fontsize=14)\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Value\")\n\nax.legend(\n    title=\"Series\",\n    ncols=7,\n    loc=\"upper center\",\n    bbox_to_anchor=(0.5, 1.14),\n    frameon=False,\n)\n\nfig.autofmt_xdate(rotation=45)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The plot is created using the ax.plot() function from matplotlib. It visualizes temporal data (Date) on the X-axis, quantitative values on the Y-axis, and multiple categories (A-G) represented by different lines, fitting the definition of a Line chart."}}
{"input_csv_file": "1timeseries.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"1timeseries.csv\", parse_dates=[\"Date\"])\ndf = df.sort_values(\"Date\")\n\n# Plot: multi-series time line chart\ncols = [c for c in df.columns if c != \"Date\"]\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6.2), dpi=130)\n\nfor c in cols:\n    ax.plot(df[\"Date\"], df[c], linewidth=2, label=c)\n\nax.set_title(\"Time Series (A–G) from 1timeseries.csv\", pad=10, fontsize=14, weight=\"semibold\")\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Value\")\n\n# Date formatting\nax.xaxis.set_major_locator(mdates.AutoDateLocator(minticks=5, maxticks=8))\nax.xaxis.set_major_formatter(mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\nfig.autofmt_xdate()\n\n# Legend\nax.legend(ncols=4, frameon=True, framealpha=0.9, title=\"Series\", loc=\"upper left\")\n\n# Clean spines\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the matplotlib `ax.plot()` function in a loop to visualize temporal data (dates) against quantitative values across multiple categories (columns)."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20iris.csv\")\n\n    fig, ax = plt.subplots(figsize=(8, 6))\n\n    for species, g in df.groupby(\"species\"):\n        ax.scatter(\n            g[\"petal_length\"],\n            g[\"petal_width\"],\n            s=45,\n            alpha=0.85,\n            edgecolors=\"white\",\n            linewidths=0.6,\n            label=species,\n        )\n\n    ax.set_title(\"Iris Petal Dimensions by Species\")\n    ax.set_xlabel(\"Petal length (cm)\")\n    ax.set_ylabel(\"Petal width (cm)\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n    ax.legend(title=\"Species\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization uses the matplotlib Axes method `ax.scatter()` to plot two quantitative dimensions (petal length and petal width) from the Iris dataset, making it a Scatterplot."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20iris.csv\")\n\n# Summarize: average petal length by species (simple comparison chart)\nsummary = (\n    df.groupby(\"species\", as_index=False)[\"petal_length\"]\n      .mean()\n      .sort_values(\"petal_length\")\n)\n\n# Plot: single bar chart\nplt.figure(figsize=(7, 4.5))\nplt.bar(summary[\"species\"], summary[\"petal_length\"], color=[\"#4C78A8\", \"#F58518\", \"#54A24B\"])\n\nplt.title(\"Average Petal Length by Iris Species\")\nplt.xlabel(\"Species\")\nplt.ylabel(\"Average petal length (cm)\")\nplt.ylim(0, summary[\"petal_length\"].max() * 1.15)\n\n# Add value labels\nfor i, v in enumerate(summary[\"petal_length\"]):\n    plt.text(i, v, f\"{v:.2f}\", ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard pyplot function plt.bar() to render the data, and since the bars are vertical (categorical values on the x-axis), it is classified as a Column chart."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20iris.csv\")\n\n# Prepare summary: mean petal length by species\nsummary = (\n    df.groupby(\"species\", as_index=False)[\"petal_length\"]\n      .mean()\n      .sort_values(\"petal_length\")\n)\n\n# Single chart: bar chart\nplt.figure(figsize=(7, 4.5))\nplt.bar(summary[\"species\"], summary[\"petal_length\"], color=[\"#4C78A8\", \"#F58518\", \"#54A24B\"])\nplt.title(\"Average Petal Length by Species (Iris)\")\nplt.xlabel(\"Species\")\nplt.ylabel(\"Mean Petal Length\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses the standard matplotlib.pyplot function plt.bar() to create vertical bars representing the mean petal length across species, which matches the definition for a Column chart."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20iris.csv\")\n\n# Simple, \"read the data\" level chart: average petal length by species\nsummary = (\n    df.groupby(\"species\", as_index=False)[\"petal_length\"]\n    .mean()\n    .sort_values(\"petal_length\")\n)\n\n# Plot\nplt.figure(figsize=(8, 5))\nplt.bar(summary[\"species\"], summary[\"petal_length\"], color=[\"#4C78A8\", \"#F58518\", \"#54A24B\"])\n\nplt.title(\"Average Petal Length by Species (Iris Dataset)\")\nplt.xlabel(\"Species\")\nplt.ylabel(\"Average Petal Length (cm)\")\nplt.ylim(0, summary[\"petal_length\"].max() * 1.15)\n\n# Value labels\nfor i, v in enumerate(summary[\"petal_length\"]):\n    plt.text(i, v + 0.05, f\"{v:.2f}\", ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard 'plt.bar()' function from the matplotlib library to render vertical bars based on categorical and quantitative variables. Since the bars are vertical and rendered directly via pyplot rather than a pandas wrapper or seaborn, it is classified as a Column chart within matplotlib."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20iris.csv\")\n\n# Single chart: Sepal length vs Petal length, colored by species\nfig, ax = plt.subplots(figsize=(8, 6))\n\nspecies_order = sorted(df[\"species\"].unique())\ncolors = {\"setosa\": \"#1f77b4\", \"versicolor\": \"#ff7f0e\", \"virginica\": \"#2ca02c\"}\n\nfor sp in species_order:\n    sub = df[df[\"species\"] == sp]\n    ax.scatter(\n        sub[\"sepal_length\"],\n        sub[\"petal_length\"],\n        s=45,\n        alpha=0.8,\n        label=sp,\n        color=colors.get(sp, None),\n        edgecolor=\"white\",\n        linewidth=0.6,\n    )\n\nax.set_title(\"Iris: Sepal Length vs Petal Length (by Species)\")\nax.set_xlabel(\"Sepal length (cm)\")\nax.set_ylabel(\"Petal length (cm)\")\nax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\nax.legend(title=\"species\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses ax.scatter() from the matplotlib library to draw data points. It plots two quantitative variables (sepal_length and petal_length), which corresponds to a scatterplot.", "is_valid": true}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20iris.csv\")\n\n    fig, ax = plt.subplots(figsize=(8, 6))\n\n    colors = {\n        \"setosa\": \"#1f77b4\",\n        \"versicolor\": \"#ff7f0e\",\n        \"virginica\": \"#2ca02c\",\n    }\n\n    for sp, g in df.groupby(\"species\"):\n        ax.scatter(\n            g[\"petal_length\"],\n            g[\"petal_width\"],\n            s=35,\n            alpha=0.85,\n            c=colors.get(sp, None),\n            label=sp,\n            edgecolors=\"white\",\n            linewidths=0.4,\n        )\n\n    ax.set_title(\"Iris: Petal Length vs Petal Width (by Species)\")\n    ax.set_xlabel(\"petal_length\")\n    ax.set_ylabel(\"petal_width\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n    ax.legend(title=\"species\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using the standard Matplotlib axes function `ax.scatter()` rather than a pandas or seaborn wrapper. Since it maps two quantitative variables (petal_length and petal_width) to the X and Y axes, it is classified as a scatterplot."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20iris.csv\")\n\n    fig, ax = plt.subplots(figsize=(8, 6))\n\n    for species, g in df.groupby(\"species\"):\n        ax.scatter(\n            g[\"petal_length\"],\n            g[\"petal_width\"],\n            s=45,\n            alpha=0.75,\n            edgecolors=\"white\",\n            linewidths=0.6,\n            label=species,\n        )\n\n    ax.set_title(\"Iris: Petal Length vs Petal Width (by Species)\")\n    ax.set_xlabel(\"petal_length\")\n    ax.set_ylabel(\"petal_width\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.35)\n    ax.legend(title=\"species\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses ax.scatter() directly from the matplotlib library to render two quantitative variables (petal_length and petal_width)."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20iris.csv\")\n\n    fig, ax = plt.subplots(figsize=(8, 6))\n\n    for sp, g in df.groupby(\"species\"):\n        ax.scatter(\n            g[\"petal_length\"],\n            g[\"petal_width\"],\n            s=45,\n            alpha=0.8,\n            edgecolors=\"white\",\n            linewidths=0.6,\n            label=sp,\n        )\n\n    ax.set_title(\"Iris: Petal Length vs Petal Width (Colored by Species)\")\n    ax.set_xlabel(\"petal_length\")\n    ax.set_ylabel(\"petal_width\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.4)\n    ax.legend(title=\"species\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the standard matplotlib axis method 'ax.scatter()' to render the data points for two quantitative dimensions (petal_length and petal_width)."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20iris.csv\")\n\n    plt.figure(figsize=(8, 6))\n    for species, g in df.groupby(\"species\"):\n        plt.scatter(\n            g[\"petal_length\"],\n            g[\"petal_width\"],\n            s=45,\n            alpha=0.85,\n            edgecolors=\"white\",\n            linewidths=0.6,\n            label=species,\n        )\n\n    plt.title(\"Iris: Petal Length vs Petal Width (20iris.csv)\")\n    plt.xlabel(\"petal_length\")\n    plt.ylabel(\"petal_width\")\n    plt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n    plt.legend(title=\"species\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses plt.scatter() directly to render the data points for each group, which falls under the matplotlib library classification. The chart plots two quantitative variables (petal_length and petal_width), classifying it as a Scatterplot."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20iris.csv\")\n\n    species_order = [\"setosa\", \"versicolor\", \"virginica\"]\n    palette = {\"setosa\": \"#1f77b4\", \"versicolor\": \"#ff7f0e\", \"virginica\": \"#2ca02c\"}\n\n    fig, ax = plt.subplots(figsize=(9, 6))\n\n    # Single chart: scatter of petal_length vs petal_width, colored by species\n    for sp in species_order:\n        sub = df[df[\"species\"] == sp]\n        ax.scatter(\n            sub[\"petal_length\"],\n            sub[\"petal_width\"],\n            s=55,\n            alpha=0.85,\n            c=palette.get(sp, \"#333333\"),\n            edgecolors=\"white\",\n            linewidths=0.6,\n            label=f\"{sp} (n={len(sub)})\",\n        )\n\n    ax.set_title(\"Iris Petal Morphology by Species (20iris.csv)\")\n    ax.set_xlabel(\"Petal length (cm)\")\n    ax.set_ylabel(\"Petal width (cm)\")\n\n    ax.grid(True, which=\"major\", linestyle=\"-\", linewidth=0.6, alpha=0.22)\n    ax.set_axisbelow(True)\n\n    ax.legend(title=\"Species\", frameon=True, facecolor=\"white\", edgecolor=\"#dddddd\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The plot is created using the standard matplotlib axes method `ax.scatter()` to visualize the relationship between two quantitative variables (petal_length and petal_width), which corresponds to the Scatterplot classification."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"20iris.csv\")\n\n# Style\nsns.set_theme(style=\"whitegrid\")\npalette = {\"setosa\": \"#1b9e77\", \"versicolor\": \"#d95f02\", \"virginica\": \"#7570b3\"}\n\n# Figure\nfig, ax = plt.subplots(figsize=(9.5, 6.2), dpi=140)\n\n# Scatter: petal_length vs petal_width, colored by species\nsns.scatterplot(\n    data=df,\n    x=\"petal_length\",\n    y=\"petal_width\",\n    hue=\"species\",\n    palette=palette,\n    s=55,\n    edgecolor=\"white\",\n    linewidth=0.7,\n    alpha=0.92,\n    ax=ax\n)\n\n# Labels & title\nax.set_title(\"Iris Petal Dimensions by Species (20iris.csv)\", pad=12, fontsize=14, weight=\"semibold\")\nax.set_xlabel(\"Petal length (cm)\")\nax.set_ylabel(\"Petal width (cm)\")\n\n# Subtle refinements\nax.grid(True, which=\"major\", color=\"#d9d9d9\", linewidth=0.8, alpha=0.7)\nax.set_axisbelow(True)\nfor spine in (\"top\", \"right\"):\n    ax.spines[spine].set_visible(False)\n\n# Legend styling\nleg = ax.legend(title=\"Species\", frameon=True, borderpad=0.7, labelspacing=0.4, handletextpad=0.6)\nleg.get_frame().set_edgecolor(\"#cccccc\")\nleg.get_frame().set_linewidth(0.8)\nleg.get_frame().set_alpha(0.95)\n\n# Tight layout and show\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The plot is generated using the `sns.scatterplot` function from the seaborn library. It visualizes the relationship between two quantitative variables ('petal_length' and 'petal_width'), fitting the definition of a scatterplot."}}
{"input_csv_file": "20iris.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"20iris.csv\")\n\n# Style\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\n\n# Single chart: Petal Length vs Petal Width, colored by species, with confidence ellipses via KDE contours\nfig, ax = plt.subplots(figsize=(10, 7))\n\npalette = {\n    \"setosa\": \"#1b9e77\",\n    \"versicolor\": \"#d95f02\",\n    \"virginica\": \"#7570b3\",\n}\n\n# Scatter\nsns.scatterplot(\n    data=df,\n    x=\"petal_length\",\n    y=\"petal_width\",\n    hue=\"species\",\n    palette=palette,\n    s=70,\n    edgecolor=\"white\",\n    linewidth=0.7,\n    alpha=0.9,\n    ax=ax,\n)\n\n# Density contours per species (adds separation structure without extra panels)\nfor sp, color in palette.items():\n    sub = df[df[\"species\"] == sp]\n    if len(sub) >= 10:\n        sns.kdeplot(\n            data=sub,\n            x=\"petal_length\",\n            y=\"petal_width\",\n            levels=3,\n            thresh=0.15,\n            fill=False,\n            color=color,\n            linewidths=2.0,\n            ax=ax,\n        )\n\n# Labels and formatting\nax.set_title(\"Iris (20iris.csv): Petal Dimensions by Species\", pad=12)\nax.set_xlabel(\"Petal length (cm)\")\nax.set_ylabel(\"Petal width (cm)\")\n\nax.legend(\n    title=\"Species\",\n    frameon=True,\n    facecolor=\"white\",\n    edgecolor=\"#dddddd\",\n    loc=\"upper left\",\n)\n\nsns.despine(ax=ax, left=False, bottom=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using seaborn's sns.scatterplot() and sns.kdeplot() functions. A custom dictionary mapping was used for colors instead of a named palette."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20tips.csv\")\n\n# Aggregate: average tip percentage by day\ndf[\"tip_pct\"] = (df[\"tip\"] / df[\"total_bill\"]) * 100\norder = [\"Thur\", \"Fri\", \"Sat\", \"Sun\"]\navg_tip_pct = df.groupby(\"day\")[\"tip_pct\"].mean().reindex(order).dropna()\n\n# Plot: single chart\nplt.figure(figsize=(8, 4.8))\nbars = plt.bar(avg_tip_pct.index, avg_tip_pct.values, color=\"#4C78A8\")\n\nplt.title(\"Average Tip Percentage by Day\")\nplt.xlabel(\"Day\")\nplt.ylabel(\"Average tip (% of total bill)\")\nplt.ylim(0, max(avg_tip_pct.values) * 1.25)\n\n# Label bars\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h, f\"{h:.1f}%\", ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using plt.bar(), which generates vertical bars. According to the hierarchy rules, since the data is rendered using standard pyplot functions rather than Seaborn or Pandas wrappers, the library is matplotlib."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20tips.csv\")\n\n# Summarize: average tip by day\nday_order = [\"Thur\", \"Fri\", \"Sat\", \"Sun\"]\navg_tip_by_day = (\n    df.groupby(\"day\", as_index=False)[\"tip\"]\n      .mean()\n      .rename(columns={\"tip\": \"avg_tip\"})\n)\navg_tip_by_day[\"day\"] = pd.Categorical(avg_tip_by_day[\"day\"], categories=day_order, ordered=True)\navg_tip_by_day = avg_tip_by_day.sort_values(\"day\")\n\n# Plot: single chart\nplt.figure(figsize=(7.5, 4.5))\nplt.bar(avg_tip_by_day[\"day\"], avg_tip_by_day[\"avg_tip\"], color=\"#4C78A8\")\nplt.title(\"Average Tip by Day\")\nplt.xlabel(\"Day\")\nplt.ylabel(\"Average tip ($)\")\nplt.ylim(0, max(avg_tip_by_day[\"avg_tip\"]) * 1.25)\n\n# Label bars\nfor x, y in zip(avg_tip_by_day[\"day\"], avg_tip_by_day[\"avg_tip\"]):\n    plt.text(x, y, f\"{y:.2f}\", ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the plt.bar() function directly to render the data, which falls under the matplotlib classification according to the hierarchy rules. Since the bars are vertical, the chart is classified as a Column chart."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20tips.csv\")\n\n# Create a simple, \"read the data\" level chart:\n# Average tip by day (bar chart)\nday_order = [\"Thur\", \"Fri\", \"Sat\", \"Sun\"]\navg_tip_by_day = df.groupby(\"day\", as_index=True)[\"tip\"].mean().reindex(day_order)\n\n# Plot\nplt.figure(figsize=(8, 4.5))\nbars = plt.bar(avg_tip_by_day.index, avg_tip_by_day.values, color=\"#4C78A8\")\n\nplt.title(\"Average Tip by Day\")\nplt.xlabel(\"Day\")\nplt.ylabel(\"Average tip ($)\")\nplt.ylim(0, max(avg_tip_by_day.values) * 1.2)\n\n# Add value labels\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h, f\"{h:.2f}\", ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is rendered using the standard matplotlib.pyplot function plt.bar() rather than seaborn or pandas wrappers. Since plt.bar() creates vertical bars by default, it is classified as a Column chart according to the taxonomy. A single hex color (#4C78A8) was used instead of a named color palette."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20tips.csv\")\n\n# Summarize: average tip by day\navg_tip_by_day = df.groupby(\"day\")[\"tip\"].mean().reindex([\"Thur\", \"Fri\", \"Sat\", \"Sun\"])\n\n# Plot: single chart\nplt.figure(figsize=(7, 4))\nplt.bar(avg_tip_by_day.index, avg_tip_by_day.values, color=\"#4C78A8\")\nplt.title(\"Average Tip by Day\")\nplt.xlabel(\"Day\")\nplt.ylabel(\"Average tip ($)\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data rather than using seaborn or pandas plot methods. Because the bars are vertical, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndf = pd.read_csv(\"20tips.csv\")\n\nsns.set_theme(style=\"whitegrid\")\n\nplt.figure(figsize=(8, 6))\nsns.scatterplot(\n    data=df,\n    x=\"total_bill\",\n    y=\"tip\",\n    hue=\"smoker\",\n    style=\"sex\",\n    s=80,\n    alpha=0.85\n)\n\nplt.title(\"Tip vs Total Bill (colored by Smoker, shaped by Sex)\")\nplt.xlabel(\"Total bill ($)\")\nplt.ylabel(\"Tip ($)\")\nplt.legend(title=\"Smoker / Sex\", bbox_to_anchor=(1.02, 1), loc=\"upper left\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using sns.scatterplot(), which takes priority over matplotlib and pandas in the library hierarchy. The plot visualizes the relationship between two quantitative variables (total_bill and tip), classifying it as a Scatterplot."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20tips.csv\")\n\n    # Single chart: scatter of total_bill vs tip, colored by smoker\n    smokers = [\"No\", \"Yes\"]\n    colors = {\"No\": \"#1f77b4\", \"Yes\": \"#ff7f0e\"}\n\n    plt.figure(figsize=(8, 5))\n    for s in smokers:\n        sub = df[df[\"smoker\"] == s]\n        plt.scatter(\n            sub[\"total_bill\"],\n            sub[\"tip\"],\n            s=45,\n            alpha=0.75,\n            c=colors[s],\n            label=f\"Smoker: {s}\",\n            edgecolors=\"white\",\n            linewidths=0.4,\n        )\n\n    plt.title(\"Tip vs Total Bill (colored by Smoker)\")\n    plt.xlabel(\"Total bill ($)\")\n    plt.ylabel(\"Tip ($)\")\n    plt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n    plt.legend(frameon=True)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.scatter() to draw the data points directly. The chart plots two quantitative variables (total_bill and tip), which matches the Scatterplot definition."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20tips.csv\")\n\n    # Tip率（%）を計算\n    df[\"tip_pct\"] = (df[\"tip\"] / df[\"total_bill\"]) * 100\n\n    # 曜日ごとのTip率分布（箱ひげ図）\n    order = [\"Thur\", \"Fri\", \"Sat\", \"Sun\"]\n    data = [df.loc[df[\"day\"] == d, \"tip_pct\"].dropna().values for d in order]\n\n    fig, ax = plt.subplots(figsize=(9, 5))\n    ax.boxplot(\n        data,\n        labels=order,\n        showmeans=True,\n        meanline=True,\n        patch_artist=True,\n        boxprops=dict(facecolor=\"#8ecae6\", edgecolor=\"#1f2d3d\", alpha=0.9),\n        medianprops=dict(color=\"#d62828\", linewidth=2),\n        meanprops=dict(color=\"#2a9d8f\", linewidth=2),\n        whiskerprops=dict(color=\"#1f2d3d\"),\n        capprops=dict(color=\"#1f2d3d\"),\n        flierprops=dict(marker=\"o\", markersize=4, markerfacecolor=\"#ffb703\", markeredgecolor=\"#1f2d3d\", alpha=0.8),\n    )\n\n    ax.set_title(\"Tip率（%）の曜日別分布（20tips.csv）\")\n    ax.set_xlabel(\"曜日\")\n    ax.set_ylabel(\"Tip率（%）\")\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Box plot", "color_palette": null, "reasoning": "The plot is generated using the matplotlib axes-level function `ax.boxplot()`. Although pandas is used for data preparation, the rendering is done directly through matplotlib's API rather than a wrapper like df.plot(). No named color palette is used; colors are specified via individual hex codes."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20tips.csv\")\n\n    # 单个图表：不同星期的平均小费\n    day_order = [\"Thur\", \"Fri\", \"Sat\", \"Sun\"]\n    avg_tip_by_day = (\n        df.groupby(\"day\", as_index=False)[\"tip\"]\n        .mean()\n        .set_index(\"day\")\n        .reindex(day_order)\n    )\n\n    fig, ax = plt.subplots(figsize=(8, 4.5))\n    ax.bar(avg_tip_by_day.index, avg_tip_by_day[\"tip\"], color=\"#4C78A8\")\n    ax.set_title(\"Average Tip by Day\")\n    ax.set_xlabel(\"Day\")\n    ax.set_ylabel(\"Average Tip ($)\")\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib axes-level function `ax.bar()` to render data, which draws vertical bars representing categories (days) and quantitative values (average tip)."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20tips.csv\")\n\n# Single chart: Tip vs Total Bill scatter, colored by smoker status\ncolor_map = {\"Yes\": \"#d62728\", \"No\": \"#1f77b4\"}\ncolors = df[\"smoker\"].map(color_map)\n\nfig, ax = plt.subplots(figsize=(8, 5))\n\nax.scatter(df[\"total_bill\"], df[\"tip\"], c=colors, alpha=0.8, edgecolor=\"white\", linewidth=0.6)\n\n# Legend (single plot)\nfor label in [\"No\", \"Yes\"]:\n    ax.scatter([], [], c=color_map[label], label=f\"Smoker: {label}\")\n\nax.set_title(\"Propina vs Total de la Cuenta (coloreado por fumador)\")\nax.set_xlabel(\"Total de la cuenta (total_bill)\")\nax.set_ylabel(\"Propina (tip)\")\nax.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.4)\nax.legend(frameon=True, title=\"Grupo\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using the Matplotlib Axes method `ax.scatter()` directly. The plot visualizes two quantitative variables ('total_bill' and 'tip'), fitting the definition of a Scatterplot."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20tips.csv\")\n\n# Derived metric: tip percentage\ndf[\"tip_pct\"] = 100 * df[\"tip\"] / df[\"total_bill\"]\n\n# Aggregate: median tip % by day and time\norder = [\"Thur\", \"Fri\", \"Sat\", \"Sun\"]\nagg = (\n    df.groupby([\"day\", \"time\"], as_index=False)[\"tip_pct\"]\n      .median()\n)\n\n# Ensure consistent ordering on x-axis\nagg[\"day\"] = pd.Categorical(agg[\"day\"], categories=order, ordered=True)\nagg = agg.sort_values([\"day\", \"time\"])\n\n# Prepare series for plotting (single chart: grouped bars)\ntimes = [\"Lunch\", \"Dinner\"]\nx = range(len(order))\nbar_w = 0.38\n\nvals_lunch = [float(agg[(agg[\"day\"] == d) & (agg[\"time\"] == \"Lunch\")][\"tip_pct\"].values[0])\n              if ((agg[\"day\"] == d) & (agg[\"time\"] == \"Lunch\")).any() else float(\"nan\")\n              for d in order]\nvals_dinner = [float(agg[(agg[\"day\"] == d) & (agg[\"time\"] == \"Dinner\")][\"tip_pct\"].values[0])\n               if ((agg[\"day\"] == d) & (agg[\"time\"] == \"Dinner\")).any() else float(\"nan\")\n               for d in order]\n\nfig, ax = plt.subplots(figsize=(9, 5.2), dpi=140)\n\nax.bar([i - bar_w/2 for i in x], vals_lunch, width=bar_w, label=\"Lunch\", color=\"#4C78A8\")\nax.bar([i + bar_w/2 for i in x], vals_dinner, width=bar_w, label=\"Dinner\", color=\"#F58518\")\n\nax.set_title(\"Median Tip Percentage by Day and Time (20tips.csv)\")\nax.set_xlabel(\"Day\")\nax.set_ylabel(\"Median tip (%)\")\nax.set_xticks(list(x))\nax.set_xticklabels(order)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nax.legend(frameon=False, title=\"Time\")\n\n# Annotate bars\nfor xi, v in zip([i - bar_w/2 for i in x], vals_lunch):\n    if v == v:  # not NaN\n        ax.text(xi, v + 0.15, f\"{v:.1f}%\", ha=\"center\", va=\"bottom\", fontsize=9)\nfor xi, v in zip([i + bar_w/2 for i in x], vals_dinner):\n    if v == v:\n        ax.text(xi, v + 0.15, f\"{v:.1f}%\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.bar() function directly to render vertical bars. Since there are two categorical variables (day and time) and the bars are placed side-by-side using manual offsets, it is classified as a grouped column chart."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20tips.csv\")\n\n# Feature: tip percentage\ndf[\"tip_pct\"] = df[\"tip\"] / df[\"total_bill\"] * 100\n\n# Order days for readability\nday_order = [\"Thur\", \"Fri\", \"Sat\", \"Sun\"]\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\n\n# Prepare grouped stats\ng = df.groupby(\"day\", observed=True)[\"tip_pct\"]\nsummary = pd.DataFrame({\n    \"mean\": g.mean(),\n    \"q1\": g.quantile(0.25),\n    \"q3\": g.quantile(0.75),\n    \"n\": g.size()\n}).dropna()\n\nx = np.arange(len(summary))\n\n# Figure\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5), dpi=140)\n\n# IQR band\nax.fill_between(\n    x,\n    summary[\"q1\"].to_numpy(),\n    summary[\"q3\"].to_numpy(),\n    color=\"#4C78A8\",\n    alpha=0.18,\n    linewidth=0\n)\n\n# Mean line\nax.plot(x, summary[\"mean\"].to_numpy(), color=\"#4C78A8\", linewidth=2.5, marker=\"o\")\n\n# Light jittered points for distribution context\nrng = np.random.default_rng(7)\nfor i, day in enumerate(summary.index.tolist()):\n    vals = df.loc[df[\"day\"] == day, \"tip_pct\"].to_numpy()\n    jitter = rng.normal(0, 0.06, size=len(vals))\n    ax.scatter(\n        np.full_like(vals, i, dtype=float) + jitter,\n        vals,\n        s=18,\n        color=\"#1F2937\",\n        alpha=0.25,\n        linewidths=0\n    )\n\n# Labels & cosmetics\nax.set_title(\"Tip Percentage by Day (mean with IQR band; points jittered)\", pad=12, fontsize=13, weight=\"semibold\")\nax.set_xlabel(\"Day\")\nax.set_ylabel(\"Tip (% of total bill)\")\nax.set_xticks(x)\nax.set_xticklabels([f\"{d}\\n(n={int(summary.loc[d,'n'])})\" for d in summary.index])\nax.set_ylim(0, max(30, float(df[\"tip_pct\"].max()) * 1.08))\n\n# Subtle spines\nfor s in [\"top\", \"right\"]:\n    ax.spines[s].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using standard matplotlib axes methods (ax.fill_between, ax.plot, and ax.scatter) rather than pandas or seaborn wrappers. The chart displays a quantitative variable (tip percentage) across categorical labels (days) connected by a line."}}
{"input_csv_file": "20tips.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import PercentFormatter\n\n# Load data\ndf = pd.read_csv(\"20tips.csv\")\n\n# Feature: tip percentage\ndf[\"tip_pct\"] = df[\"tip\"] / df[\"total_bill\"]\n\n# Order days as commonly presented for this dataset\nday_order = [\"Thur\", \"Fri\", \"Sat\", \"Sun\"]\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\n\n# Aggregate: mean tip percentage by day and time\ng = (\n    df.groupby([\"day\", \"time\"], observed=True)[\"tip_pct\"]\n    .mean()\n    .reset_index()\n)\n\npivot = g.pivot(index=\"day\", columns=\"time\", values=\"tip_pct\").reindex(day_order)\n\n# Plot: grouped bars for Lunch vs Dinner by day\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5))\n\ncolors = {\"Lunch\": \"#4C78A8\", \"Dinner\": \"#F58518\"}\nx = range(len(pivot.index))\nwidth = 0.38\n\nlunch = pivot.get(\"Lunch\")\ndinner = pivot.get(\"Dinner\")\n\nif lunch is not None:\n    ax.bar([i - width / 2 for i in x], lunch.values, width=width, label=\"Lunch\", color=colors[\"Lunch\"])\nif dinner is not None:\n    ax.bar([i + width / 2 for i in x], dinner.values, width=width, label=\"Dinner\", color=colors[\"Dinner\"])\n\n# Formatting\nax.set_title(\"Average Tip Percentage by Day and Time\")\nax.set_xlabel(\"Day\")\nax.set_ylabel(\"Average tip (% of total bill)\")\nax.set_xticks(list(x))\nax.set_xticklabels(pivot.index.tolist())\nax.yaxis.set_major_formatter(PercentFormatter(1.0))\nax.set_ylim(0, max(pivot.max(skipna=True)) * 1.25)\n\n# Value labels\nfor container in ax.containers:\n    ax.bar_label(container, labels=[f\"{v*100:.1f}%\" if pd.notna(v) else \"\" for v in container.datavalues],\n                 padding=3, fontsize=9)\n\nax.legend(frameon=True, title=\"Time\")\nfig.tight_layout()\nplt.show()\n```", "judgment": {"error": "JSON Parsing Failed: Expecting property name enclosed in double quotes: line 6 column 1 (char 400)", "raw_text": "{\n    \"library\": \"matplotlib\",\n    \"chart_type\": \"Grouped column chart\",\n    \"color_palette\": null,\n    \"reasoning\": \"The code uses the Matplotlib Axes API (ax.bar) directly to render vertical bars. By calculating manual x-offsets for the 'Lunch' and 'Dinner' categories across the 'day' index, it creates a vertical grouped bar layout, which corresponds to a Grouped column chart in the taxonomy.\",\n}"}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20wine.csv\")\n\n# Single chart: Alcohol vs Malic.acid, colored by Wine class\nfig, ax = plt.subplots(figsize=(8, 5))\n\ncolors = {1: \"#1f77b4\", 2: \"#ff7f0e\", 3: \"#2ca02c\"}\nfor wine_class in sorted(df[\"Wine\"].unique()):\n    sub = df[df[\"Wine\"] == wine_class]\n    ax.scatter(\n        sub[\"Alcohol\"],\n        sub[\"Malic.acid\"],\n        s=55,\n        alpha=0.85,\n        c=colors.get(wine_class, \"#333333\"),\n        edgecolor=\"white\",\n        linewidth=0.6,\n        label=f\"Wine {wine_class}\",\n    )\n\nax.set_title(\"Alcohol vs Malic Acid by Wine Class\")\nax.set_xlabel(\"Alcohol\")\nax.set_ylabel(\"Malic acid\")\nax.grid(True, linestyle=\"--\", alpha=0.3)\nax.legend(title=\"Class\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered directly using matplotlib's ax.scatter() function. The chart visualizes the relationship between two quantitative dimensions (Alcohol and Malic.acid)."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20wine.csv\")\n\n# Compute average Alcohol by Wine class\nsummary = (\n    df.groupby(\"Wine\", as_index=False)[\"Alcohol\"]\n    .mean()\n    .rename(columns={\"Alcohol\": \"Avg_Alcohol\"})\n    .sort_values(\"Wine\")\n)\n\n# Plot: single chart (bar chart)\nplt.figure(figsize=(7, 4.5))\nbars = plt.bar(summary[\"Wine\"].astype(str), summary[\"Avg_Alcohol\"], color=\"#4C78A8\")\n\nplt.title(\"Average Alcohol Content by Wine Class\")\nplt.xlabel(\"Wine Class\")\nplt.ylabel(\"Average Alcohol (%)\")\n\n# Add value labels (simple, read-off-the-graph friendly)\nfor b, v in zip(bars, summary[\"Avg_Alcohol\"]):\n    plt.text(b.get_x() + b.get_width() / 2, b.get_height() + 0.02, f\"{v:.2f}\",\n             ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.ylim(0, max(summary[\"Avg_Alcohol\"]) + 1.0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.bar() to draw vertical bars, making it a Column chart according to the taxonomy. Although a specific hex color (#4C78A8) is defined, no named color palette was used."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20wine.csv\")\n\n# Compute mean Alcohol by Wine class\nmean_alcohol = df.groupby(\"Wine\", as_index=False)[\"Alcohol\"].mean().sort_values(\"Wine\")\n\n# Plot: simple bar chart (appropriate for basic \"read the data\" level)\nplt.figure(figsize=(7, 4.5))\nplt.bar(mean_alcohol[\"Wine\"].astype(str), mean_alcohol[\"Alcohol\"], color=\"#4C78A8\")\n\nplt.title(\"Average Alcohol Content by Wine Class\")\nplt.xlabel(\"Wine Class\")\nplt.ylabel(\"Average Alcohol (%)\")\n\nfor x, y in zip(mean_alcohol[\"Wine\"].astype(str), mean_alcohol[\"Alcohol\"]):\n    plt.text(x, y + 0.03, f\"{y:.2f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.ylim(0, max(mean_alcohol[\"Alcohol\"]) + 0.8)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using plt.bar() directly from the matplotlib.pyplot library. Since the bars are vertical and represent a categorical variable against a quantitative one, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20wine.csv\")\n\n# Summarize Alcohol by Wine class (mean)\nsummary = df.groupby(\"Wine\", as_index=False)[\"Alcohol\"].mean().sort_values(\"Wine\")\n\n# Plot: single chart (bar chart)\nplt.figure(figsize=(7, 4.5))\nplt.bar(summary[\"Wine\"].astype(str), summary[\"Alcohol\"], color=\"#4C78A8\")\nplt.title(\"Average Alcohol Content by Wine Class\")\nplt.xlabel(\"Wine Class\")\nplt.ylabel(\"Average Alcohol (%)\")\nplt.ylim(0, max(summary[\"Alcohol\"]) * 1.15)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\n# Add value labels\nfor x, y in zip(summary[\"Wine\"].astype(str), summary[\"Alcohol\"]):\n    plt.text(x, y, f\"{y:.2f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot uses plt.bar() directly to render vertical bars based on categorical (Wine) and quantitative (Alcohol) data, classifying it as a matplotlib Column chart."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20wine.csv\")\n\n# One chart: Alcohol vs Malic.acid colored by Wine class\nfig, ax = plt.subplots(figsize=(8, 5))\nfor wine_class, g in df.groupby(\"Wine\"):\n    ax.scatter(g[\"Alcohol\"], g[\"Malic.acid\"], s=55, alpha=0.85, label=f\"Wine {wine_class}\")\n\nax.set_title(\"Alcohol vs Malic Acid by Wine Class\")\nax.set_xlabel(\"Alcohol\")\nax.set_ylabel(\"Malic.acid\")\nax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\nax.legend(title=\"Class\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the standard matplotlib axes function `ax.scatter()` to visualize two quantitative variables (Alcohol and Malic.acid) against each other, which defines a scatterplot. No specific named color palette was provided."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20wine.csv\")\n\n    fig, ax = plt.subplots(figsize=(8, 5))\n\n    colors = {1: \"#1f77b4\", 2: \"#ff7f0e\", 3: \"#2ca02c\"}\n    for wine_class in sorted(df[\"Wine\"].unique()):\n        sub = df[df[\"Wine\"] == wine_class]\n        ax.scatter(\n            sub[\"Alcohol\"],\n            sub[\"Malic.acid\"],\n            s=55,\n            alpha=0.85,\n            edgecolor=\"white\",\n            linewidth=0.6,\n            color=colors.get(wine_class, None),\n            label=f\"Wine {wine_class}\",\n        )\n\n    ax.set_title(\"Alcohol vs Malic Acid by Wine Class\")\n    ax.set_xlabel(\"Alcohol\")\n    ax.set_ylabel(\"Malic.acid\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.5)\n    ax.legend(title=\"Class\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The plot is created using the ax.scatter() method from the matplotlib library to map two quantitative variables (Alcohol and Malic.acid) to the x and y axes. Although a custom dictionary of hex colors is provided, no named library palette is used."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20wine.csv\")\n\n    fig, ax = plt.subplots(figsize=(8, 6))\n\n    for wine_class in sorted(df[\"Wine\"].unique()):\n        sub = df[df[\"Wine\"] == wine_class]\n        ax.scatter(\n            sub[\"Alcohol\"],\n            sub[\"Malic.acid\"],\n            s=55,\n            alpha=0.8,\n            edgecolor=\"white\",\n            linewidth=0.6,\n            label=f\"Wine {wine_class}\",\n        )\n\n    ax.set_title(\"Wine Dataset: Alcohol vs Malic.acid by Wine Class\")\n    ax.set_xlabel(\"Alcohol\")\n    ax.set_ylabel(\"Malic.acid\")\n    ax.legend(title=\"Class\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization uses the `ax.scatter()` method from matplotlib to plot two quantitative variables ('Alcohol' and 'Malic.acid'). While it iterates through classes to assign labels, the primary rendering engine is matplotlib directly."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"20wine.csv\")\n\n    features = [\"Alcohol\", \"Malic.acid\", \"Ash\", \"Acl\"]\n    wine_classes = sorted(df[\"Wine\"].unique())\n\n    data_by_class = [df.loc[df[\"Wine\"] == c, features] for c in wine_classes]\n\n    fig, ax = plt.subplots(figsize=(10, 5))\n\n    bp = ax.boxplot(\n        data_by_class,\n        labels=[str(c) for c in wine_classes],\n        patch_artist=True,\n        widths=0.6,\n        medianprops=dict(color=\"black\", linewidth=1.5),\n        boxprops=dict(linewidth=1.0),\n        whiskerprops=dict(linewidth=1.0),\n        capprops=dict(linewidth=1.0),\n    )\n\n    colors = [\"#4C78A8\", \"#F58518\", \"#54A24B\"]\n    for patch, color in zip(bp[\"boxes\"], colors):\n        patch.set_facecolor(color)\n        patch.set_alpha(0.35)\n        patch.set_edgecolor(color)\n\n    ax.set_title(\"Wine 类别(1/2/3)的特征分布（箱线图）\", pad=10)\n    ax.set_xlabel(\"Wine（类别）\")\n    ax.set_ylabel(\"标准化特征值（z-score）\")\n\n    ax.grid(True, axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n    ax.legend(\n        handles=[\n            plt.Line2D([0], [0], color=colors[i], lw=6, alpha=0.35, label=f\"Wine {wine_classes[i]}\")\n            for i in range(len(wine_classes))\n        ],\n        title=\"类别\",\n        frameon=False,\n        loc=\"upper right\",\n    )\n\n    # 标准化并重新绘制：在同一个图表中叠加“标准化后的箱线图”\n    # 做法：将原始数据转换为长表后按 Wine 分组标准化，再在同一坐标轴上作图（保持单一图表）\n    z = df.copy()\n    for col in features:\n        z[col] = (z[col] - z[col].mean()) / z[col].std(ddof=0)\n\n    data_by_class_z = [z.loc[z[\"Wine\"] == c, features] for c in wine_classes]\n    ax.clear()\n\n    bpz = ax.boxplot(\n        data_by_class_z,\n        labels=[str(c) for c in wine_classes],\n        patch_artist=True,\n        widths=0.6,\n        medianprops=dict(color=\"black\", linewidth=1.5),\n        boxprops=dict(linewidth=1.0),\n        whiskerprops=dict(linewidth=1.0),\n        capprops=dict(linewidth=1.0),\n    )\n\n    for patch, color in zip(bpz[\"boxes\"], colors):\n        patch.set_facecolor(color)\n        patch.set_alpha(0.35)\n        patch.set_edgecolor(color)\n\n    ax.set_title(\"Wine 类别(1/2/3)的特征分布（z-score 标准化后箱线图）\", pad=10)\n    ax.set_xlabel(\"Wine（类别）\")\n    ax.set_ylabel(\"标准化特征值（z-score）\")\n    ax.grid(True, axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n    ax.legend(\n        handles=[\n            plt.Line2D([0], [0], color=colors[i], lw=6, alpha=0.35, label=f\"Wine {wine_classes[i]}\")\n            for i in range(len(wine_classes))\n        ],\n        title=\"类别\",\n        frameon=False,\n        loc=\"upper right\",\n    )\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Box plot", "color_palette": null, "reasoning": "The code uses the direct matplotlib axes method `ax.boxplot()` to render the visualization, making it a matplotlib-based chart."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"20wine.csv\")\n\n# Un solo gráfico: Alcohol vs Malic.acid, coloreado por tipo de vino (Wine)\nfig, ax = plt.subplots(figsize=(8, 5))\n\ncolors = {1: \"#1f77b4\", 2: \"#ff7f0e\", 3: \"#2ca02c\"}\nfor wine_type, grp in df.groupby(\"Wine\"):\n    ax.scatter(\n        grp[\"Alcohol\"],\n        grp[\"Malic.acid\"],\n        s=55,\n        alpha=0.85,\n        color=colors.get(int(wine_type), \"gray\"),\n        edgecolor=\"white\",\n        linewidth=0.6,\n        label=f\"Wine {wine_type}\",\n    )\n\nax.set_title(\"Relación entre Alcohol y Ácido Málico por tipo de vino\")\nax.set_xlabel(\"Alcohol\")\nax.set_ylabel(\"Malic.acid\")\nax.legend(title=\"Clase\", frameon=True)\nax.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses ax.scatter() directly to render the data points, which identifies the library as matplotlib under the hierarchy rules. The chart visualizes the relationship between two quantitative variables (Alcohol and Malic.acid), classifying it as a Scatterplot."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"20wine.csv\")\n\n# Style\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\n\n# Single chart: Alcohol distribution by Wine class\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsns.boxplot(\n    data=df,\n    x=\"Wine\",\n    y=\"Alcohol\",\n    hue=\"Wine\",\n    palette=\"Set2\",\n    dodge=False,\n    width=0.55,\n    linewidth=1.5,\n    ax=ax,\n)\n\nsns.stripplot(\n    data=df,\n    x=\"Wine\",\n    y=\"Alcohol\",\n    color=\"black\",\n    size=4,\n    alpha=0.65,\n    jitter=0.18,\n    ax=ax,\n)\n\nax.set_title(\"Alcohol by Wine Class (Boxplot + Individual Samples)\")\nax.set_xlabel(\"Wine class\")\nax.set_ylabel(\"Alcohol\")\nax.legend_.remove()\n\nsns.despine(ax=ax)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Box plot", "color_palette": "Set2", "reasoning": "The data is rendered using Seaborn functions (sns.boxplot and sns.stripplot). According to the hierarchy rules, Seaborn takes priority over matplotlib when sns functions are used to draw the data. The primary chart type used to analyze the distribution is a box plot."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20wine.csv\")\n\n# Plot: Alcohol vs Malic acid, colored by Wine class, sized by Acl\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 6))\n\nclasses = sorted(df[\"Wine\"].unique())\ncolors = {1: \"#1f77b4\", 2: \"#ff7f0e\", 3: \"#2ca02c\"}\n\nfor c in classes:\n    d = df[df[\"Wine\"] == c]\n    ax.scatter(\n        d[\"Malic.acid\"],\n        d[\"Alcohol\"],\n        s=(d[\"Acl\"] - df[\"Acl\"].min() + 2) ** 2 * 3.0,\n        c=colors.get(c, \"#333333\"),\n        alpha=0.75,\n        edgecolors=\"white\",\n        linewidths=0.6,\n        label=f\"Wine {c}\",\n    )\n\nax.set_title(\"Alcohol vs Malic Acid by Wine Class (size ~ Acl)\")\nax.set_xlabel(\"Malic acid\")\nax.set_ylabel(\"Alcohol\")\nax.legend(title=\"Class\", frameon=True, loc=\"best\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The code uses the matplotlib axes method `ax.scatter()` directly for rendering. The visualization is classified as a bubble chart because it maps two quantitative variables to the X and Y axes and a third quantitative variable (Acl) to the marker size."}}
{"input_csv_file": "20wine.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"20wine.csv\")\n\n# Single chart: Alcohol vs Malic.acid, colored by Wine class\nfig, ax = plt.subplots(figsize=(8.5, 5.5))\n\nclasses = sorted(df[\"Wine\"].unique())\ncolors = {1: \"#1f77b4\", 2: \"#ff7f0e\", 3: \"#2ca02c\"}\n\nfor c in classes:\n    d = df[df[\"Wine\"] == c]\n    ax.scatter(\n        d[\"Alcohol\"],\n        d[\"Malic.acid\"],\n        s=55,\n        alpha=0.85,\n        edgecolor=\"white\",\n        linewidth=0.6,\n        c=colors.get(c, \"gray\"),\n        label=f\"Wine {c}\",\n    )\n\nax.set_title(\"Alcohol vs Malic Acid by Wine Class\")\nax.set_xlabel(\"Alcohol\")\nax.set_ylabel(\"Malic acid\")\nax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.35)\nax.legend(title=\"Class\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization is created using the Matplotlib axes function `ax.scatter()` to plot two quantitative variables (Alcohol and Malic.acid). Since the plotting is done through matplotlib directly rather than a seaborn or pandas wrapper, it is classified as matplotlib."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21college_2time_slot.csv\"\ndf = pd.read_csv(csv_path)\n\n# Build start/end times in minutes since midnight and duration\ndf[\"start_min_total\"] = df[\"start_hr\"] * 60 + df[\"start_min\"]\ndf[\"end_min_total\"] = df[\"end_hr\"] * 60 + df[\"end_min\"]\ndf[\"duration_min\"] = df[\"end_min_total\"] - df[\"start_min_total\"]\n\n# Map days to y positions (Mon..Fri + Thu as R)\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\nday_labels = {\"M\": \"Mon\", \"T\": \"Tue\", \"W\": \"Wed\", \"R\": \"Thu\", \"F\": \"Fri\"}\ndf = df[df[\"day\"].isin(day_order)].copy()\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\ndf = df.sort_values([\"day\", \"start_min_total\", \"time_slot_id\"])\n\ny_map = {d: i for i, d in enumerate(day_order)}\ndf[\"y\"] = df[\"day\"].map(y_map)\n\n# Plot: weekly schedule as a single Gantt-like chart\nfig, ax = plt.subplots(figsize=(10, 5))\n\n# Assign a distinct color per time_slot_id\nslot_ids = sorted(df[\"time_slot_id\"].unique())\ncmap = plt.get_cmap(\"tab20\")\ncolor_map = {sid: cmap(i % 20) for i, sid in enumerate(slot_ids)}\n\nfor _, r in df.iterrows():\n    ax.barh(\n        y=r[\"y\"],\n        width=r[\"duration_min\"],\n        left=r[\"start_min_total\"],\n        height=0.6,\n        color=color_map[r[\"time_slot_id\"]],\n        edgecolor=\"black\",\n        linewidth=0.6,\n        alpha=0.9,\n    )\n    ax.text(\n        r[\"start_min_total\"] + r[\"duration_min\"] / 2,\n        r[\"y\"],\n        str(r[\"time_slot_id\"]),\n        va=\"center\",\n        ha=\"center\",\n        fontsize=9,\n        color=\"black\",\n    )\n\n# Axes formatting\nax.set_yticks([y_map[d] for d in day_order])\nax.set_yticklabels([day_labels[d] for d in day_order])\n\n# X ticks every hour from 08:00 to 17:00\nmin_x = max(0, int(df[\"start_min_total\"].min() // 60 * 60))\nmax_x = int((df[\"end_min_total\"].max() + 59) // 60 * 60)\nxticks = list(range(min_x, max_x + 1, 60))\nax.set_xticks(xticks)\nax.set_xticklabels([f\"{t//60:02d}:00\" for t in xticks])\n\nax.set_xlim(min_x - 15, max_x + 15)\nax.set_xlabel(\"Time of day\")\nax.set_title(\"College Time Slots by Day (from 21college_2time_slot.csv)\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "tab20", "reasoning": "The code uses ax.barh() directly to render horizontal bars representing durations, and matplotlib.pyplot.subplots() to initialize the figure. Since it calls drawing functions from the matplotlib library rather than pandas or seaborn wrappers, it is classified as matplotlib."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21college_2time_slot.csv\")\n\n# Build time columns (minutes since midnight)\ndf[\"start_min_total\"] = df[\"start_hr\"] * 60 + df[\"start_min\"]\ndf[\"end_min_total\"] = df[\"end_hr\"] * 60 + df[\"end_min\"]\ndf[\"duration_min\"] = df[\"end_min_total\"] - df[\"start_min_total\"]\n\n# Day ordering and labels\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\nday_labels = {\"M\": \"Mon\", \"T\": \"Tue\", \"W\": \"Wed\", \"R\": \"Thu\", \"F\": \"Fri\"}\ndf = df[df[\"day\"].isin(day_order)].copy()\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\ndf = df.sort_values([\"day\", \"start_min_total\", \"time_slot_id\"])\n\n# Map each row to a y-position (one row per time-slot meeting)\ndf[\"y\"] = range(len(df))\ny_labels = [f\"{day_labels[d]}  {tid}\" for d, tid in zip(df[\"day\"], df[\"time_slot_id\"])]\n\n# Plot: horizontal timeline bars showing start time and duration\nfig, ax = plt.subplots(figsize=(11, 7))\nax.barh(\n    df[\"y\"],\n    df[\"duration_min\"],\n    left=df[\"start_min_total\"],\n    color=\"#4C78A8\",\n    edgecolor=\"black\",\n    linewidth=0.6,\n)\n\n# X-axis ticks formatted as time of day\ndef fmt_time(m):\n    h = int(m // 60)\n    mm = int(m % 60)\n    return f\"{h:02d}:{mm:02d}\"\n\nxmin = df[\"start_min_total\"].min()\nxmax = df[\"end_min_total\"].max()\n\n# choose a reasonable tick step (30 minutes)\ntick_step = 30\nticks = list(range((xmin // tick_step) * tick_step, ((xmax + tick_step - 1) // tick_step) * tick_step + 1, tick_step))\nax.set_xticks(ticks)\nax.set_xticklabels([fmt_time(t) for t in ticks], rotation=0)\n\n# Y-axis labels\nax.set_yticks(df[\"y\"])\nax.set_yticklabels(y_labels)\n\n# Styling and labels\nax.set_title(\"College Time Slots by Day (Start–End Times)\")\nax.set_xlabel(\"Time of day\")\nax.set_ylabel(\"Day and time slot\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\nax.invert_yaxis()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses `ax.barh()` to render the data directly onto a matplotlib axes object. This function creates horizontal bars, which classifies it as a 'Bar chart' according to the provided taxonomy. No named color palette or seaborn/pandas plotting wrappers were used."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21college_2time_slot.csv\")\n\n# Convert start/end to minutes since midnight for easy plotting\ndf[\"start_min_total\"] = df[\"start_hr\"] * 60 + df[\"start_min\"]\ndf[\"end_min_total\"] = df[\"end_hr\"] * 60 + df[\"end_min\"]\ndf[\"duration_min\"] = df[\"end_min_total\"] - df[\"start_min_total\"]\n\n# Order days (college schedule style)\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\n\n# Sort for nicer plotting\ndf = df.sort_values([\"day\", \"start_min_total\", \"time_slot_id\"]).reset_index(drop=True)\n\n# Map days to y positions\ndays_present = [d for d in day_order if d in df[\"day\"].astype(str).unique()]\ny_map = {d: i for i, d in enumerate(days_present)}\ndf[\"y\"] = df[\"day\"].astype(str).map(y_map)\n\n# Plot a simple weekly schedule as horizontal time blocks\nplt.figure(figsize=(10, 4.8))\nfor _, r in df.iterrows():\n    plt.barh(\n        y=r[\"y\"],\n        width=r[\"duration_min\"],\n        left=r[\"start_min_total\"],\n        height=0.6,\n        color=\"#4C78A8\",\n        edgecolor=\"white\",\n        linewidth=0.8,\n    )\n    # Label each block with its time_slot_id\n    plt.text(\n        r[\"start_min_total\"] + r[\"duration_min\"] / 2,\n        r[\"y\"],\n        str(r[\"time_slot_id\"]),\n        va=\"center\",\n        ha=\"center\",\n        color=\"white\",\n        fontsize=9,\n        fontweight=\"bold\",\n    )\n\n# X-axis ticks as clock times\ntick_hours = list(range(8, 18))\nticks = [h * 60 for h in tick_hours]\ntick_labels = [f\"{h}:00\" for h in tick_hours]\nplt.xticks(ticks, tick_labels)\n\n# Y-axis labels\nplt.yticks(list(y_map.values()), list(y_map.keys()))\nplt.xlabel(\"Time of day\")\nplt.ylabel(\"Day\")\nplt.title(\"Class Time Slots by Day (21college_2time_slot.csv)\")\nplt.xlim(8 * 60, 17 * 60)\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib 'plt.barh' function to create horizontal bars. According to the taxonomy, horizontal bars are classified as 'Bar chart', and since no seaborn or pandas plotting wrappers are used, the library is 'matplotlib'.", "is_valid": true}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21college_2time_slot.csv\")\n\n# Compute duration (minutes)\ndf[\"start_total_min\"] = df[\"start_hr\"] * 60 + df[\"start_min\"]\ndf[\"end_total_min\"] = df[\"end_hr\"] * 60 + df[\"end_min\"]\ndf[\"duration_min\"] = df[\"end_total_min\"] - df[\"start_total_min\"]\n\n# Order days (college-style) and label them\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\nday_labels = {\"M\": \"Mon\", \"T\": \"Tue\", \"W\": \"Wed\", \"R\": \"Thu\", \"F\": \"Fri\"}\ndf = df[df[\"day\"].isin(day_order)].copy()\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\ndf = df.sort_values([\"day\", \"start_total_min\"])\n\n# Aggregate: average duration by day\navg_by_day = df.groupby(\"day\", observed=True)[\"duration_min\"].mean().reindex(day_order)\n\n# Plot: bar chart (single chart)\nplt.figure(figsize=(8, 4.5))\nplt.bar([day_labels[d] for d in avg_by_day.index], avg_by_day.values, color=\"#4C78A8\")\nplt.title(\"Average Class Time Slot Duration by Day\")\nplt.xlabel(\"Day\")\nplt.ylabel(\"Average Duration (minutes)\")\nplt.ylim(0, max(60, (avg_by_day.max() or 0) + 10))\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using plt.bar() which renders vertical bars, distinguishing it as a Column chart rather than a Bar chart (horizontal) according to the taxonomy. The plotting is done directly through matplotlib rather than a pandas wrapper or seaborn."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21college_2time_slot.csv\")\n\n# Compute duration in minutes\ndf[\"start_minutes\"] = df[\"start_hr\"] * 60 + df[\"start_min\"]\ndf[\"end_minutes\"] = df[\"end_hr\"] * 60 + df[\"end_min\"]\ndf[\"duration_min\"] = df[\"end_minutes\"] - df[\"start_minutes\"]\n\n# Aggregate: average duration per time_slot_id\navg_duration = (\n    df.groupby(\"time_slot_id\", as_index=False)[\"duration_min\"]\n      .mean()\n      .sort_values(\"time_slot_id\")\n)\n\n# Plot (single chart)\nplt.figure(figsize=(8, 4.5))\nplt.bar(avg_duration[\"time_slot_id\"], avg_duration[\"duration_min\"], color=\"#4C78A8\")\nplt.title(\"Average Duration per Time Slot ID\")\nplt.xlabel(\"Time Slot ID\")\nplt.ylabel(\"Average Duration (minutes)\")\nplt.ylim(0, max(avg_duration[\"duration_min\"]) + 10)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, which falls under the matplotlib classification. Since plt.bar() creates vertical bars by default, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21college_2time_slot.csv\"\ndf = pd.read_csv(csv_path)\n\n# Build start/end times in minutes from midnight\ndf[\"start_min_total\"] = df[\"start_hr\"] * 60 + df[\"start_min\"]\ndf[\"end_min_total\"] = df[\"end_hr\"] * 60 + df[\"end_min\"]\ndf[\"duration_min\"] = df[\"end_min_total\"] - df[\"start_min_total\"]\n\n# Day order (M T W R F)\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\n\n# Sort for a cleaner plot\ndf = df.sort_values([\"day\", \"start_min_total\", \"time_slot_id\"]).reset_index(drop=True)\n\n# Map each entry to a y-position (one row per day label)\nday_to_y = {d: i for i, d in enumerate(day_order)}\ndf[\"y\"] = df[\"day\"].map(day_to_y)\n\n# Plot: single chart (timeline-like horizontal bars by day)\nfig, ax = plt.subplots(figsize=(10, 4.5))\n\nfor _, row in df.iterrows():\n    ax.broken_barh(\n        [(row[\"start_min_total\"], row[\"duration_min\"])],\n        (row[\"y\"] - 0.35, 0.7),\n        facecolors=\"tab:blue\",\n        edgecolors=\"black\",\n        linewidth=0.6,\n        alpha=0.85\n    )\n    # Label each block with time_slot_id\n    ax.text(\n        row[\"start_min_total\"] + row[\"duration_min\"] / 2,\n        row[\"y\"],\n        str(row[\"time_slot_id\"]),\n        ha=\"center\",\n        va=\"center\",\n        color=\"white\",\n        fontsize=9,\n        fontweight=\"bold\"\n    )\n\n# Axes formatting\nax.set_yticks([day_to_y[d] for d in day_order])\nax.set_yticklabels(day_order)\nax.set_ylim(-0.8, len(day_order) - 0.2)\n\n# X ticks every hour from earliest to latest\nxmin = int(df[\"start_min_total\"].min() // 60) * 60\nxmax = int((df[\"end_min_total\"].max() + 59) // 60) * 60\nax.set_xlim(xmin, xmax)\n\nxticks = list(range(xmin, xmax + 1, 60))\nax.set_xticks(xticks)\nax.set_xticklabels([f\"{t//60:02d}:00\" for t in xticks])\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Day\")\nax.set_title(\"Time Slots by Day (21college_2time_slot)\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.broken_barh() function to create horizontal bars segments representing time slots. According to the taxonomy, horizontal bars representing categorical variables (Days) are classified as Bar charts."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef to_minutes(hr, minute):\n    return int(hr) * 60 + int(minute)\n\ncsv_path = \"21college_2time_slot.csv\"\ndf = pd.read_csv(csv_path)\n\n# Compute start/end in minutes from midnight\ndf[\"start_minute\"] = df.apply(lambda r: to_minutes(r[\"start_hr\"], r[\"start_min\"]), axis=1)\ndf[\"end_minute\"] = df.apply(lambda r: to_minutes(r[\"end_hr\"], r[\"end_min\"]), axis=1)\n\n# Order days (M T W R F)\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\nday_labels = {\"M\": \"Mon\", \"T\": \"Tue\", \"W\": \"Wed\", \"R\": \"Thu\", \"F\": \"Fri\"}\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\n\n# Sort for nicer plotting\ndf = df.sort_values([\"day\", \"start_minute\", \"time_slot_id\"])\n\n# Plot as a weekly timetable (single chart)\nfig, ax = plt.subplots(figsize=(10, 5))\n\n# Map days to y positions\nypos = {d: i for i, d in enumerate(day_order)}\nbar_height = 0.7\n\nfor _, r in df.iterrows():\n    y = ypos[str(r[\"day\"])]\n    start = r[\"start_minute\"]\n    duration = r[\"end_minute\"] - r[\"start_minute\"]\n    ax.barh(y, duration, left=start, height=bar_height, edgecolor=\"black\", alpha=0.85)\n    ax.text(\n        start + duration / 2,\n        y,\n        str(r[\"time_slot_id\"]),\n        va=\"center\",\n        ha=\"center\",\n        fontsize=9,\n        color=\"black\",\n    )\n\n# X-axis ticks every hour from min to max\nxmin = int(df[\"start_minute\"].min() // 60) * 60\nxmax = int((df[\"end_minute\"].max() + 59) // 60) * 60\nxticks = list(range(xmin, xmax + 1, 60))\nax.set_xticks(xticks)\nax.set_xticklabels([f\"{t//60:02d}:00\" for t in xticks])\n\n# Y-axis labels\nax.set_yticks([ypos[d] for d in day_order])\nax.set_yticklabels([day_labels[d] for d in day_order])\n\nax.set_xlim(xmin, xmax)\nax.set_xlabel(\"Time of day\")\nax.set_title(\"Time Slots (Weekly Schedule)\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\nax.set_axisbelow(True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's axes-level function 'ax.barh()' to render horizontal bars representing durations of time slots. According to the taxonomy, horizontal bars are classified as a 'Bar chart' and the direct use of 'ax.barh' identifies 'matplotlib' as the library."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21college_2time_slot.csv\"\ndf = pd.read_csv(csv_path)\n\n# Helpers\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\", \"S\", \"U\"]\nday_labels = {\"M\": \"Mon\", \"T\": \"Tue\", \"W\": \"Wed\", \"R\": \"Thu\", \"F\": \"Fri\", \"S\": \"Sat\", \"U\": \"Sun\"}\n\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\ndf = df.sort_values([\"day\", \"start_hr\", \"start_min\", \"time_slot_id\"])\n\ndf[\"start\"] = df[\"start_hr\"] + df[\"start_min\"] / 60.0\ndf[\"end\"] = df[\"end_hr\"] + df[\"end_min\"] / 60.0\ndf[\"dur\"] = df[\"end\"] - df[\"start\"]\n\n# Plot: schedule-style (Gantt) chart by day\nfig, ax = plt.subplots(figsize=(10, 5.8))\n\nfor _, r in df.iterrows():\n    y = day_order.index(r[\"day\"])\n    ax.barh(\n        y=y,\n        width=r[\"dur\"],\n        left=r[\"start\"],\n        height=0.65,\n        edgecolor=\"black\",\n        linewidth=0.8,\n        alpha=0.85,\n        label=r[\"time_slot_id\"],\n    )\n    ax.text(\n        r[\"start\"] + r[\"dur\"] / 2,\n        y,\n        str(r[\"time_slot_id\"]),\n        ha=\"center\",\n        va=\"center\",\n        fontsize=9,\n        color=\"black\",\n    )\n\n# Axes formatting\nax.set_yticks(range(len(day_order)))\nax.set_yticklabels([day_labels.get(d, d) for d in day_order])\nax.invert_yaxis()  # Mon at top\n\nax.set_xlim(7.5, 17.5)\nxticks = list(range(8, 18))\nax.set_xticks(xticks)\nax.set_xticklabels([f\"{h:02d}:00\" for h in xticks])\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.set_xlabel(\"Time of day\")\nax.set_ylabel(\"Day\")\nax.set_title(\"Time Slots Schedule (21college_2time_slot.csv)\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the matplotlib axes method `ax.barh()` to render the data, which draws horizontal bars. According to the taxonomy, horizontal layouts of bars are classified as 'Bar chart', while vertical ones are 'Column chart'. No specific color palette was defined."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21college_2time_slot.csv\"\ndf = pd.read_csv(csv_path)\n\n# Map day codes to ordered labels (College scheduling style)\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\nday_labels = {\"M\": \"Mon\", \"T\": \"Tue\", \"W\": \"Wed\", \"R\": \"Thu\", \"F\": \"Fri\"}\n\n# Create start/end times in minutes from midnight\ndf[\"start_minute\"] = df[\"start_hr\"] * 60 + df[\"start_min\"]\ndf[\"end_minute\"] = df[\"end_hr\"] * 60 + df[\"end_min\"]\ndf[\"duration\"] = df[\"end_minute\"] - df[\"start_minute\"]\n\n# Keep only expected days and order them\ndf = df[df[\"day\"].isin(day_order)].copy()\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\n\n# Sort for cleaner plotting\ndf = df.sort_values([\"day\", \"start_minute\", \"time_slot_id\"]).reset_index(drop=True)\n\n# Plot: single chart (weekly schedule / Gantt-like view)\nfig, ax = plt.subplots(figsize=(10, 5))\n\n# y positions for days\ny_pos = {d: i for i, d in enumerate(day_order)}\nbar_height = 0.8\n\nfor _, row in df.iterrows():\n    y = y_pos[row[\"day\"]]\n    ax.barh(\n        y=y,\n        width=row[\"duration\"],\n        left=row[\"start_minute\"],\n        height=bar_height,\n        edgecolor=\"black\",\n        linewidth=0.8,\n        alpha=0.9,\n        color=\"#4C78A8\",\n    )\n    # Label each block with time_slot_id\n    ax.text(\n        row[\"start_minute\"] + row[\"duration\"] / 2,\n        y,\n        str(row[\"time_slot_id\"]),\n        va=\"center\",\n        ha=\"center\",\n        color=\"white\",\n        fontsize=9,\n        fontweight=\"bold\",\n    )\n\n# Y-axis labels\nax.set_yticks([y_pos[d] for d in day_order])\nax.set_yticklabels([day_labels[d] for d in day_order])\n\n# X-axis ticks every hour from earliest start to latest end\nmin_start = int(df[\"start_minute\"].min())\nmax_end = int(df[\"end_minute\"].max())\nstart_hour = (min_start // 60)\nend_hour = (max_end + 59) // 60\n\nxticks = [h * 60 for h in range(start_hour, end_hour + 1)]\nax.set_xticks(xticks)\nax.set_xticklabels([f\"{h:02d}:00\" for h in range(start_hour, end_hour + 1)])\n\nax.set_xlim(start_hour * 60, end_hour * 60)\nax.set_xlabel(\"Time of day\")\nax.set_title(\"Time Slots by Day (21college_2time_slot.csv)\")\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is created using ax.barh(), which is a standard matplotlib function for horizontal bars. Although pandas is used for data manipulation, the rendering of data is done directly through matplotlib's axes object rather than the .plot() wrapper."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\n# Load data\ncsv_path = \"21college_2time_slot.csv\"\ndf = pd.read_csv(csv_path)\n\n# Map days to positions (top to bottom like a timetable)\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\nday_labels = {\"M\": \"Mon\", \"T\": \"Tue\", \"W\": \"Wed\", \"R\": \"Thu\", \"F\": \"Fri\"}\nday_to_y = {d: i for i, d in enumerate(day_order[::-1])}  # reverse so Mon is at top\n\n# Convert times to minutes since midnight\ndf[\"start_minute\"] = df[\"start_hr\"] * 60 + df[\"start_min\"]\ndf[\"end_minute\"] = df[\"end_hr\"] * 60 + df[\"end_min\"]\n\n# Figure\nplt.rcParams.update({\n    \"figure.dpi\": 140,\n    \"axes.titlesize\": 14,\n    \"axes.labelsize\": 11,\n    \"font.size\": 10\n})\nfig, ax = plt.subplots(figsize=(11, 4.8))\n\n# Color per time_slot_id\nslot_ids = sorted(df[\"time_slot_id\"].unique())\ncmap = plt.get_cmap(\"tab10\")\ncolors = {sid: cmap(i % 10) for i, sid in enumerate(slot_ids)}\n\n# Draw blocks (single chart)\nbar_h = 0.72\nfor _, r in df.iterrows():\n    y = day_to_y[r[\"day\"]]\n    x0 = r[\"start_minute\"]\n    w = r[\"end_minute\"] - r[\"start_minute\"]\n    ax.add_patch(\n        mpatches.Rectangle(\n            (x0, y - bar_h / 2),\n            w,\n            bar_h,\n            facecolor=colors[r[\"time_slot_id\"]],\n            edgecolor=\"white\",\n            linewidth=1.0,\n            alpha=0.95,\n        )\n    )\n    # Label inside block\n    ax.text(\n        x0 + w / 2,\n        y,\n        str(r[\"time_slot_id\"]),\n        ha=\"center\",\n        va=\"center\",\n        color=\"black\",\n        fontsize=10,\n        fontweight=\"bold\",\n    )\n\n# Axes formatting\nax.set_yticks([day_to_y[d] for d in day_order])\nax.set_yticklabels([day_labels[d] for d in day_order])\n\n# Time axis: 08:00 to 17:00 (covers all)\nxmin, xmax = 8 * 60, 17 * 60\nax.set_xlim(xmin, xmax)\n\nticks = list(range(xmin, xmax + 1, 60))\ntick_labels = [f\"{t//60:02d}:00\" for t in ticks]\nax.set_xticks(ticks)\nax.set_xticklabels(tick_labels)\n\n# Grid + styling\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\nax.set_xlabel(\"Time of day\")\nax.set_ylabel(\"Day\")\nax.set_title(\"College Time Slots (by Day and Time)\")\n\n# Legend\nhandles = [mpatches.Patch(color=colors[sid], label=f\"Slot {sid}\") for sid in slot_ids]\nax.legend(handles=handles, title=\"Time Slot ID\", ncol=min(4, len(handles)),\n          frameon=False, loc=\"upper center\", bbox_to_anchor=(0.5, -0.18))\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "tab10", "reasoning": "The code uses matplotlib's `ax.add_patch` with `mpatches.Rectangle` to draw horizontal blocks representing time intervals (start and end times) for categorical day values. Following the library hierarchy, it is classified as 'matplotlib' because it uses standard axes/patches functions to render data. Following the taxonomy distinction for bar orientation, the horizontal layout classifies this as a 'Bar chart'."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\n# Load data\ncsv_path = \"21college_2time_slot.csv\"\ndf = pd.read_csv(csv_path)\n\n# Map days to order and labels\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\nday_label = {\"M\": \"Mon\", \"T\": \"Tue\", \"W\": \"Wed\", \"R\": \"Thu\", \"F\": \"Fri\"}\ndf = df[df[\"day\"].isin(day_order)].copy()\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\ndf.sort_values([\"day\", \"start_hr\", \"start_min\", \"time_slot_id\"], inplace=True)\n\n# Time helpers\ndef to_minutes(h, m):\n    return int(h) * 60 + int(m)\n\ndf[\"start_minute\"] = df.apply(lambda r: to_minutes(r[\"start_hr\"], r[\"start_min\"]), axis=1)\ndf[\"end_minute\"] = df.apply(lambda r: to_minutes(r[\"end_hr\"], r[\"end_min\"]), axis=1)\ndf[\"duration\"] = df[\"end_minute\"] - df[\"start_minute\"]\n\n# Plot setup (single chart)\nplt.rcParams.update({\n    \"figure.dpi\": 140,\n    \"axes.spines.top\": False,\n    \"axes.spines.right\": False\n})\n\nfig, ax = plt.subplots(figsize=(10.5, 5.6))\n\n# Y positions per day\nypos = {d: i for i, d in enumerate(day_order)}\nbar_h = 0.72\n\n# Color by time_slot_id\nslot_ids = sorted(df[\"time_slot_id\"].unique())\ncmap = plt.get_cmap(\"tab20\")\ncolors = {sid: cmap(i % 20) for i, sid in enumerate(slot_ids)}\n\n# Draw blocks; if multiple slots on same day overlap, nudge vertically within the day band\nfor d in day_order:\n    sub = df[df[\"day\"] == d].copy()\n    if sub.empty:\n        continue\n\n    # Simple overlap layering: sort by start; assign lane if overlaps previous in that lane\n    lanes_end = []\n    lane_of_row = []\n\n    for _, r in sub.iterrows():\n        assigned = False\n        for li, endt in enumerate(lanes_end):\n            if r[\"start_minute\"] >= endt:\n                lanes_end[li] = r[\"end_minute\"]\n                lane_of_row.append(li)\n                assigned = True\n                break\n        if not assigned:\n            lanes_end.append(r[\"end_minute\"])\n            lane_of_row.append(len(lanes_end) - 1)\n\n    nlanes = max(lane_of_row) + 1 if lane_of_row else 1\n    for (idx, r), lane in zip(sub.iterrows(), lane_of_row):\n        # distribute lanes within the day band\n        lane_offset = (lane - (nlanes - 1) / 2) * (bar_h / max(nlanes, 1)) * 0.9\n        y = ypos[d] + lane_offset\n        h = (bar_h / max(nlanes, 1)) * 0.85\n\n        ax.broken_barh(\n            [(r[\"start_minute\"], r[\"duration\"])],\n            (y - h / 2, h),\n            facecolors=colors[r[\"time_slot_id\"]],\n            edgecolors=\"white\",\n            linewidth=1.0,\n            alpha=0.95,\n            zorder=3\n        )\n\n        # Label each block with its slot id\n        xmid = r[\"start_minute\"] + r[\"duration\"] / 2\n        ax.text(\n            xmid, y, str(r[\"time_slot_id\"]),\n            ha=\"center\", va=\"center\",\n            fontsize=9, color=\"black\", zorder=4\n        )\n\n# Axes formatting\nax.set_yticks([ypos[d] for d in day_order])\nax.set_yticklabels([day_label[d] for d in day_order])\nax.set_ylabel(\"Day\")\n\n# Time range\ntmin = df[\"start_minute\"].min()\ntmax = df[\"end_minute\"].max()\n\n# Pad to nice bounds\npad = 15\nxmin = (tmin // 30) * 30 - pad\nxmax = ((tmax + 29) // 30) * 30 + pad\nax.set_xlim(xmin, xmax)\n\n# X ticks every 30 minutes, formatted as HH:MM\nticks = list(range(int(xmin // 30) * 30, int(xmax // 30) * 30 + 1, 30))\ndef fmt_time(m):\n    h = (m // 60) % 24\n    mm = m % 60\n    return f\"{h:02d}:{mm:02d}\"\n\nax.set_xticks(ticks)\nax.set_xticklabels([fmt_time(t) for t in ticks], rotation=0)\nax.set_xlabel(\"Time of day\")\n\n# Grid\nax.grid(axis=\"x\", linestyle=\"--\", linewidth=0.7, alpha=0.35, zorder=0)\n\n# Title\nax.set_title(\"College Time Slots by Day (from 21college_2time_slot.csv)\")\n\n# Compact legend for slot IDs\nhandles = [mpatches.Patch(color=colors[s], label=s) for s in slot_ids]\nax.legend(\n    handles=handles, title=\"time_slot_id\",\n    ncols=min(8, len(handles)),\n    frameon=False, loc=\"upper center\", bbox_to_anchor=(0.5, -0.12)\n)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "tab20", "reasoning": "The visualization uses the matplotlib function `ax.broken_barh` to render horizontal segments for each day. In the provided taxonomy, horizontal bar-based representations are classified as 'Bar charts', whereas vertical ones are 'Column charts'. The library is 'matplotlib' because data rendering is performed directly through axes methods rather than seaborn or pandas wrappers."}}
{"input_csv_file": "21college_2time_slot.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21college_2time_slot.csv\"\ndf = pd.read_csv(csv_path)\n\n# Day order and labels\nday_order = [\"M\", \"T\", \"W\", \"R\", \"F\"]\nday_labels = {\"M\": \"Mon\", \"T\": \"Tue\", \"W\": \"Wed\", \"R\": \"Thu\", \"F\": \"Fri\"}\n\n# Convert to minutes-from-midnight for plotting\ndf[\"start\"] = df[\"start_hr\"] * 60 + df[\"start_min\"]\ndf[\"end\"] = df[\"end_hr\"] * 60 + df[\"end_min\"]\ndf[\"duration\"] = df[\"end\"] - df[\"start\"]\n\n# Ensure plotting order\ndf[\"day\"] = pd.Categorical(df[\"day\"], categories=day_order, ordered=True)\ndf = df.sort_values([\"day\", \"start\", \"time_slot_id\"]).reset_index(drop=True)\n\n# Y positions (top to bottom: Mon ... Fri)\ny_map = {d: i for i, d in enumerate(day_order)}\ndf[\"y\"] = df[\"day\"].map(y_map)\n\n# Figure\nfig, ax = plt.subplots(figsize=(11, 5))\n\n# Draw time blocks (Gantt-like)\nfor _, r in df.iterrows():\n    ax.barh(\n        y=r[\"y\"],\n        width=r[\"duration\"],\n        left=r[\"start\"],\n        height=0.55,\n        color=\"#4C78A8\",\n        alpha=0.85,\n        edgecolor=\"white\",\n        linewidth=1.0,\n    )\n    label = f'{r[\"time_slot_id\"]} ({r[\"start_hr\"]:02d}:{r[\"start_min\"]:02d}-{r[\"end_hr\"]:02d}:{r[\"end_min\"]:02d})'\n    ax.text(\n        r[\"start\"] + r[\"duration\"] / 2,\n        r[\"y\"],\n        label,\n        va=\"center\",\n        ha=\"center\",\n        fontsize=9,\n        color=\"white\",\n        weight=\"bold\",\n        clip_on=True,\n    )\n\n# Y axis: days\nax.set_yticks(range(len(day_order)))\nax.set_yticklabels([day_labels[d] for d in day_order])\nax.invert_yaxis()  # Monday at top\n\n# X axis: time of day\nxmin = df[\"start\"].min()\nxmax = df[\"end\"].max()\npad = 15\nax.set_xlim(max(0, xmin - pad), min(24 * 60, xmax + pad))\n\n# Tick every 30 minutes\nticks = list(range((ax.get_xlim()[0] // 30) * 30, int(ax.get_xlim()[1]) + 31, 30))\nticks = [t for t in ticks if 0 <= t <= 24 * 60]\nax.set_xticks(ticks)\nax.set_xticklabels([f\"{t//60:02d}:{t%60:02d}\" for t in ticks], rotation=0)\n\n# Styling\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.set_xlabel(\"Time of day\")\nax.set_ylabel(\"Day\")\nax.set_title(\"College Time Slots by Day (from 21college_2time_slot.csv)\")\n\nfor spine in [\"top\", \"right\"]:\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization is created using the `ax.barh()` function from the matplotlib library to render data. Because the bars are oriented horizontally and display a categorical variable (days) alongside quantitative variables (start time and duration), it fits the taxonomy definition of a Bar chart."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ncsv_path = \"21heatmapDataOrig.csv\"\ndf = pd.read_csv(csv_path)\n\n# Pivot into a grid for a heatmap: rows=A, cols=B, values=C\ngrid = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index().sort_index(axis=1)\n\n# Plot\nfig, ax = plt.subplots(figsize=(12, 3.2), constrained_layout=True)\nim = ax.imshow(grid.to_numpy(), aspect=\"auto\", cmap=\"viridis\", vmin=grid.min().min(), vmax=grid.max().max())\n\nax.set_title(\"Heatmap of C by (A, B)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\n# Ticks (show all A; show B every 5 to reduce clutter)\na_vals = grid.index.to_list()\nb_vals = grid.columns.to_list()\n\nax.set_yticks(np.arange(len(a_vals)))\nax.set_yticklabels(a_vals)\n\nstep = 5\nax.set_xticks(np.arange(0, len(b_vals), step))\nax.set_xticklabels([b_vals[i] for i in range(0, len(b_vals), step)])\n\ncbar = fig.colorbar(im, ax=ax, pad=0.02)\ncbar.set_label(\"C\")\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The data is rendered using the matplotlib axes function `ax.imshow()` to visualize a 2D grid of values (pivoted from categorical dimensions A and B with quantitative values C), which corresponds to the XY Heatmap chart definition."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21heatmapDataOrig.csv\")\n\n# Pivot into a grid for a heatmap (A = rows, B = columns, C = values)\ngrid = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index(axis=0).sort_index(axis=1)\n\n# Plot: single chart (heatmap)\nfig, ax = plt.subplots(figsize=(12, 3.5))\nim = ax.imshow(grid.values, aspect=\"auto\", cmap=\"viridis\", vmin=grid.values.min(), vmax=grid.values.max())\n\n# Axes labels and ticks\nax.set_title(\"Heatmap of C by A (rows) and B (columns)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\nax.set_xticks(range(grid.shape[1]))\nax.set_xticklabels(grid.columns.astype(int))\nax.set_yticks(range(grid.shape[0]))\nax.set_yticklabels(grid.index.astype(int))\n\n# Colorbar\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label(\"C\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The plot is created using the matplotlib axes method `ax.imshow()` to visualize a 2D grid (pivot table) where rows and columns represent categorical dimensions and the color represents a quantitative value, fitting the XY Heatmap chart definition. Matplotlib is identified as the library because the data is rendered directly through its axes API rather than a pandas or seaborn wrapper."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"21heatmapDataOrig.csv\")\n\n# Convert to a 2D grid for a heatmap (A = rows, B = columns, C = values)\nheat = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index().sort_index(axis=1)\n\n# Plot: single chart (heatmap)\nplt.figure(figsize=(14, 4.5))\nax = sns.heatmap(\n    heat,\n    cmap=\"viridis\",\n    vmin=0, vmax=100,\n    cbar_kws={\"label\": \"C (value)\"}\n)\n\nax.set_title(\"Heatmap of C by A (rows) and B (columns)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The code uses the seaborn function 'sns.heatmap()' to render the data, which takes priority over matplotlib and pandas according to the library classification rules. The taxonomy classifies a chart with two categorical dimensions and a quantitative value encoded by color as an 'XY Heatmap chart'."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21heatmapDataOrig.csv\"\ndf = pd.read_csv(csv_path)\n\n# Pivot to a grid for a heatmap (A = rows, B = columns, C = values)\ngrid = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index().sort_index(axis=1)\n\n# Plot (single chart)\nfig, ax = plt.subplots(figsize=(12, 3.2), constrained_layout=True)\nim = ax.imshow(grid.values, aspect=\"auto\", interpolation=\"nearest\", cmap=\"viridis\")\n\nax.set_title(\"Heatmap of C by A (rows) and B (columns)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\nax.set_xticks(range(grid.shape[1]))\nax.set_xticklabels(grid.columns)\nax.set_yticks(range(grid.shape[0]))\nax.set_yticklabels(grid.index)\n\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label(\"C\")\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The code renders data using the matplotlib axes method ax.imshow() to display a pivoted DataFrame where rows and columns represent categorical dimensions and the color encodes the quantitative value, which fits the definition of an XY Heatmap chart."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21heatmapDataOrig.csv\"\ndf = pd.read_csv(csv_path)\n\n# Pivot to matrix form for heatmap: rows=A, cols=B, values=C\nheat = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index().sort_index(axis=1)\n\n# Plot single heatmap chart\nfig, ax = plt.subplots(figsize=(12, 3.5), constrained_layout=True)\nim = ax.imshow(heat.values, aspect=\"auto\", interpolation=\"nearest\", cmap=\"viridis\")\n\nax.set_title(\"Heatmap of C by A (rows) and B (columns)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\nax.set_xticks(range(heat.shape[1]))\nax.set_xticklabels(heat.columns.tolist())\nax.set_yticks(range(heat.shape[0]))\nax.set_yticklabels(heat.index.tolist())\n\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label(\"C\")\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The visualization uses matplotlib's ax.imshow() to display quantitative values (C) mapped to two categorical dimensions (A and B), which constitutes an XY Heatmap. Since the plotting is done directly via matplotlib axes rather than pandas or seaborn wrappers, the library is classified as matplotlib."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ncsv_path = \"21heatmapDataOrig.csv\"\ndf = pd.read_csv(csv_path)\n\n# Pivot to matrix form for heatmap: A as rows, B as columns, C as values\nheat = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index(axis=0).sort_index(axis=1)\n\n# Plot single chart (heatmap)\nplt.figure(figsize=(14, 4))\nax = sns.heatmap(\n    heat,\n    cmap=\"viridis\",\n    vmin=0, vmax=100,\n    cbar=True,\n    linewidths=0.0\n)\n\nax.set_title(\"Heatmap of C by A (rows) and B (columns)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The code uses sns.heatmap() to draw the data, which classifies the library as seaborn. The chart visualizes two categorical variables (A and B) and one quantitative variable (C) using color, fitting the XY Heatmap chart taxonomy definition. The palette is explicitly set via the cmap='viridis' argument."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21heatmapDataOrig.csv\"\ndf = pd.read_csv(csv_path)\n\n# Pivot to matrix for heatmap (A as rows, B as columns, C as values)\nheat = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index().sort_index(axis=1)\n\n# Plot single heatmap chart\nfig, ax = plt.subplots(figsize=(12, 3.5), constrained_layout=True)\nim = ax.imshow(heat.values, aspect=\"auto\", interpolation=\"nearest\", cmap=\"viridis\")\n\nax.set_title(\"Heatmap of C by A (rows) and B (columns)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\nax.set_xticks(range(heat.shape[1]))\nax.set_xticklabels(heat.columns.astype(int))\nax.set_yticks(range(heat.shape[0]))\nax.set_yticklabels(heat.index.astype(int))\n\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label(\"C\")\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The code uses the matplotlib Axes method 'ax.imshow()' to render the quantitative data from a pivoted matrix where dimensions 'A' and 'B' act as categorical axes, which aligns with the XY Heatmap chart definition. Since the data is rendered via matplotlib directly rather than a pandas or seaborn wrapper, the library is identified as matplotlib."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    csv_path = \"21heatmapDataOrig.csv\"\n    df = pd.read_csv(csv_path)\n\n    # Pivot to matrix for heatmap: rows=A, cols=B, values=C\n    mat = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index().sort_index(axis=1)\n\n    fig, ax = plt.subplots(figsize=(12, 4.5))\n    im = ax.imshow(mat.values, aspect=\"auto\", cmap=\"viridis\", interpolation=\"nearest\")\n\n    ax.set_title(\"Heatmap of C by A (rows) and B (columns)\")\n    ax.set_xlabel(\"B\")\n    ax.set_ylabel(\"A\")\n\n    ax.set_xticks(range(mat.shape[1]))\n    ax.set_xticklabels(mat.columns.tolist())\n    ax.set_yticks(range(mat.shape[0]))\n    ax.set_yticklabels(mat.index.tolist())\n\n    cbar = fig.colorbar(im, ax=ax)\n    cbar.set_label(\"C\")\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The code uses ax.imshow() directly from the matplotlib library to render a matrix where two categorical dimensions (A and B) form the axes and a quantitative value (C) is encoded by color via the viridis colormap."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"21heatmapDataOrig.csv\")\n\n# Convertir formato largo (A,B,C) a matriz para heatmap\nheat = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index(axis=0).sort_index(axis=1)\n\n# Graficar (un solo chart)\nfig, ax = plt.subplots(figsize=(12, 3.5))\nim = ax.imshow(heat.values, aspect=\"auto\", interpolation=\"nearest\", cmap=\"viridis\")\n\nax.set_title(\"Heatmap de C por (A, B)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\nax.set_xticks(range(heat.shape[1]))\nax.set_xticklabels(heat.columns.astype(int))\nax.set_yticks(range(heat.shape[0]))\nax.set_yticklabels(heat.index.astype(int))\n\ncbar = fig.colorbar(im, ax=ax)\ncbar.set_label(\"C\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The visualization is drawn using matplotlib's ax.imshow() function directly. It encodes two categorical variables (A and B) and a quantitative variable (C) as colors in a grid, which matches the definition of an XY Heatmap chart."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21heatmapDataOrig.csv\")\n\n# Pivot into a matrix for heatmap: rows=A, cols=B, values=C\nheat = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index().sort_index(axis=1)\n\n# Ensure full rectangular grid (in case of missing combinations)\na_full = np.arange(df[\"A\"].min(), df[\"A\"].max() + 1)\nb_full = np.arange(df[\"B\"].min(), df[\"B\"].max() + 1)\nheat = heat.reindex(index=a_full, columns=b_full)\n\n# Plot (single chart)\nfig, ax = plt.subplots(figsize=(14, 3.6), dpi=150)\n\nim = ax.imshow(\n    heat.to_numpy(),\n    aspect=\"auto\",\n    interpolation=\"nearest\",\n    cmap=\"viridis\",\n    vmin=np.nanmin(heat.to_numpy()),\n    vmax=np.nanmax(heat.to_numpy()),\n)\n\ncbar = fig.colorbar(im, ax=ax, pad=0.02)\ncbar.set_label(\"C\", rotation=90)\n\nax.set_title(\"Heatmap of C by A (rows) and B (columns)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\n# Ticks\nax.set_xticks(np.arange(len(b_full)))\nax.set_xticklabels(b_full)\nax.set_yticks(np.arange(len(a_full)))\nax.set_yticklabels(a_full)\n\n# Light gridlines to emphasize cells\nax.set_xticks(np.arange(-0.5, len(b_full), 1), minor=True)\nax.set_yticks(np.arange(-0.5, len(a_full), 1), minor=True)\nax.grid(which=\"minor\", color=\"white\", linewidth=0.4, alpha=0.35)\nax.tick_params(which=\"minor\", bottom=False, left=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The code uses ax.imshow() from the Matplotlib library to visualize a 2D matrix (pivoted data) where values are encoded by color across two dimensions."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21heatmapDataOrig.csv\"\ndf = pd.read_csv(csv_path)\n\n# Pivot to matrix for heatmap (A as rows, B as columns, C as values)\nheat = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index().sort_index(axis=1)\n\n# Plot: single heatmap chart\nfig, ax = plt.subplots(figsize=(14, 3.8), constrained_layout=True)\nim = ax.imshow(heat.values, aspect=\"auto\", interpolation=\"nearest\", cmap=\"viridis\", vmin=0, vmax=100)\n\n# Axes formatting\nax.set_title(\"Heatmap of C by (A, B)\", pad=10)\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\n\n# Ticks\nax.set_xticks(range(heat.shape[1]))\nax.set_xticklabels(heat.columns.tolist())\nax.set_yticks(range(heat.shape[0]))\nax.set_yticklabels(heat.index.tolist())\n\n# Colorbar\ncbar = fig.colorbar(im, ax=ax, fraction=0.03, pad=0.02)\ncbar.set_label(\"C\")\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The code uses the Matplotlib library via `ax.imshow()` to visualize a pivoted matrix. The visualization represents two categorical dimensions (A and B) and a quantitative value (C) encoded by color, which fits the definition of an XY Heatmap chart."}}
{"input_csv_file": "21heatmapDataOrig.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ncsv_path = \"21heatmapDataOrig.csv\"\ndf = pd.read_csv(csv_path)\n\n# Pivot to matrix (A as rows, B as columns, C as values)\nheat = df.pivot(index=\"A\", columns=\"B\", values=\"C\").sort_index().sort_index(axis=1)\n\n# Plot\nsns.set_theme(style=\"white\")\nfig, ax = plt.subplots(figsize=(14, 3.8), constrained_layout=True)\n\nsns.heatmap(\n    heat,\n    ax=ax,\n    cmap=\"viridis\",\n    vmin=0, vmax=100,\n    linewidths=0.3,\n    linecolor=(1, 1, 1, 0.15),\n    cbar_kws={\"label\": \"C (0–100)\", \"shrink\": 0.9, \"pad\": 0.02},\n)\n\nax.set_title(\"Heatmap of C by A (rows) and B (columns)\")\nax.set_xlabel(\"B\")\nax.set_ylabel(\"A\")\nax.set_xticks(range(0, heat.shape[1], 2))\nax.set_xticklabels([str(x) for x in range(0, heat.shape[1], 2)], rotation=0)\nax.set_yticklabels(ax.get_yticklabels(), rotation=0)\n\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "XY Heatmap chart", "color_palette": "viridis", "reasoning": "The plot is created using sns.heatmap(), which falls under the seaborn library. The visualization displays a grid of two categorical variables (A and B) with values (C) encoded by color, matching the XY Heatmap chart definition."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21us_cities.csv\")\n\n# Aggregate population by region\nregion_pop = (\n    df.groupby(\"region\", as_index=True)[\"pop_max\"]\n    .sum()\n    .sort_values(ascending=False)\n)\n\n# Single chart: total population by region\nplt.figure(figsize=(9, 5))\nax = region_pop.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\", linewidth=0.6)\n\nax.set_title(\"Total Pop_max by Region (21 US Cities)\")\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Total population (pop_max)\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n# Add value labels\nfor p in ax.patches:\n    val = int(p.get_height())\n    ax.annotate(\n        f\"{val:,}\",\n        (p.get_x() + p.get_width() / 2, p.get_height()),\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n        xytext=(0, 3),\n        textcoords=\"offset points\",\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas .plot(kind='bar') method. In the provided taxonomy, vertical bars (the default for kind='bar') are classified as a Column chart."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21us_cities.csv\")\n\n# Aggregate: total population by region\nregion_pop = (\n    df.groupby(\"region\", as_index=True)[\"pop_max\"]\n      .sum()\n      .sort_values(ascending=False)\n)\n\n# Plot: one clear chart (Curcio \"read the data\" friendly)\nfig, ax = plt.subplots(figsize=(9, 5))\nregion_pop.plot(kind=\"bar\", ax=ax, color=\"#4C78A8\", edgecolor=\"black\")\n\nax.set_title(\"Total Population (pop_max) by U.S. Region (55 cities)\")\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Total pop_max\")\nax.tick_params(axis=\"x\", rotation=0)\n\n# Add value labels\nfor i, v in enumerate(region_pop.values):\n    ax.text(i, v, f\"{v:,}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, even if matplotlib is used for formatting, the use of pandas' plotting wrapper identifies the library as 'pandas'. Since the bars are vertical (the default for 'bar'), it is classified as a Column chart."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21us_cities.csv\")\n\n# Aggregate: total population by region\nregion_pop = (\n    df.groupby(\"region\", as_index=False)[\"pop_max\"]\n      .sum()\n      .sort_values(\"pop_max\", ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(9, 5))\nplt.bar(region_pop[\"region\"], region_pop[\"pop_max\"], color=\"#4C78A8\")\nplt.title(\"Total Population (pop_max) by U.S. Region\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Total pop_max\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly from the matplotlib.pyplot library to render the data. Because standard plt.bar draws vertical bars, it is classified as a Column chart."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21us_cities.csv\")\n\n# Aggregate: total population by region\nregion_pop = (\n    df.groupby(\"region\", as_index=False)[\"pop_max\"]\n    .sum()\n    .sort_values(\"pop_max\", ascending=False)\n)\n\n# Plot: single chart (bar chart)\nplt.figure(figsize=(9, 5))\nplt.bar(region_pop[\"region\"], region_pop[\"pop_max\"], color=\"#4C78A8\")\nplt.title(\"Total Maximum Population by U.S. Region (55 Cities)\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Total pop_max\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, which identifies the library as matplotlib. Since plt.bar() creates vertical bars, it is classified as a Column chart according to the provided taxonomy."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21us_cities.csv\")\n\n# Aggregate population by region\nregion_pop = df.groupby(\"region\", as_index=True)[\"pop_max\"].sum().sort_values(ascending=False)\n\n# Plot: Total population by region\nplt.figure(figsize=(9, 5.2))\nax = region_pop.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\", linewidth=0.6)\n\nax.set_title(\"Total City Population (pop_max) by U.S. Region\")\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Total pop_max\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is generated using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, even though matplotlib is used for styling, the data rendering call via pandas makes the library 'pandas'. Since the bars are vertical (default 'bar'), it is classified as a Column chart."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"21us_cities.csv\")\n\n    region_stats = (\n        df.groupby(\"region\", as_index=False)\n          .agg(total_population=(\"pop_max\", \"sum\"))\n          .sort_values(\"total_population\", ascending=False)\n    )\n\n    plt.style.use(\"seaborn-v0_8-whitegrid\")\n    fig, ax = plt.subplots(figsize=(9, 5.2))\n\n    ax.bar(region_stats[\"region\"], region_stats[\"total_population\"], color=\"#4C78A8\")\n    ax.set_title(\"Total Population by Region (21 US Cities Dataset)\")\n    ax.set_xlabel(\"Region\")\n    ax.set_ylabel(\"Total population (sum of pop_max)\")\n\n    ax.ticklabel_format(axis=\"y\", style=\"plain\")\n    ax.set_ylim(0, region_stats[\"total_population\"].max() * 1.12)\n\n    for i, v in enumerate(region_stats[\"total_population\"]):\n        ax.text(i, v, f\"{v:,}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\n    fig.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is generated using the matplotlib Axes method `ax.bar()`, which renders vertical bars by default. Per the taxonomy and hierarchy rules, vertical bars are classified as a 'Column chart' and the library is 'matplotlib' since no seaborn or pandas plotting wrappers were used to draw the data."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"21us_cities.csv\")\n    df[\"region\"] = df[\"region\"].astype(str)\n\n    region_stats = (\n        df.groupby(\"region\", as_index=True)[\"pop_max\"]\n        .sum()\n        .sort_values(ascending=False)\n    )\n\n    fig, ax = plt.subplots(figsize=(9, 5))\n    bars = ax.bar(region_stats.index, region_stats.values, color=\"#4C78A8\")\n\n    ax.set_title(\"Total Maximum Population by Region (21us_cities.csv)\")\n    ax.set_xlabel(\"Region\")\n    ax.set_ylabel(\"Total pop_max\")\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n    ax.bar_label(bars, labels=[f\"{v:,.0f}\" for v in region_stats.values], padding=3, fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.bar()` function to render vertical bars mapping a categorical variable (region) to a quantitative variable (pop_max). Since the bars are vertical and created using the standard matplotlib axes function, it is classified as a Column chart."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"21us_cities.csv\")\n\n    # Aggregate by region\n    region_stats = (\n        df.groupby(\"region\")\n          .agg(total_population=(\"pop_max\", \"sum\"), cities=(\"name\", \"count\"))\n          .sort_values(\"total_population\", ascending=False)\n    )\n\n    # Single chart: total population by region\n    fig, ax = plt.subplots(figsize=(9, 5))\n    region_stats[\"total_population\"].plot(kind=\"bar\", ax=ax, color=\"#4C78A8\", edgecolor=\"black\")\n\n    ax.set_title(\"Total Population (pop_max) by US Region\")\n    ax.set_xlabel(\"Region\")\n    ax.set_ylabel(\"Total pop_max\")\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\n    # Annotate bars with city counts\n    for i, (region, row) in enumerate(region_stats.iterrows()):\n        ax.text(i, row[\"total_population\"], f'{int(row[\"cities\"])} cities',\n                ha=\"center\", va=\"bottom\", fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is generated using the pandas Series plotting method (`.plot(kind='bar')`). Since the resulting bars are oriented vertically, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21us_cities.csv\")\n\n# Aggregate by region: total population\nregion_pop = (\n    df.groupby(\"region\", as_index=True)[\"pop_max\"]\n    .sum()\n    .sort_values(ascending=False)\n)\n\n# Plot (single chart)\nplt.figure(figsize=(9, 5))\nax = region_pop.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nax.set_title(\"Población total (pop_max) por región - 21us_cities.csv\")\nax.set_xlabel(\"Región\")\nax.set_ylabel(\"Población total (suma de pop_max)\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is generated using the pandas plotting wrapper `region_pop.plot(kind='bar')`. According to the hierarchy rules, even though matplotlib is used for styling, the rendering method makes it 'pandas'. Since the bars are vertical (default for kind='bar'), it is classified as a 'Column chart'."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21us_cities.csv\")\n\n# Aggregate by region\nregion_pop = (\n    df.groupby(\"region\", as_index=False)[\"pop_max\"]\n      .sum()\n      .sort_values(\"pop_max\", ascending=True)\n)\n\n# Plot: total population by region\nplt.figure(figsize=(9.5, 5.5))\nbars = plt.barh(region_pop[\"region\"], region_pop[\"pop_max\"], color=\"#3B82F6\")\n\n# Labels on bars\nfor bar, val in zip(bars, region_pop[\"pop_max\"]):\n    plt.text(\n        val, bar.get_y() + bar.get_height() / 2,\n        f\" {val:,}\",\n        va=\"center\", ha=\"left\", fontsize=10, color=\"#111827\"\n    )\n\nplt.title(\"Total Population (pop_max) by U.S. Region (55 Cities)\", fontsize=13)\nplt.xlabel(\"Total population (sum of pop_max)\")\nplt.ylabel(\"Region\")\nplt.grid(axis=\"x\", linestyle=\"--\", linewidth=0.7, alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the 'plt.barh()' function from matplotlib to render the data directly, which creates horizontal bars. Per the taxonomy, horizontal bars are classified as a 'Bar chart' and vertical ones as a 'Column chart'. Because matplotlib functions are used instead of pandas or seaborn plot wrappers, the library is identified as 'matplotlib'."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"21us_cities.csv\"\ndf = pd.read_csv(csv_path)\n\n# Prepare styling\nregions = [\"West\", \"Midwest\", \"South\", \"Northeast\"]\ncolors = {\n    \"West\": \"#1f77b4\",\n    \"Midwest\": \"#ff7f0e\",\n    \"South\": \"#2ca02c\",\n    \"Northeast\": \"#d62728\",\n}\n\ndf[\"region\"] = pd.Categorical(df[\"region\"], categories=regions, ordered=True)\n\n# Bubble sizes: proportional to population, but visually stable\np = df[\"pop_max\"].astype(float)\nsizes = 30 + 900 * ((p - p.min()) / (p.max() - p.min() + 1e-9)) ** 0.9\n\n# Figure\nplt.rcParams.update({\n    \"figure.dpi\": 140,\n    \"axes.titleweight\": \"semibold\",\n    \"axes.labelcolor\": \"#333333\",\n    \"xtick.color\": \"#444444\",\n    \"ytick.color\": \"#444444\",\n    \"axes.edgecolor\": \"#DDDDDD\",\n})\n\nfig, ax = plt.subplots(figsize=(10.6, 6.2))\n\n# Plot by region to control legend\nfor r in regions:\n    dfr = df[df[\"region\"] == r]\n    ax.scatter(\n        dfr[\"longitude\"],\n        dfr[\"latitude\"],\n        s=sizes[dfr.index],\n        c=colors[r],\n        alpha=0.78,\n        edgecolor=\"white\",\n        linewidth=0.7,\n        label=r,\n        zorder=3,\n    )\n\n# Annotate a few largest cities for context\ntop = df.nlargest(10, \"pop_max\").copy()\nfor _, row in top.iterrows():\n    ax.text(\n        row[\"longitude\"] + 0.6,\n        row[\"latitude\"] + 0.3,\n        row[\"name\"],\n        fontsize=8.5,\n        color=\"#222222\",\n        ha=\"left\",\n        va=\"center\",\n        zorder=4,\n    )\n\n# Axes, grid, and layout\nax.set_title(\"US Cities in 21us_cities.csv — Location and Population (Bubble Size)\")\nax.set_xlabel(\"Longitude\")\nax.set_ylabel(\"Latitude\")\nax.grid(True, which=\"major\", color=\"#EAEAEA\", linewidth=1.0, zorder=0)\nax.set_axisbelow(True)\n\n# Make bounds a bit roomy\npad_lon = 2.5\npad_lat = 1.5\nax.set_xlim(df[\"longitude\"].min() - pad_lon, df[\"longitude\"].max() + pad_lon)\nax.set_ylim(df[\"latitude\"].min() - pad_lat, df[\"latitude\"].max() + pad_lat)\n\n# Legend\nleg = ax.legend(\n    title=\"Region\",\n    loc=\"upper left\",\n    frameon=True,\n    facecolor=\"white\",\n    edgecolor=\"#DDDDDD\",\n)\nleg._legend_box.align = \"left\"\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The code uses the matplotlib `ax.scatter()` method to render data. It plots two quantitative variables (longitude and latitude) on the axes and uses a third quantitative variable (population, represented by 'sizes') to modulate the size of the markers, which defines a bubble chart."}}
{"input_csv_file": "21us_cities.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"21us_cities.csv\")\n\n# Prepare styling\ndf = df.copy()\ndf[\"pop_millions\"] = df[\"pop_max\"] / 1_000_000\n\nregion_order = [\"West\", \"Midwest\", \"South\", \"Northeast\"]\nregion_colors = {\n    \"West\": \"#1f77b4\",\n    \"Midwest\": \"#ff7f0e\",\n    \"South\": \"#2ca02c\",\n    \"Northeast\": \"#d62728\",\n}\n\n# Bubble sizes (area in points^2)\nmin_s, max_s = 30, 1400\npmin, pmax = df[\"pop_max\"].min(), df[\"pop_max\"].max()\ndf[\"size\"] = min_s + (df[\"pop_max\"] - pmin) / (pmax - pmin) * (max_s - min_s)\n\n# Figure\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6.5), dpi=140)\n\n# Plot each region for clean legend\nfor region in region_order:\n    sub = df[df[\"region\"] == region]\n    if sub.empty:\n        continue\n    ax.scatter(\n        sub[\"longitude\"],\n        sub[\"latitude\"],\n        s=sub[\"size\"],\n        c=region_colors.get(region, \"#777777\"),\n        alpha=0.65,\n        edgecolors=\"white\",\n        linewidths=0.7,\n        label=region,\n    )\n\n# Annotate a handful of largest cities\ntop = df.nlargest(8, \"pop_max\").copy()\nfor _, r in top.iterrows():\n    ax.annotate(\n        r[\"name\"],\n        (r[\"longitude\"], r[\"latitude\"]),\n        xytext=(6, 6),\n        textcoords=\"offset points\",\n        fontsize=9,\n        color=\"#222222\",\n        ha=\"left\",\n        va=\"bottom\",\n        bbox=dict(boxstyle=\"round,pad=0.2\", fc=\"white\", ec=\"none\", alpha=0.75),\n    )\n\n# Axes formatting\nax.set_title(\"US Cities (Sample): Locations and Population (bubble size)\", pad=12, fontsize=14)\nax.set_xlabel(\"Longitude\")\nax.set_ylabel(\"Latitude\")\nax.set_xlim(df[\"longitude\"].min() - 5, df[\"longitude\"].max() + 5)\nax.set_ylim(df[\"latitude\"].min() - 2, df[\"latitude\"].max() + 2)\n\n# Legend for regions\nleg1 = ax.legend(title=\"Region\", loc=\"upper left\", frameon=True)\nleg1.get_frame().set_alpha(0.92)\n\n# Bubble size legend (population)\nsizes_for_legend = [100_000, 500_000, 1_000_000, 2_000_000]\nhandles = []\nlabels = []\nfor p in sizes_for_legend:\n    s = min_s + (p - pmin) / (pmax - pmin) * (max_s - min_s)\n    handles.append(ax.scatter([], [], s=s, c=\"#999999\", alpha=0.6, edgecolors=\"white\", linewidths=0.7))\n    labels.append(f\"{p/1_000_000:.1f}M\")\n\nleg2 = ax.legend(\n    handles,\n    labels,\n    title=\"Population\",\n    loc=\"lower left\",\n    frameon=True,\n    labelspacing=1.2,\n    borderpad=0.8,\n)\nleg2.get_frame().set_alpha(0.92)\nax.add_artist(leg1)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.scatter() to plot longitude and latitude as the spatial dimensions, while modulating the marker size (s) based on population values, which fits the definition of a bubble chart. The library is classified as matplotlib because the data is rendered using axes methods rather than pandas or seaborn wrappers."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Parse opening year and extract year\ndf[\"openning_year\"] = pd.to_datetime(df[\"openning_year\"], errors=\"coerce\")\ndf[\"year\"] = df[\"openning_year\"].dt.year\n\n# Aggregate: total capacity opened per year\ncap_by_year = (\n    df.groupby(\"year\", dropna=False)[\"capacity\"]\n    .sum()\n    .sort_index()\n)\n\n# Plot (single chart)\nplt.figure(figsize=(8, 4.5))\nplt.plot(cap_by_year.index, cap_by_year.values, marker=\"o\", linewidth=2)\nplt.title(\"Total Cinema Capacity Opened per Year\")\nplt.xlabel(\"Opening Year\")\nplt.ylabel(\"Total Capacity\")\nplt.xticks(cap_by_year.index)\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses plt.plot() to render quantitative values (capacity) against temporal values (years), which fits the Line chart definition. The plotting function used is directly from the pyplot module of matplotlib."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Ensure capacity is numeric\ndf[\"capacity\"] = pd.to_numeric(df[\"capacity\"], errors=\"coerce\")\n\n# Sort for clearer viewing\ndf_sorted = df.sort_values(\"capacity\", ascending=False)\n\n# Single chart: Capacity by cinema\nplt.figure(figsize=(10, 5))\nplt.bar(df_sorted[\"name\"], df_sorted[\"capacity\"], color=\"#4C78A8\")\nplt.title(\"Cinema Capacity by Cinema\")\nplt.xlabel(\"Cinema\")\nplt.ylabel(\"Capacity (seats)\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() to render the data as vertical bars, which according to the taxonomy is a Column chart. The library is matplotlib because it uses the plt.bar() function directly rather than seaborn or pandas wrappers."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Clean/parse opening year (handles odd timestamp-like strings)\ndf[\"openning_year\"] = pd.to_datetime(df[\"openning_year\"], errors=\"coerce\")\ndf[\"year\"] = df[\"openning_year\"].dt.year\n\n# Aggregate: total capacity by location (simple, clear comparison)\ncapacity_by_location = (\n    df.groupby(\"location\", as_index=True)[\"capacity\"]\n      .sum()\n      .sort_values(ascending=False)\n)\n\n# Plot (single chart)\nplt.figure(figsize=(10, 5))\ncapacity_by_location.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Total Cinema Capacity by Location\")\nplt.xlabel(\"Location\")\nplt.ylabel(\"Total Capacity (seats)\")\nplt.xticks(rotation=35, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas Series .plot() method with kind='bar'. According to the hierarchy rules, even if matplotlib is used for styling, the data-drawing call determines the library as 'pandas'. Since the bars are vertical (the default for kind='bar'), it is classified as a 'Column chart' rather than a 'Bar chart'."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Convert the odd timestamp-like year strings to a numeric year (e.g., 2010)\n# Example: \"1970-01-01 00:00:00.000002010\" -> \"2010\"\ndf[\"openning_year\"] = (\n    df[\"openning_year\"].astype(str).str.extract(r\"(\\d{4})$\", expand=False).astype(int)\n)\n\n# Aggregate: number of cinemas opened each year\nopened_per_year = df.groupby(\"openning_year\")[\"cinema_id\"].count().sort_index()\n\n# Plot (single chart)\nplt.figure(figsize=(8, 4.5))\nopened_per_year.plot(kind=\"bar\", color=\"#4C78A8\")\nplt.title(\"Cinemas Opened per Year\")\nplt.xlabel(\"Opening Year\")\nplt.ylabel(\"Number of Cinemas\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is generated using the pandas Series plotting wrapper 'opened_per_year.plot(kind=\"bar\")'. Although matplotlib is used for styling (title, labels), the rendering call belongs to pandas. The 'kind=\"bar\"' parameter in pandas defaults to vertical bars, which maps to 'Column chart' in the taxonomy."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Parse year from the odd timestamp-like strings in openning_year\n# Example: \"1970-01-01 00:00:00.000002010\" -> year 2010\ndf[\"year\"] = pd.to_numeric(df[\"openning_year\"].astype(str).str.extract(r\"(\\d{4})$\")[0], errors=\"coerce\")\n\n# Aggregate: total capacity by location\ncap_by_location = (\n    df.groupby(\"location\", as_index=True)[\"capacity\"]\n      .sum()\n      .sort_values(ascending=True)\n)\n\n# Plot: single chart (horizontal bar)\nplt.figure(figsize=(10, 5.5))\ncap_by_location.plot(kind=\"barh\", color=\"#4C78A8\")\nplt.title(\"Total Cinema Capacity by Location\")\nplt.xlabel(\"Total Capacity (seats)\")\nplt.ylabel(\"Location\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is generated using the pandas .plot() method on a Series object with kind='barh', which renders horizontal bars. Per the hierarchy rules, even though matplotlib.pyplot is used for styling, the data rendering via .plot() classifies the library as pandas."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Parse the weird-looking datetime strings and extract year\ndf[\"openning_year\"] = pd.to_datetime(df[\"openning_year\"], errors=\"coerce\")\ndf[\"year\"] = df[\"openning_year\"].dt.year\n\n# Aggregate: total capacity by opening year\nyear_capacity = (\n    df.groupby(\"year\", dropna=True)[\"capacity\"]\n    .sum()\n    .sort_index()\n)\n\n# Plot: single chart\nplt.figure(figsize=(9, 5))\nplt.bar(year_capacity.index.astype(int), year_capacity.values, color=\"#4C78A8\")\nplt.title(\"Total Cinema Capacity by Opening Year\")\nplt.xlabel(\"Opening Year\")\nplt.ylabel(\"Total Capacity\")\nplt.xticks(year_capacity.index.astype(int), rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using 'plt.bar()', which is the standard matplotlib function for creating vertical bars. According to the taxonomy, vertical bars are classified as a Column chart. Although a specific hex color (#4C78A8) is provided, no named color palette was used."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Parse year from the odd datetime-like strings in 'openning_year'\ndf[\"openning_year\"] = pd.to_datetime(df[\"openning_year\"], errors=\"coerce\").dt.year\n\n# Aggregate: average capacity by opening year\ng = (\n    df.dropna(subset=[\"openning_year\"])\n      .groupby(\"openning_year\", as_index=True)[\"capacity\"]\n      .mean()\n      .sort_index()\n)\n\n# Plot (single chart)\nplt.figure(figsize=(8, 4.5))\nplt.plot(g.index, g.values, marker=\"o\", linewidth=2)\nplt.title(\"Average Cinema Capacity by Opening Year\")\nplt.xlabel(\"Opening Year\")\nplt.ylabel(\"Average Capacity (seats)\")\nplt.xticks(g.index.astype(int))\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered directly using matplotlib's plt.plot() function rather than a pandas or seaborn wrapper. The visualization maps a temporal dimension (opening year) to a quantitative dimension (average capacity), fitting the Line chart definition."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef parse_year(val):\n    s = str(val)\n    for token in s.split():\n        if token.isdigit() and len(token) == 4:\n            return int(token)\n    return pd.to_datetime(s, errors=\"coerce\").year\n\ndf = pd.read_csv(\"2cinema.csv\")\n\ndf[\"year\"] = df[\"openning_year\"].apply(parse_year)\n\nyear_capacity = (\n    df.groupby(\"year\", as_index=False)[\"capacity\"]\n    .sum()\n    .sort_values(\"year\")\n)\n\nplt.figure(figsize=(8, 4.5))\nplt.plot(year_capacity[\"year\"], year_capacity[\"capacity\"], marker=\"o\", linewidth=2)\nplt.title(\"Total Cinema Capacity by Opening Year\")\nplt.xlabel(\"Opening Year\")\nplt.ylabel(\"Total Capacity\")\nplt.xticks(year_capacity[\"year\"])\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using the standard plt.plot() function from the matplotlib library. It displays temporal/ordered data (years) on the X-axis against a quantitative variable (capacity) on the Y-axis, which classifies it as a Line chart."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Extraer el año desde el formato extraño (p.ej. 1970-01-01 00:00:00.000002010 -> 2010)\ndf[\"openning_year\"] = df[\"openning_year\"].astype(str)\ndf[\"year\"] = df[\"openning_year\"].str.extract(r\"(\\d{4})\\s*$\")[0].astype(int)\n\n# Agrupar capacidad total por año de apertura\ncap_by_year = df.groupby(\"year\", as_index=True)[\"capacity\"].sum().sort_index()\n\n# Gráfico (una sola figura)\nplt.figure(figsize=(9, 5))\nplt.plot(cap_by_year.index, cap_by_year.values, marker=\"o\")\nplt.title(\"Capacidad total de cines por año de apertura\")\nplt.xlabel(\"Año de apertura\")\nplt.ylabel(\"Capacidad total\")\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib pyplot function `plt.plot()` to render the quantitative variable 'capacity' against the temporal variable 'year', which corresponds to the Line chart definition in the taxonomy."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Parse opening year (handles the odd timestamp-like strings) and extract year\ndf[\"openning_year\"] = pd.to_datetime(df[\"openning_year\"], errors=\"coerce\")\ndf[\"year\"] = df[\"openning_year\"].dt.year\n\n# Aggregate: total capacity by location\ncap_by_loc = (\n    df.groupby(\"location\", as_index=True)[\"capacity\"]\n    .sum()\n    .sort_values(ascending=True)\n)\n\n# Plot: horizontal bar chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\nbars = ax.barh(cap_by_loc.index, cap_by_loc.values, color=\"#2b8cbe\")\n\nax.set_title(\"Total Cinema Capacity by Location\", pad=12)\nax.set_xlabel(\"Total seats (capacity)\")\nax.set_ylabel(\"Location\")\n\n# Value labels\nfor b in bars:\n    w = b.get_width()\n    ax.text(w + max(cap_by_loc.values) * 0.01, b.get_y() + b.get_height() / 2,\n            f\"{int(w)}\", va=\"center\", ha=\"left\", fontsize=9)\n\nax.set_xlim(0, max(cap_by_loc.values) * 1.12)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the matplotlib library's `ax.barh()` method to render horizontal bars representing a categorical variable (location) and a quantitative variable (capacity). Following the taxonomy, horizontal bars are classified as a 'Bar chart'."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Parse year from the odd datetime-like strings in openning_year\ndf[\"openning_year\"] = pd.to_datetime(df[\"openning_year\"], errors=\"coerce\")\ndf[\"year\"] = df[\"openning_year\"].dt.year\n\n# Aggregate: total capacity opened per year\nby_year = (\n    df.groupby(\"year\", dropna=False)[\"capacity\"]\n      .sum()\n      .sort_index()\n      .reset_index()\n)\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 4.8))\n\nax.bar(by_year[\"year\"].astype(int), by_year[\"capacity\"], color=\"#2E86AB\", edgecolor=\"#1B4F72\", linewidth=0.8)\n\nax.set_title(\"Total Cinema Seating Capacity by Opening Year\", pad=10)\nax.set_xlabel(\"Opening Year\")\nax.set_ylabel(\"Total Capacity (seats)\")\n\nax.set_xticks(by_year[\"year\"].astype(int))\nax.set_xticklabels(by_year[\"year\"].astype(int), rotation=0)\n\n# Value labels\nfor x, y in zip(by_year[\"year\"].astype(int), by_year[\"capacity\"]):\n    ax.text(x, y, f\"{int(y)}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is rendered using the matplotlib ax.bar() function directly. Since ax.bar() produces vertical bars by default, it is classified as a Column chart."}}
{"input_csv_file": "2cinema.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2cinema.csv\")\n\n# Parse year from the quirky datetime-like string format\ndt = pd.to_datetime(df[\"openning_year\"], errors=\"coerce\")\nyear = dt.dt.year.copy()\n\n# If parsing fails (NaT), extract trailing 4 digits as year (e.g., ...000002010 -> 2010)\nmask = year.isna()\nif mask.any():\n    year.loc[mask] = (\n        df.loc[mask, \"openning_year\"]\n        .astype(str)\n        .str.extract(r\"(\\d{4})\\s*$\")[0]\n        .astype(float)\n    )\n\ndf[\"year\"] = year.astype(\"Int64\")\n\n# Aggregate capacity by opening year\nagg = (\n    df.dropna(subset=[\"year\"])\n      .groupby(\"year\", as_index=False)[\"capacity\"]\n      .sum()\n      .sort_values(\"year\")\n)\n\n# Plot: Total cinema capacity by opening year\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 4.8))\n\nax.bar(agg[\"year\"].astype(int).astype(str), agg[\"capacity\"], color=\"#2C7FB8\")\n\nax.set_title(\"Total Cinema Capacity by Opening Year\")\nax.set_xlabel(\"Opening Year\")\nax.set_ylabel(\"Total Capacity (seats)\")\n\n# Value labels\nfor i, v in enumerate(agg[\"capacity\"].values):\n    ax.text(i, v, f\"{int(v):,}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nax.margins(y=0.12)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is rendered using the 'ax.bar()' method which draws vertical bars, classifying it as a Column chart. The library is matplotlib because the data is drawn directly using pyplot/axes functions rather than seaborn or pandas plotting wrappers."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(csv_path)\n\n# Prepare data: count cards by type\ncounts = df[\"card_type_code\"].value_counts().sort_index()\n\n# Plot: single chart\nplt.figure(figsize=(7, 4.5))\nbars = plt.bar(counts.index.astype(str), counts.values, color=[\"#4C78A8\", \"#F58518\"][: len(counts)])\n\nplt.title(\"Number of Cards by Card Type\")\nplt.xlabel(\"Card Type\")\nplt.ylabel(\"Count of Cards\")\n\n# Add value labels\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h + 0.05, f\"{int(h)}\", ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function `plt.bar()` to draw vertical bars, which classifies it as a Column chart under the taxonomy and identifies the library as matplotlib."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(csv_path)\n\n# Simple summary: count of cards by type (Credit vs Debit)\ncounts = df[\"card_type_code\"].value_counts().sort_index()\n\n# Plot (single chart)\nplt.figure(figsize=(7, 4))\nbars = plt.bar(counts.index, counts.values, color=[\"#4C78A8\", \"#F58518\"])\nplt.title(\"Number of Cards by Card Type\")\nplt.xlabel(\"Card Type\")\nplt.ylabel(\"Count of Cards\")\n\n# Add value labels\nfor b in bars:\n    y = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, y, f\"{int(y)}\", ha=\"center\", va=\"bottom\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using plt.bar() directly, which identifies the library as matplotlib. Since the bars are vertical and map a categorical variable (card type) to a quantitative one (count), it is classified as a Column chart per the taxonomy."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\npath = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(path)\n\n# Simple summary: number of cards by type\ncounts = df[\"card_type_code\"].value_counts().sort_index()\n\n# Plot (single chart)\nplt.figure(figsize=(7, 4))\nbars = plt.bar(counts.index, counts.values, color=[\"#4C78A8\", \"#F58518\"])\nplt.title(\"Number of Cards by Card Type\")\nplt.xlabel(\"Card Type\")\nplt.ylabel(\"Count of Cards\")\n\n# Label values on bars\nfor b in bars:\n    plt.text(b.get_x() + b.get_width() / 2, b.get_height() + 0.05, str(int(b.get_height())),\n             ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.ylim(0, counts.max() + 2)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using plt.bar() directly rather than pandas or seaborn methods, and the bars are vertical, classifying it as a Column chart."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\npath = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(path)\n\n# Prepare data: count cards by type\ncounts = df[\"card_type_code\"].value_counts().sort_index()\n\n# Plot: single chart (bar)\nplt.figure(figsize=(7, 4.5))\nbars = plt.bar(counts.index, counts.values, color=[\"#4C78A8\", \"#F58518\"][: len(counts)])\n\nplt.title(\"Number of Cards by Card Type\")\nplt.xlabel(\"Card Type\")\nplt.ylabel(\"Count of Cards\")\n\n# Add value labels\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h + 0.05, f\"{int(h)}\", ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.ylim(0, max(counts.values) + 1.5)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code utilizes plt.bar() directly to render data, which according to the hierarchy rules classifies the library as 'matplotlib'. Because plt.bar() creates vertical bars, it is classified as a 'Column chart' per the provided taxonomy. No named palette (e.g., 'viridis') was used, only specific hex codes."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\npath = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(path)\n\n# Prepare dates\ndf[\"date_valid_from\"] = pd.to_datetime(df[\"date_valid_from\"], errors=\"coerce\")\ndf[\"date_valid_to\"] = pd.to_datetime(df[\"date_valid_to\"], errors=\"coerce\")\n\n# Compute validity duration in days\ndf[\"validity_days\"] = (df[\"date_valid_to\"] - df[\"date_valid_from\"]).dt.total_seconds() / 86400.0\n\n# Aggregate: average validity by card type\nsummary = (\n    df.dropna(subset=[\"validity_days\", \"card_type_code\"])\n      .groupby(\"card_type_code\")[\"validity_days\"]\n      .mean()\n      .sort_values(ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(7, 4))\nax = summary.plot(kind=\"bar\", color=[\"#4C78A8\"] * len(summary))\nax.set_title(\"Average Card Validity Duration by Card Type\")\nax.set_xlabel(\"Card Type\")\nax.set_ylabel(\"Average Validity (days)\")\nax.tick_params(axis=\"x\", rotation=0)\n\n# Add value labels\nfor i, v in enumerate(summary.values):\n    ax.text(i, v, f\"{v:,.0f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using the pandas DataFrame/Series plot method `summary.plot(kind='bar')`. According to the hierarchy rules, even though matplotlib is used for styling, the rendering method classifies the library as 'pandas'. The resulting bars are vertical, which classifies it as a 'Column chart' per the taxonomy definitions."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\npath = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(path)\n\n# One chart: count of cards by type\ncounts = df[\"card_type_code\"].value_counts().sort_index()\n\nplt.figure(figsize=(7, 4))\ncounts.plot(kind=\"bar\", color=[\"#4C78A8\", \"#F58518\"])\nplt.title(\"Number of Cards by Card Type\")\nplt.xlabel(\"Card Type\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data visualization is rendered using the pandas Series `.plot()` method with kind='bar'. According to the library hierarchy, the use of pandas' plotting wrapper identifies the library as 'pandas' despite the use of matplotlib for styling. Because kind='bar' produces vertical bars by default, it is classified as a 'Column chart' under the provided taxonomy."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\npath = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(path)\n\n# Parse dates\ndf[\"date_valid_from\"] = pd.to_datetime(df[\"date_valid_from\"], errors=\"coerce\")\ndf[\"date_valid_to\"] = pd.to_datetime(df[\"date_valid_to\"], errors=\"coerce\")\n\n# Card validity duration in days\ndf[\"valid_days\"] = (df[\"date_valid_to\"] - df[\"date_valid_from\"]).dt.total_seconds() / 86400.0\ndf = df.dropna(subset=[\"valid_days\", \"card_type_code\"])\n\n# Aggregate: average validity by card type\nsummary = (\n    df.groupby(\"card_type_code\", as_index=False)[\"valid_days\"]\n      .mean()\n      .sort_values(\"valid_days\", ascending=False)\n)\n\n# Plot (single chart)\nplt.figure(figsize=(7, 4))\nplt.bar(summary[\"card_type_code\"], summary[\"valid_days\"], color=[\"#4C78A8\", \"#F58518\"][: len(summary)])\nplt.title(\"Average Card Validity Duration by Card Type\")\nplt.xlabel(\"Card Type\")\nplt.ylabel(\"Average Validity (days)\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using 'plt.bar()', which is a direct matplotlib function for rendering vertical bars, classifying it as a Column chart. Although pandas is used for data manipulation, the rendering logic is handled by matplotlib. Manual hex colors were provided instead of a named palette."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\npath = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(path)\n\n# Parse dates\ndf[\"date_valid_from\"] = pd.to_datetime(df[\"date_valid_from\"], errors=\"coerce\")\ndf[\"date_valid_to\"] = pd.to_datetime(df[\"date_valid_to\"], errors=\"coerce\")\n\n# Compute card validity duration in days\ndf[\"validity_days\"] = (df[\"date_valid_to\"] - df[\"date_valid_from\"]).dt.total_seconds() / 86400.0\ndf = df.dropna(subset=[\"validity_days\", \"card_type_code\"])\n\n# Aggregate: average validity by card type\navg_validity = (\n    df.groupby(\"card_type_code\")[\"validity_days\"]\n    .mean()\n    .sort_values(ascending=False)\n)\n\n# Plot single chart\nplt.figure(figsize=(8, 4.8))\nax = avg_validity.plot(kind=\"bar\", color=[\"#4C78A8\", \"#F58518\"][: len(avg_validity)])\nax.set_title(\"Average Card Validity Duration by Card Type\")\nax.set_xlabel(\"Card Type\")\nax.set_ylabel(\"Average Validity (days)\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is generated using the pandas Series method `avg_validity.plot(kind='bar')`. According to the hierarchy rules, if the data is rendered via the .plot() method on a pandas object, the library is 'pandas'. Since kind='bar' produces vertical bars by default, it is classified as a Column chart."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Archivo CSV\ncsv_path = \"2customers_card_transactions@Customers_Cards.csv\"\n\n# Cargar datos\ndf = pd.read_csv(csv_path)\n\n# Preparar fechas y métrica: duración de validez de la tarjeta (en días)\ndf[\"date_valid_from\"] = pd.to_datetime(df[\"date_valid_from\"], errors=\"coerce\")\ndf[\"date_valid_to\"] = pd.to_datetime(df[\"date_valid_to\"], errors=\"coerce\")\ndf[\"validity_days\"] = (df[\"date_valid_to\"] - df[\"date_valid_from\"]).dt.days\n\n# Agrupar por tipo de tarjeta\nsummary = (\n    df.groupby(\"card_type_code\", dropna=False)[\"validity_days\"]\n      .mean()\n      .sort_values(ascending=False)\n)\n\n# Gráfico (una sola figura)\nplt.figure(figsize=(8, 4.5))\nax = summary.plot(kind=\"bar\", color=[\"#4C78A8\", \"#F58518\"])\nax.set_title(\"Duración promedio de validez (días) por tipo de tarjeta\")\nax.set_xlabel(\"Tipo de tarjeta\")\nax.set_ylabel(\"Días (promedio)\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using the pandas '.plot(kind=\"bar\")' method on a Series object. Even though matplotlib is used for styling, the data rendering is handled by pandas. In the provided taxonomy, vertical bars are classified as a 'Column chart'."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MaxNLocator\n\n# Load data\ncsv_path = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(csv_path)\n\n# Parse dates and compute validity duration in days\ndf[\"date_valid_from\"] = pd.to_datetime(df[\"date_valid_from\"], errors=\"coerce\")\ndf[\"date_valid_to\"] = pd.to_datetime(df[\"date_valid_to\"], errors=\"coerce\")\ndf[\"validity_days\"] = (df[\"date_valid_to\"] - df[\"date_valid_from\"]).dt.total_seconds() / 86400.0\n\n# Aggregate: average validity duration by card type\nsummary = (\n    df.dropna(subset=[\"validity_days\", \"card_type_code\"])\n      .groupby(\"card_type_code\", as_index=False)[\"validity_days\"]\n      .mean()\n      .sort_values(\"validity_days\", ascending=False)\n)\n\n# Plot: single chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5))\n\nbars = ax.bar(summary[\"card_type_code\"], summary[\"validity_days\"], color=[\"#4C78A8\", \"#F58518\"][:len(summary)])\n\nax.set_title(\"Average Card Validity Duration by Card Type\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Card Type\")\nax.set_ylabel(\"Average Validity (days)\")\nax.yaxis.set_major_locator(MaxNLocator(integer=True))\n\n# Value labels\nfor b in bars:\n    h = b.get_height()\n    ax.annotate(f\"{h:,.0f}\",\n                xy=(b.get_x() + b.get_width()/2, h),\n                xytext=(0, 6),\n                textcoords=\"offset points\",\n                ha=\"center\", va=\"bottom\", fontsize=10)\n\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses `ax.bar()` to render data, which is a standard matplotlib function. Since the bars are oriented vertically, it is classified as a 'Column chart' according to the taxonomy."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\npath = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(path)\n\n# Parse dates and compute card validity duration (days)\ndf[\"date_valid_from\"] = pd.to_datetime(df[\"date_valid_from\"], errors=\"coerce\")\ndf[\"date_valid_to\"] = pd.to_datetime(df[\"date_valid_to\"], errors=\"coerce\")\ndf[\"validity_days\"] = (df[\"date_valid_to\"] - df[\"date_valid_from\"]).dt.total_seconds() / 86400.0\n\n# Aggregate: average validity duration by card type\nagg = (\n    df.dropna(subset=[\"validity_days\"])\n      .groupby(\"card_type_code\", as_index=True)[\"validity_days\"]\n      .mean()\n      .sort_values(ascending=False)\n)\n\n# Plot: single chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(8.5, 4.8), dpi=140)\n\nbars = ax.bar(agg.index.astype(str), agg.values, color=[\"#4C78A8\" if i % 2 == 0 else \"#F58518\" for i in range(len(agg))])\n\nax.set_title(\"Average Card Validity Duration by Card Type\", pad=10)\nax.set_xlabel(\"Card Type\")\nax.set_ylabel(\"Average Validity (days)\")\n\n# Value labels\nfor b in bars:\n    h = b.get_height()\n    ax.text(b.get_x() + b.get_width() / 2, h, f\"{h:,.0f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nax.margins(y=0.12)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using ax.bar(), which is a standard matplotlib Axes method. Since the bars are vertical, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "2customers_card_transactions@Customers_Cards.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\npath = \"2customers_card_transactions@Customers_Cards.csv\"\ndf = pd.read_csv(path)\n\n# Parse dates and compute card validity duration (days)\ndf[\"date_valid_from\"] = pd.to_datetime(df[\"date_valid_from\"], errors=\"coerce\")\ndf[\"date_valid_to\"] = pd.to_datetime(df[\"date_valid_to\"], errors=\"coerce\")\ndf[\"valid_days\"] = (df[\"date_valid_to\"] - df[\"date_valid_from\"]).dt.total_seconds() / 86400.0\n\n# Aggregate: average validity duration by card type\nsummary = (\n    df.dropna(subset=[\"valid_days\"])\n      .groupby(\"card_type_code\", as_index=False)[\"valid_days\"]\n      .mean()\n      .sort_values(\"valid_days\", ascending=True)\n)\n\n# Plot: single chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(8.5, 4.8))\n\nax.barh(summary[\"card_type_code\"], summary[\"valid_days\"], color=\"#2F6BFF\", alpha=0.9)\nax.set_title(\"Average Card Validity Duration by Card Type\", pad=10, fontsize=13, weight=\"bold\")\nax.set_xlabel(\"Average validity (days)\")\nax.set_ylabel(\"Card type\")\n\n# Annotate values\nfor y, v in enumerate(summary[\"valid_days\"]):\n    ax.text(v, y, f\"  {v:,.0f}\", va=\"center\", ha=\"left\", fontsize=10, color=\"#1a1a1a\")\n\nax.margins(x=0.08)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses ax.barh() from the matplotlib library to render horizontal bars, which corresponds to the 'Bar chart' definition in the taxonomy."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Parse the year from the unusual datetime-like string in start_year\ndf[\"start_year\"] = pd.to_datetime(df[\"start_year\"], errors=\"coerce\")\ndf[\"year\"] = df[\"start_year\"].dt.year\n\n# Count clubs per region\ncounts = df[\"region\"].value_counts().sort_values(ascending=True)\n\n# Plot (single chart)\nplt.figure(figsize=(8, 4.5))\ncounts.plot(kind=\"barh\", color=\"#4C78A8\")\nplt.title(\"Number of Clubs by Region\")\nplt.xlabel(\"Number of Clubs\")\nplt.ylabel(\"Region\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The data is rendered using the pandas Series plotting method .plot(kind='barh'), which classifies the library as 'pandas'. Because 'barh' produces horizontal bars, the chart type is classified as a 'Bar chart' per the taxonomy."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Convert start_year to a proper datetime, then extract the year\ndf[\"start_year\"] = pd.to_datetime(df[\"start_year\"], errors=\"coerce\")\ndf[\"start_year_year\"] = df[\"start_year\"].dt.year\n\n# Count clubs by region\nregion_counts = df[\"region\"].value_counts().sort_values(ascending=False)\n\n# Plot: number of clubs per region\nplt.figure(figsize=(8, 4.5))\nregion_counts.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Number of Riding Clubs by Region\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Number of Clubs\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, if the data is rendered via a pandas plotting method, the library is classified as 'pandas' regardless of matplotlib usage for styling. Since the resulting bars are vertical, it is classified as a Column chart.", "source_code": "region_counts.plot(kind='bar', color='#4C78A8', edgecolor='black')"}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Convert start_year to a real datetime and extract year\ndf[\"start_year\"] = pd.to_datetime(df[\"start_year\"], errors=\"coerce\")\ndf[\"start_year\"] = df[\"start_year\"].dt.year\n\n# Count clubs per region\nregion_counts = df[\"region\"].value_counts().sort_values(ascending=False)\n\n# Single chart: bar chart of number of clubs by region\nplt.figure(figsize=(8, 4.5))\nregion_counts.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Number of Riding Clubs by Region\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Number of Clubs\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using the pandas '.plot()' method on a Series (region_counts.plot). Per the hierarchy rules, even though matplotlib is used for styling, the data rendering method makes it 'pandas'. The chart uses vertical bars (kind='bar'), which corresponds to the 'Column chart' definition in the taxonomy."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Parse the weird timestamp-like strings in start_year and extract the year\ndf[\"start_year\"] = pd.to_datetime(df[\"start_year\"], errors=\"coerce\").dt.year\n\n# Count clubs by region\nregion_counts = df[\"region\"].value_counts().sort_values(ascending=False)\n\n# Single chart: number of clubs per region\nplt.figure(figsize=(8, 4))\nregion_counts.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Number of Riding Clubs by Region\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Number of Clubs\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the .plot(kind='bar') method on a pandas Series. Per the hierarchy rules, even though matplotlib is used for styling, the rendering method makes the library 'pandas'. Since the bars are vertical (default for kind='bar'), it is classified as a Column chart."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Parse the strange datetime-like strings and extract year\ndf[\"start_year_dt\"] = pd.to_datetime(df[\"start_year\"], errors=\"coerce\")\ndf[\"start_year_num\"] = df[\"start_year_dt\"].dt.year\n\n# Fallback: if parsing failed, try extracting a 4-digit year from the string\nmask = df[\"start_year_num\"].isna()\nif mask.any():\n    df.loc[mask, \"start_year_num\"] = (\n        df.loc[mask, \"start_year\"].astype(str).str.extract(r\"(\\d{4})\")[0].astype(float)\n    )\n\n# Aggregate: count clubs by region\nregion_counts = df[\"region\"].value_counts().sort_values(ascending=False)\n\n# Single chart\nplt.figure(figsize=(8, 4.5))\nregion_counts.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Number of Riding Clubs by Region\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Club Count\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the .plot(kind='bar') method on a pandas Series object, which classifies the library as pandas despite matplotlib being used for styling. In pandas, kind='bar' defaults to vertical bars, which the taxonomy defines as a Column chart."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Parse start_year values like \"1970-01-01 ... 2009\" into a year number\ndt = pd.to_datetime(df[\"start_year\"], errors=\"coerce\")\nyear_from_datetime = dt.dt.year\n\n# If some values fail to parse, fall back to extracting the last 4-digit year from the string\nyear_from_regex = (\n    df[\"start_year\"].astype(str).str.extract(r\"(\\d{4})$\", expand=False).astype(\"float\")\n)\n\ndf[\"start_year_num\"] = year_from_datetime.fillna(year_from_regex).astype(int)\n\n# Aggregate: number of clubs by region\nregion_counts = df[\"region\"].value_counts().sort_values(ascending=False)\n\n# Plot: single chart\nplt.figure(figsize=(8, 4.5))\nax = region_counts.plot(kind=\"bar\", color=\"#4C78A8\")\nax.set_title(\"Number of Riding Clubs by Region\")\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Club Count\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the pandas plotting wrapper `region_counts.plot(kind='bar')` to render the data. In the provided taxonomy, vertical bars (the default for `kind='bar'`) are classified as a 'Column chart'."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Parse start_year into a usable year (handles the odd timestamp-like strings)\ndf[\"start_year_parsed\"] = pd.to_datetime(df[\"start_year\"], errors=\"coerce\")\ndf[\"start_year_numeric\"] = df[\"start_year_parsed\"].dt.year\n\n# Fallback: if parsing fails, extract a 4-digit year from the string\nmask = df[\"start_year_numeric\"].isna()\nif mask.any():\n    extracted = df.loc[mask, \"start_year\"].astype(str).str.extract(r\"(\\d{4})\")[0]\n    df.loc[mask, \"start_year_numeric\"] = pd.to_numeric(extracted, errors=\"coerce\")\n\ndf[\"start_year_numeric\"] = df[\"start_year_numeric\"].astype(\"Int64\")\n\n# Aggregate: count clubs per region\nregion_counts = df[\"region\"].value_counts().sort_values(ascending=False)\n\n# Plot: single chart\nplt.figure(figsize=(8, 4.5))\nregion_counts.plot(kind=\"bar\", color=\"#4C78A8\")\nplt.title(\"Number of Clubs by Region\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Club Count\")\nplt.xticks(rotation=0)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the .plot(kind='bar') method from the pandas library. According to the taxonomy, vertical bars are classified as a Column chart, and while matplotlib.pyplot is used for styling and labels, the core rendering function identifies the library as pandas."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport re\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Extract year from the weird datetime-like string in start_year\ndef extract_year(x):\n    s = str(x)\n    m = re.search(r'(\\d{4})\\s*$', s)\n    if m:\n        return int(m.group(1))\n    m = re.search(r'(\\d{4})', s)\n    return int(m.group(1)) if m else None\n\ndf[\"year\"] = df[\"start_year\"].apply(extract_year)\ndf = df.dropna(subset=[\"year\"])\n\n# Count clubs by region\ncounts = df[\"region\"].value_counts().sort_values(ascending=False)\n\n# Single chart: bar chart of club counts by region\nplt.figure(figsize=(8, 4.5))\ncounts.plot(kind=\"bar\", color=\"#4C78A8\")\nplt.title(\"Number of Riding Clubs by Region\")\nplt.xlabel(\"Region\")\nplt.ylabel(\"Club count\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using the pandas .plot() method on a Series (counts.plot). Although kind='bar' is specified, this produces vertical bars by default in pandas, which corresponds to 'Column chart' in the provided taxonomy."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar el CSV\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Convertir start_year (que viene como string raro) a año numérico\ndf[\"start_year\"] = pd.to_datetime(df[\"start_year\"], errors=\"coerce\")\ndf[\"year\"] = df[\"start_year\"].dt.year\n\n# Preparar datos: año promedio por región (con 1 club por región aquí, será el mismo año)\nregion_year = (\n    df.groupby(\"region\", as_index=False)[\"year\"]\n    .mean()\n    .sort_values(\"year\")\n)\n\n# Gráfico (un solo chart)\nplt.figure(figsize=(9, 5))\nplt.bar(region_year[\"region\"], region_year[\"year\"], color=\"#4C78A8\")\nplt.title(\"Año de inicio promedio por región (2riding_club.csv)\")\nplt.xlabel(\"Región\")\nplt.ylabel(\"Año de inicio (promedio)\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using plt.bar(), which generates vertical bars, categorizing it as a Column chart according to the taxonomy. Since standard pyplot functions are used to render the data directly, the library is classified as matplotlib."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Parse start_year (handles weird timestamp strings by extracting a 4-digit year)\ndf[\"start_year\"] = df[\"start_year\"].astype(str)\ndf[\"year\"] = pd.to_numeric(df[\"start_year\"].str.extract(r\"(\\d{4})\")[0], errors=\"coerce\")\n\n# Aggregate: count clubs by region\nregion_counts = (\n    df.groupby(\"region\", dropna=False)[\"club_id\"]\n    .count()\n    .sort_values(ascending=False)\n)\n\n# Plot: single chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5))\n\nbars = ax.bar(region_counts.index.astype(str), region_counts.values, color=\"#4C78A8\")\nax.set_title(\"Number of Riding Clubs by Region\", pad=12)\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Number of Clubs\")\n\n# Value labels\nfor b in bars:\n    ax.text(\n        b.get_x() + b.get_width() / 2,\n        b.get_height(),\n        f\"{int(b.get_height())}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=10\n    )\n\n# Optional note if year parsing had issues (kept minimal, doesn't add extra chart)\nif df[\"year\"].isna().any():\n    ax.text(\n        0.99, 0.01,\n        \"Note: Some start_year values couldn't be parsed into a year.\",\n        transform=ax.transAxes,\n        ha=\"right\",\n        va=\"bottom\",\n        fontsize=8,\n        color=\"gray\"\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using ax.bar(), which is a standard matplotlib function for rendering vertical bars. Since it uses categorical labels on the x-axis and quantitative counts on the y-axis in a vertical orientation, it is classified as a Column chart."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Parse start_year (values look like full timestamps with embedded year at the end)\ndt = pd.to_datetime(df[\"start_year\"], errors=\"coerce\")\nyears = dt.dt.year\n\n# If parsing fails (NaT) for any rows, fall back to extracting the last 4-digit year in the string\nmask_bad = years.isna()\nif mask_bad.any():\n    extracted = (\n        df.loc[mask_bad, \"start_year\"]\n        .astype(str)\n        .str.extract(r\"(\\d{4})\", expand=False)\n        .astype(float)\n    )\n    years.loc[mask_bad] = extracted\n\ndf[\"year\"] = years.astype(\"Int64\")\n\n# Aggregate: number of clubs by region\nregion_counts = (\n    df.groupby(\"region\", dropna=False)[\"club_id\"]\n    .count()\n    .sort_values(ascending=False)\n)\n\n# Plot: bar chart (single chart)\nfig, ax = plt.subplots(figsize=(8.5, 4.8))\nbars = ax.bar(region_counts.index.astype(str), region_counts.values, color=\"#2C7FB8\")\n\nax.set_title(\"Number of Riding Clubs by Region\", pad=10)\nax.set_xlabel(\"Region\")\nax.set_ylabel(\"Club count\")\nax.yaxis.set_major_locator(mtick.MaxNLocator(integer=True))\nax.grid(axis=\"y\", linestyle=\"--\", linewidth=0.7, alpha=0.35)\n\n# Annotate bars\nfor b in bars:\n    h = b.get_height()\n    ax.text(\n        b.get_x() + b.get_width() / 2,\n        h,\n        f\"{int(h)}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=10\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the `ax.bar()` function from matplotlib. Since the bars are vertical and represent a categorical variable against a quantitative one, it is classified as a Column chart."}}
{"input_csv_file": "2riding_club.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"2riding_club.csv\")\n\n# Parse the quirky timestamp-like strings and extract the year\ndt = pd.to_datetime(df[\"start_year\"], errors=\"coerce\")\ndf[\"start_year_parsed\"] = dt.dt.year\n\n# Count clubs by region\nregion_counts = (\n    df[\"region\"]\n    .fillna(\"Unknown\")\n    .astype(str)\n    .value_counts()\n    .sort_values(ascending=True)\n)\n\n# Plot: horizontal bar chart of club counts by region\nfig, ax = plt.subplots(figsize=(8, 4.5))\nax.barh(region_counts.index, region_counts.values, color=\"#4C78A8\")\n\nax.set_title(\"Riding Clubs by Region (Count)\")\nax.set_xlabel(\"Number of Clubs\")\nax.set_ylabel(\"Region\")\n\n# Add value labels\nfor y, v in enumerate(region_counts.values):\n    ax.text(v + 0.03, y, str(v), va=\"center\", ha=\"left\", fontsize=10)\n\nax.set_xlim(0, max(region_counts.values) + 1)\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the matplotlib axes method `ax.barh()` to render the data. According to the taxonomy, horizontal bars are classified as a 'Bar chart', and since standard matplotlib functions are used directly rather than a pandas or seaborn wrapper, the library is classified as 'matplotlib'."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"3college_Student.csv\")\n\n    # Count students by city_code\n    city_counts = df[\"city_code\"].value_counts().sort_values(ascending=False)\n\n    plt.style.use(\"seaborn-v0_8-whitegrid\")\n    fig, ax = plt.subplots(figsize=(10, 5))\n\n    ax.bar(city_counts.index, city_counts.values, color=\"#4C78A8\")\n    ax.set_title(\"Number of Students by City Code\")\n    ax.set_xlabel(\"City Code\")\n    ax.set_ylabel(\"Student Count\")\n    ax.tick_params(axis=\"x\", rotation=45)\n\n    for i, v in enumerate(city_counts.values):\n        ax.text(i, v + 0.05, str(v), ha=\"center\", va=\"bottom\", fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using ax.bar(), which is a standard matplotlib function. The bars are vertical, which classifies it as a 'Column chart' according to the taxonomy."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3college_Student.csv\")\n\n# Simple \"read the data\" chart: count of students by city_code\ncounts = df[\"city_code\"].value_counts().sort_values(ascending=False)\n\nplt.figure(figsize=(10, 5))\ncounts.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Number of Students by City Code\")\nplt.xlabel(\"City Code\")\nplt.ylabel(\"Number of Students\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is generated using the .plot(kind='bar') method on a pandas Series object ('counts'). According to the hierarchy rules, even though matplotlib is used for styling, the use of pandas' built-in plotting wrapper classifies the library as 'pandas'. Since pandas 'bar' plots are vertical by default, it is classified as a 'Column chart' per the taxonomy."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3college_Student.csv\")\n\n# Count students by sex\ncounts = df[\"sex\"].value_counts().reindex([\"F\", \"M\"]).fillna(0).astype(int)\n\n# Plot: simple bar chart (good for \"read the data\" level)\nplt.figure(figsize=(6, 4))\nbars = plt.bar(counts.index, counts.values, color=[\"#4C78A8\", \"#F58518\"])\n\nplt.title(\"Number of Students by Sex\")\nplt.xlabel(\"Sex\")\nplt.ylabel(\"Number of Students\")\nplt.ylim(0, counts.max() + 2)\n\n# Add count labels on bars\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h + 0.1, f\"{int(h)}\", ha=\"center\", va=\"bottom\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is generated using the standard plt.bar() function for vertical bars, which classifies it as a Column chart and identifies the library as matplotlib."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3college_Student.csv\")\n\n# Basic summary for a \"read the data\" level: count students by sex\nsex_counts = df[\"sex\"].value_counts().reindex([\"F\", \"M\"])\n\n# Plot (single chart)\nplt.figure(figsize=(6, 4))\nbars = plt.bar(sex_counts.index, sex_counts.values, color=[\"#4C78A8\", \"#F58518\"])\nplt.title(\"Number of Students by Sex\")\nplt.xlabel(\"Sex\")\nplt.ylabel(\"Number of Students\")\n\n# Add count labels on bars\nfor b in bars:\n    plt.text(\n        b.get_x() + b.get_width() / 2,\n        b.get_height(),\n        f\"{int(b.get_height())}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=10,\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() to render vertical bars directly, which corresponds to the 'Column chart' category in the taxonomy. Since the data is plotted using the standard matplotlib.pyplot interface rather than pandas.plot() or seaborn, the library is classified as matplotlib."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"3college_Student.csv\")\n\n    major_counts = df[\"major\"].value_counts().sort_index()\n\n    fig, ax = plt.subplots(figsize=(9, 5))\n    ax.bar(major_counts.index.astype(str), major_counts.values, color=\"#4C78A8\")\n    ax.set_title(\"Number of Students by Major Code\")\n    ax.set_xlabel(\"Major Code\")\n    ax.set_ylabel(\"Student Count\")\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C78A8", "reasoning": "The code uses the ax.bar() method directly from matplotlib to render vertical bars, which classifies as a Column chart. The data represents a categorical variable (major code) and a quantitative variable (count)."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"3college_Student.csv\")\n\n    # Count students by city_code\n    city_counts = (\n        df[\"city_code\"]\n        .astype(str)\n        .str.strip()\n        .value_counts()\n        .sort_values(ascending=False)\n    )\n\n    plt.figure(figsize=(10, 5))\n    plt.bar(city_counts.index, city_counts.values, color=\"#4C78A8\")\n    plt.title(\"Number of Students by City Code\")\n    plt.xlabel(\"City Code\")\n    plt.ylabel(\"Number of Students\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C78A8", "reasoning": "The code uses plt.bar() to render the data directly, which signifies matplotlib according to the hierarchy. Because plt.bar() produces vertical bars, it is classified as a Column chart."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"3college_Student.csv\")\n\n# One chart: count of students by city_code (sorted descending)\ncity_counts = df[\"city_code\"].value_counts().sort_values(ascending=False)\n\nplt.figure(figsize=(10, 5))\ncity_counts.plot(kind=\"bar\", color=\"#4C72B0\")\nplt.title(\"Number of Students by City Code\")\nplt.xlabel(\"City Code\")\nplt.ylabel(\"Student Count\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, even though matplotlib is used for styling, the rendering method makes the library 'pandas'. Since the bars are vertical (standard 'bar' kind), it is classified as a Column chart."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"3college_Student.csv\")\n\n    sex_counts = df[\"sex\"].value_counts().reindex([\"F\", \"M\"]).fillna(0).astype(int)\n\n    fig, ax = plt.subplots(figsize=(7, 4.5))\n    ax.bar(sex_counts.index, sex_counts.values, color=[\"#4C78A8\", \"#F58518\"])\n\n    ax.set_title(\"Student Count by Sex\")\n    ax.set_xlabel(\"Sex\")\n    ax.set_ylabel(\"Number of Students\")\n\n    for i, v in enumerate(sex_counts.values):\n        ax.text(i, v + 0.2, str(v), ha=\"center\", va=\"bottom\", fontsize=10)\n\n    ax.set_ylim(0, max(sex_counts.values) + 3)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the `ax.bar()` function from the matplotlib library to render vertical bars representing student counts for discrete categories ('F' and 'M')."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"3college_Student.csv\")\n\n# Conteo de estudiantes por ciudad\ncity_counts = df[\"city_code\"].value_counts().sort_values(ascending=False)\n\n# Gráfico (un solo chart)\nplt.figure(figsize=(10, 5))\nplt.bar(city_counts.index, city_counts.values, color=\"#4C78A8\")\nplt.title(\"Número de estudiantes por city_code\")\nplt.xlabel(\"city_code\")\nplt.ylabel(\"Cantidad de estudiantes\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using plt.bar() directly, which belongs to the matplotlib library. According to the taxonomy, standard vertical bars created with plt.bar are classified as a Column chart."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3college_Student.csv\")\n\n# Prepare: student counts by major and sex\ncounts = (\n    df.groupby([\"major\", \"sex\"])\n      .size()\n      .unstack(fill_value=0)\n      .sort_index()\n)\n\n# Ensure consistent column order (F then M if present)\ncols = [c for c in [\"F\", \"M\"] if c in counts.columns]\ncounts = counts[cols]\n\n# Plot: stacked bar chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\nx = counts.index.astype(str)\nbottom = None\ncolors = {\"F\": \"#4C78A8\", \"M\": \"#F58518\"}\n\nfor sex in counts.columns:\n    ax.bar(\n        x,\n        counts[sex].values,\n        bottom=bottom,\n        label=sex,\n        color=colors.get(sex, None),\n        edgecolor=\"white\",\n        linewidth=0.8,\n    )\n    bottom = counts[sex].values if bottom is None else bottom + counts[sex].values\n\nax.set_title(\"Student Count by Major (stacked by Sex)\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Major Code\")\nax.set_ylabel(\"Number of Students\")\nax.legend(title=\"Sex\", frameon=True)\nax.margins(x=0.02)\nax.set_axisbelow(True)\n\n# Subtle annotation: totals on top of each bar\ntotals = counts.sum(axis=1).values\nfor i, total in enumerate(totals):\n    ax.text(i, total + 0.05, str(int(total)), ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.bar()` function directly to draw vertical bars. The bars are stacked by iterating through categories and calculating the `bottom` offset, which classifies it as a Stacked column chart."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3college_Student.csv\")\n\n# Ensure clean types\ndf[\"age\"] = pd.to_numeric(df[\"age\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"age\", \"sex\"])\n\n# Aggregate: age distribution by sex (single chart, grouped bars)\nbins = [15, 18, 21, 24, 27, 30]\nlabels = [\"16–18\", \"19–21\", \"22–24\", \"25–27\", \"28–30\"]\ndf[\"age_group\"] = pd.cut(df[\"age\"], bins=bins, labels=labels, include_lowest=True, right=True)\n\ncounts = (\n    df.groupby([\"age_group\", \"sex\"], observed=True)\n      .size()\n      .unstack(\"sex\", fill_value=0)\n)\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\ncounts.plot(kind=\"bar\", ax=ax, width=0.85, color={\"F\": \"#4C78A8\", \"M\": \"#F58518\"})\n\nax.set_title(\"Student Count by Age Group and Sex\", pad=12)\nax.set_xlabel(\"Age group\")\nax.set_ylabel(\"Number of students\")\nax.legend(title=\"Sex\", frameon=True, loc=\"upper right\")\n\n# Value labels\nfor container in ax.containers:\n    ax.bar_label(container, padding=2, fontsize=9)\n\nax.set_ylim(0, max(counts.max()) + 2)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas plotting method `counts.plot(kind='bar')`. Since the bars are vertical (the default for kind='bar') and represent two categorical variables (age_group and sex), it is classified as a Grouped column chart."}}
{"input_csv_file": "3college_Student.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"3college_Student.csv\")\n\n# Prepare data: distribution of students by major and sex (counts)\ncounts = (\n    df.groupby([\"major\", \"sex\"])\n      .size()\n      .reset_index(name=\"count\")\n)\n\n# Plot\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\nfig, ax = plt.subplots(figsize=(12, 6))\n\npalette = {\"F\": \"#4C78A8\", \"M\": \"#F58518\"}  # colorblind-friendly\n\nsns.barplot(\n    data=counts,\n    x=\"major\",\n    y=\"count\",\n    hue=\"sex\",\n    palette=palette,\n    ax=ax\n)\n\nax.set_title(\"Student Count by Major, Split by Sex\")\nax.set_xlabel(\"Major Code\")\nax.set_ylabel(\"Number of Students\")\nax.legend(title=\"Sex\", frameon=True, loc=\"upper right\")\n\n# Improve readability\nax.margins(y=0.05)\nfor c in ax.containers:\n    ax.bar_label(c, padding=3, fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses sns.barplot() to render the data, which prioritizes 'seaborn' as the library. The bars are vertical by default (x is categorical, y is quantitative), and the 'hue' parameter introduces a second categorical variable ('sex'), making it a grouped column chart."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3company_employee.csv\")\n\n# Single chart: average salary by department (dno)\navg_salary = df.groupby(\"dno\", as_index=False)[\"salary\"].mean().sort_values(\"dno\")\n\nplt.figure(figsize=(8, 4.5))\nplt.bar(avg_salary[\"dno\"].astype(str), avg_salary[\"salary\"], color=\"#4C78A8\")\nplt.title(\"Average Salary by Department\")\nplt.xlabel(\"Department (dno)\")\nplt.ylabel(\"Average Salary ($)\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is generated using the standard `plt.bar()` function from matplotlib. Since the bars are vertical and represent a categorical dimension (dno) against a quantitative dimension (salary), it is classified as a Column chart."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"3company_employee.csv\")\n\n# Prepare: average salary by department number (dno)\navg_salary = (\n    df.groupby(\"dno\", as_index=False)[\"salary\"]\n      .mean()\n      .sort_values(\"dno\")\n)\n\n# Plot: single chart\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(8, 4.5))\n\nax = sns.barplot(\n    data=avg_salary,\n    x=\"dno\",\n    y=\"salary\",\n    color=\"#4C78A8\"\n)\n\nax.set_title(\"Average Salary by Department (dno)\")\nax.set_xlabel(\"Department Number (dno)\")\nax.set_ylabel(\"Average Salary (USD)\")\n\n# Format y-axis as currency-like labels\nax.get_yaxis().set_major_formatter(lambda x, pos: f\"${x:,.0f}\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is generated using sns.barplot() with x and y parameters, which defaults to vertical bars (Column chart). According to the priority rules, since a seaborn function is used to render the data, the library is classified as 'seaborn'."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3company_employee.csv\")\n\n# Prepare: average salary by department number (dno)\navg_salary_by_dept = (\n    df.groupby(\"dno\", as_index=True)[\"salary\"]\n      .mean()\n      .sort_index()\n)\n\n# Plot: single chart\nplt.figure(figsize=(8, 4.5))\navg_salary_by_dept.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\n\nplt.title(\"Average Salary by Department (dno)\")\nplt.xlabel(\"Department Number (dno)\")\nplt.ylabel(\"Average Salary (USD)\")\nplt.xticks(rotation=0)\n\n# Add value labels for readability\nfor i, v in enumerate(avg_salary_by_dept.values):\n    plt.text(i, v + 500, f\"{v:,.0f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plotting is performed using the `.plot(kind='bar')` method on a pandas Series, which makes 'pandas' the primary library. Since the 'bar' kind in pandas defaults to vertical bars, it is classified as a 'Column chart' according to the taxonomy."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3company_employee.csv\")\n\n# Prepare: average salary by department number (dno)\navg_salary = df.groupby(\"dno\", as_index=True)[\"salary\"].mean().sort_index()\n\n# Plot: single chart\nplt.figure(figsize=(8, 4.5))\nax = avg_salary.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nax.set_title(\"Average Salary by Department (dno)\")\nax.set_xlabel(\"Department Number (dno)\")\nax.set_ylabel(\"Average Salary ($)\")\nax.set_ylim(0, max(avg_salary) * 1.15)\nax.bar_label(ax.containers[0], fmt=\"%.0f\", padding=3)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, this classifies the library as 'pandas'. Since the bars are vertical (the default for kind='bar' in pandas), it is classified as a Column chart."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3company_employee.csv\")\n\n# Aggregate: average salary by department number (dno)\navg_salary = df.groupby(\"dno\", as_index=True)[\"salary\"].mean().sort_index()\n\n# Plot: single chart\nplt.figure(figsize=(8, 4.5))\navg_salary.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Average Salary by Department (dno)\")\nplt.xlabel(\"Department Number (dno)\")\nplt.ylabel(\"Average Salary (USD)\")\nplt.xticks(rotation=0)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is generated using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, usage of DataFrame/Series plotting methods classifies the library as 'pandas'. Since the bars are vertical (the default for kind='bar'), it is classified as a Column chart."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3company_employee.csv\")\n\n# Aggregate: average salary by department number (dno)\navg_salary_by_dno = (\n    df.groupby(\"dno\", as_index=True)[\"salary\"]\n      .mean()\n      .sort_index()\n)\n\n# Plot: single chart\nplt.figure(figsize=(8, 4.5))\nax = avg_salary_by_dno.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\n\nax.set_title(\"Average Salary by Department (dno)\")\nax.set_xlabel(\"Department Number (dno)\")\nax.set_ylabel(\"Average Salary\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, even though matplotlib is used for figure creation and labels, the core rendering via the pandas wrapper identifies the library as 'pandas'. Since the bars are vertical (kind='bar'), it is classified as a 'Column chart' per the taxonomy."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"3company_employee.csv\")\n\n    # 平均給与を部署(dno)ごとに集計\n    avg_salary_by_dno = df.groupby(\"dno\", as_index=False)[\"salary\"].mean().sort_values(\"dno\")\n\n    # 1つのグラフ（部署ごとの平均給与の棒グラフ）\n    plt.figure(figsize=(8, 4.5))\n    plt.bar(avg_salary_by_dno[\"dno\"].astype(str), avg_salary_by_dno[\"salary\"], color=\"#4C78A8\")\n    plt.title(\"Average Salary by Department (dno)\")\n    plt.xlabel(\"Department Number (dno)\")\n    plt.ylabel(\"Average Salary\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() to render data, which according to the hierarchy rules is classified as 'matplotlib'. Since plt.bar() creates vertical bars representing categorical (dno) and quantitative (salary) variables, it is classified as a 'Column chart'."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"3company_employee.csv\")\n\n    # Aggregate salary by department number (dno)\n    dept_salary = df.groupby(\"dno\", as_index=True)[\"salary\"].mean().sort_index()\n\n    plt.figure(figsize=(8, 4.8))\n    plt.bar(dept_salary.index.astype(str), dept_salary.values, color=\"#4C78A8\")\n    plt.title(\"Average Salary by Department (dno)\")\n    plt.xlabel(\"Department Number (dno)\")\n    plt.ylabel(\"Average Salary\")\n    plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses `plt.bar()` to render data, which according to the hierarchy rules classifies the library as 'matplotlib'. Since `plt.bar()` produces vertical bars representing a categorical variable (Department Number) and a quantitative variable (Average Salary), it is classified as a 'Column chart'. A single hex color code is provided instead of a named palette."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"3company_employee.csv\")\n\n# Agregar salario promedio por departamento (dno)\navg_salary = df.groupby(\"dno\")[\"salary\"].mean().sort_index()\n\n# Gráfico único\nplt.figure(figsize=(8, 4.5))\nplt.bar(avg_salary.index.astype(str), avg_salary.values, color=\"#4C78A8\")\nplt.title(\"Salario promedio por departamento (dno)\")\nplt.xlabel(\"Departamento (dno)\")\nplt.ylabel(\"Salario promedio\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard plt.bar() function to render vertical bars representing the relationship between categorical department indices and quantitative average salaries, identifying it as a Column chart. Following the hierarchy rules, since the data is rendered via matplotlib's pyplot rather than pandas or seaborn methods, the library is matplotlib."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"3company_employee.csv\")\n\n# Aggregate: average salary by department (dno) and sex\nagg = (\n    df.groupby([\"dno\", \"sex\"], as_index=False)[\"salary\"]\n    .mean()\n    .rename(columns={\"salary\": \"avg_salary\"})\n)\nagg[\"dno\"] = agg[\"dno\"].astype(str)\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5.5))\n\nsns.barplot(\n    data=agg,\n    x=\"dno\",\n    y=\"avg_salary\",\n    hue=\"sex\",\n    palette={\"M\": \"#4C78A8\", \"F\": \"#F58518\"},\n    ax=ax,\n)\n\nax.set_title(\"Average Salary by Department and Sex\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Department (dno)\")\nax.set_ylabel(\"Average Salary (USD)\")\nax.legend(title=\"Sex\", frameon=True)\n\n# Add value labels\nfor container in ax.containers:\n    ax.bar_label(container, fmt=\"%.0f\", padding=3, fontsize=9)\n\nax.set_ylim(0, max(agg[\"avg_salary\"]) * 1.18)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses sns.barplot with a 'hue' parameter to compare average salaries across two categorical dimensions (department and sex). The bars are oriented vertically, which classifies it as a column chart rather than a bar chart."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"3company_employee.csv\")\n\n# Prepare data: average salary by department and sex\nsalary_summary = (\n    df.groupby([\"dno\", \"sex\"], as_index=False)[\"salary\"]\n      .mean()\n      .rename(columns={\"salary\": \"avg_salary\"})\n)\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(9, 5))\n\nax = sns.barplot(\n    data=salary_summary,\n    x=\"dno\",\n    y=\"avg_salary\",\n    hue=\"sex\",\n    palette={\"M\": \"#4C78A8\", \"F\": \"#F58518\"},\n    edgecolor=\"white\"\n)\n\nax.set_title(\"Average Salary by Department and Sex\", pad=10)\nax.set_xlabel(\"Department Number (dno)\")\nax.set_ylabel(\"Average Salary (USD)\")\nax.legend(title=\"Sex\", frameon=True)\n\n# Improve y-axis formatting\nax.yaxis.set_major_formatter(lambda x, pos: f\"${x:,.0f}\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the seaborn library (sns.barplot). It displays vertical bars representing a quantitative value (avg_salary) across two categorical dimensions ('dno' and 'sex' via the hue parameter), which classifies it as a Grouped column chart."}}
{"input_csv_file": "3company_employee.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    # Load data\n    df = pd.read_csv(\"3company_employee.csv\")\n\n    # Aggregate: average salary by department (dno)\n    agg = (\n        df.groupby(\"dno\", as_index=False)[\"salary\"]\n        .mean()\n        .sort_values(\"dno\")\n        .rename(columns={\"salary\": \"avg_salary\"})\n    )\n\n    # Plot: single chart\n    plt.style.use(\"seaborn-v0_8-whitegrid\")\n    fig, ax = plt.subplots(figsize=(8.5, 4.8), dpi=140)\n\n    bars = ax.bar(agg[\"dno\"].astype(str), agg[\"avg_salary\"], color=\"#4C78A8\")\n\n    ax.set_title(\"Average Salary by Department\", pad=10)\n    ax.set_xlabel(\"Department Number (dno)\")\n    ax.set_ylabel(\"Average Salary (USD)\")\n\n    # Value labels\n    for b in bars:\n        h = b.get_height()\n        ax.annotate(\n            f\"{h:,.0f}\",\n            (b.get_x() + b.get_width() / 2, h),\n            textcoords=\"offset points\",\n            xytext=(0, 6),\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=9,\n            color=\"#1f2d3d\",\n        )\n\n    ax.set_ylim(0, max(agg[\"avg_salary\"]) * 1.18)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses the `ax.bar()` method from matplotlib to render vertical bars directly. According to the hierarchy rules, since no seaborn functions or pandas .plot() methods were used to draw the data, the library is classified as 'matplotlib'. The vertical orientation of the bars identifies it as a 'Column chart' per the taxonomy."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"3customers_and_invoicesOrder_Items.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate: total quantity sold per product\nproduct_totals = (\n    df.groupby(\"product_id\", as_index=True)[\"product_quantity\"]\n      .sum()\n      .sort_values(ascending=False)\n)\n\n# Plot: bar chart of total quantity per product\nplt.figure(figsize=(10, 5))\nproduct_totals.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Total Product Quantity by Product ID\")\nplt.xlabel(\"Product ID\")\nplt.ylabel(\"Total Quantity\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas .plot() method on a Series with kind='bar', which produces vertical bars. According to the taxonomy, vertical bars are classified as a 'Column chart'. Although matplotlib is used for styling and display, the library hierarchy rule dictates that the use of DataFrame/Series plotting methods classifies the library as 'pandas'."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3customers_and_invoicesOrder_Items.csv\")\n\n# Aggregate: total quantity per product\nproduct_totals = (\n    df.groupby(\"product_id\", as_index=False)[\"product_quantity\"]\n      .sum()\n      .sort_values(\"product_quantity\", ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 5))\nplt.bar(product_totals[\"product_id\"].astype(str), product_totals[\"product_quantity\"])\nplt.title(\"Total Product Quantity Ordered (by Product ID)\")\nplt.xlabel(\"Product ID\")\nplt.ylabel(\"Total Quantity\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib pyplot function `plt.bar()` to render data. Since `plt.bar()` creates vertical bars by default, it is classified as a Column chart rather than a Bar chart. No specific color palette was defined in the function call."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3customers_and_invoicesOrder_Items.csv\")\n\n# Aggregate: total quantity per product\nproduct_totals = (\n    df.groupby(\"product_id\", as_index=False)[\"product_quantity\"]\n      .sum()\n      .sort_values(\"product_quantity\", ascending=False)\n)\n\n# Plot: bar chart of total quantity by product\nplt.figure(figsize=(9, 5))\nplt.bar(product_totals[\"product_id\"].astype(str), product_totals[\"product_quantity\"])\nplt.title(\"Total Product Quantity Across All Orders\")\nplt.xlabel(\"Product ID\")\nplt.ylabel(\"Total Quantity\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, which falls under the matplotlib classification. Since plt.bar() produces vertical bars by default, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"3customers_and_invoicesOrder_Items.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate: total quantity per product\nproduct_totals = (\n    df.groupby(\"product_id\", as_index=False)[\"product_quantity\"]\n      .sum()\n      .sort_values(\"product_quantity\", ascending=False)\n)\n\n# Plot: bar chart of total quantity by product\nplt.figure(figsize=(10, 5))\nplt.bar(product_totals[\"product_id\"].astype(str), product_totals[\"product_quantity\"], color=\"#4C78A8\")\nplt.title(\"Total Quantity Ordered per Product\")\nplt.xlabel(\"Product ID\")\nplt.ylabel(\"Total Quantity\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using the plt.bar() function directly from matplotlib, rather than a seaborn or pandas wrapper. Since the bars are vertical (plt.bar), it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"3customers_and_invoicesOrder_Items.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate: total product quantity per order\norder_totals = (\n    df.groupby(\"order_id\", as_index=False)[\"product_quantity\"]\n      .sum()\n      .sort_values(\"product_quantity\", ascending=False)\n)\n\n# Plot: bar chart of total quantity by order_id\nplt.figure(figsize=(9, 5))\nplt.bar(order_totals[\"order_id\"].astype(str), order_totals[\"product_quantity\"], color=\"#4C78A8\")\nplt.title(\"Total Product Quantity per Order\")\nplt.xlabel(\"Order ID\")\nplt.ylabel(\"Total Quantity\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot uses plt.bar() which renders vertical bars, classifying it as a Column chart according to the taxonomy. Since the data is rendered using standard pyplot functions rather than seaborn or pandas plotting methods, the library is classified as matplotlib."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"3customers_and_invoicesOrder_Items.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate: total quantity sold per product\nproduct_totals = (\n    df.groupby(\"product_id\", as_index=False)[\"product_quantity\"]\n      .sum()\n      .sort_values(\"product_quantity\", ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 5))\nplt.bar(product_totals[\"product_id\"].astype(str), product_totals[\"product_quantity\"], color=\"#4C78A8\")\nplt.title(\"Total Product Quantity by Product ID\")\nplt.xlabel(\"Product ID\")\nplt.ylabel(\"Total Quantity\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses plt.bar() to render the data, which explicitly falls under matplotlib. Since plt.bar() creates vertical bars, it is classified as a Column chart."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"3customers_and_invoicesOrder_Items.csv\")\n\n# Aggregate total quantity by product\nqty_by_product = (\n    df.groupby(\"product_id\", as_index=True)[\"product_quantity\"]\n      .sum()\n      .sort_values(ascending=False)\n)\n\n# Single chart: bar chart of total quantity per product\nplt.figure(figsize=(10, 5))\nqty_by_product.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Total Product Quantity by Product ID\")\nplt.xlabel(\"Product ID\")\nplt.ylabel(\"Total Quantity\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is generated using the `.plot(kind='bar')` method on a pandas Series object. According to the hierarchy rules, even though matplotlib is used for styling, data rendering via `.plot()` classifies the library as 'pandas'. The resulting chart has vertical bars, classifying it as a 'Column chart' rather than a 'Bar chart' (horizontal)."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3customers_and_invoicesOrder_Items.csv\")\n\n# Aggregate: total quantity sold per product\nprod_qty = (\n    df.groupby(\"product_id\", as_index=False)[\"product_quantity\"]\n      .sum()\n      .sort_values(\"product_quantity\", ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 5))\nplt.bar(prod_qty[\"product_id\"].astype(str), prod_qty[\"product_quantity\"], color=\"#4C78A8\")\nplt.title(\"Total Product Quantity by Product ID\")\nplt.xlabel(\"Product ID\")\nplt.ylabel(\"Total Quantity\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using plt.bar(), which belongs to the matplotlib library. Since the bars are vertical by default in plt.bar(), it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"3customers_and_invoicesOrder_Items.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate total quantity per product\nqty_by_product = (\n    df.groupby(\"product_id\")[\"product_quantity\"]\n    .sum()\n    .sort_values(ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 5))\nplt.bar(qty_by_product.index.astype(str), qty_by_product.values, color=\"#4C78A8\")\nplt.title(\"Cantidad total vendida por producto (Order Items)\")\nplt.xlabel(\"product_id\")\nplt.ylabel(\"Suma de product_quantity\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, which falls under matplotlib classification. Since plt.bar() creates vertical bars representing a categorical variable (product_id) and a quantitative variable (product_quantity), it is classified as a Column chart."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"3customers_and_invoicesOrder_Items.csv\")\n\n# Aggregate: total quantity per product\nprod_qty = (\n    df.groupby(\"product_id\", as_index=True)[\"product_quantity\"]\n    .sum()\n    .sort_values(ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(10, 5))\nbars = plt.bar(prod_qty.index.astype(str), prod_qty.values, color=\"#4C78A8\")\n\nplt.title(\"Total Product Quantity Ordered (by Product ID)\")\nplt.xlabel(\"Product ID\")\nplt.ylabel(\"Total Quantity Ordered\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n# Value labels\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h, f\"{int(h)}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.bar() to render the data directly, which produces vertical bars according to the taxonomy. No pandas plotting wrappers or seaborn functions are used for rendering."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ncsv_path = \"3customers_and_invoicesOrder_Items.csv\"\ndf = pd.read_csv(csv_path)\n\n# Aggregate: total quantity by product\nprod_qty = (\n    df.groupby(\"product_id\", as_index=False)[\"product_quantity\"]\n      .sum()\n      .sort_values(\"product_quantity\", ascending=False)\n)\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5))\n\nsns.barplot(\n    data=prod_qty,\n    x=\"product_id\",\n    y=\"product_quantity\",\n    color=\"#4C78A8\",\n    ax=ax\n)\n\nax.set_title(\"Total Quantity Ordered by Product\", pad=10)\nax.set_xlabel(\"Product ID\")\nax.set_ylabel(\"Total Quantity\")\nax.set_ylim(0, prod_qty[\"product_quantity\"].max() * 1.15)\n\n# Value labels\nfor p in ax.patches:\n    h = p.get_height()\n    ax.annotate(\n        f\"{int(h)}\",\n        (p.get_x() + p.get_width() / 2, h),\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n        xytext=(0, 3),\n        textcoords=\"offset points\"\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using the seaborn function `sns.barplot()`. Since the categorical variable 'product_id' is mapped to the x-axis and the quantitative variable 'product_quantity' is mapped to the y-axis, the resulting bars are vertical, which classifies it as a Column chart."}}
{"input_csv_file": "3customers_and_invoicesOrder_Items.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\n# Load data\ncsv_path = Path(\"3customers_and_invoicesOrder_Items.csv\")\ndf = pd.read_csv(csv_path)\n\n# Aggregate: total quantity per product\nprod_qty = (\n    df.groupby(\"product_id\", as_index=False)[\"product_quantity\"]\n      .sum()\n      .sort_values(\"product_quantity\", ascending=True)\n)\n\n# Plot: horizontal bar chart (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nbars = ax.barh(\n    prod_qty[\"product_id\"].astype(str),\n    prod_qty[\"product_quantity\"],\n    color=\"#2B6CB0\",\n    edgecolor=\"#1A365D\",\n    linewidth=0.8\n)\n\n# Labels & title\nax.set_title(\"Total Units Ordered by Product (Order Items)\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Total Product Quantity\")\nax.set_ylabel(\"Product ID\")\n\n# Value labels\nfor b in bars:\n    w = b.get_width()\n    ax.text(w + 0.15, b.get_y() + b.get_height() / 2, f\"{int(w)}\", va=\"center\", ha=\"left\", fontsize=10)\n\n# Clean up\nax.margins(x=0.06)\nfor spine in [\"top\", \"right\"]:\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.barh()` function to render the data directly. According to the taxonomy, horizontal bars are classified as a 'Bar chart'."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4carsMod.csv\")\n\n# Single chart: Scatter plot of MPG vs Horsepower, colored by transmission (am)\nplt.figure(figsize=(8.5, 5.5))\n\nam_labels = {0.0: \"Automatic (0)\", 1.0: \"Manual (1)\"}\nfor am_value, group in df.groupby(\"am\"):\n    plt.scatter(\n        group[\"hp\"],\n        group[\"mpg\"],\n        s=70,\n        alpha=0.8,\n        edgecolors=\"white\",\n        linewidths=0.6,\n        label=am_labels.get(am_value, f\"am={am_value}\")\n    )\n\nplt.title(\"MPG vs Horsepower (colored by Transmission)\")\nplt.xlabel(\"Horsepower (hp)\")\nplt.ylabel(\"Miles per Gallon (mpg)\")\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\nplt.legend(title=\"Transmission\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the standard matplotlib function plt.scatter() to plot two quantitative variables (hp and mpg). Even though pandas is used for data manipulation, the drawing function is directly from the pyplot interface."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4carsMod.csv\")\n\n# Clean/standardize: wt looks mixed (some rows in thousands). Convert to \"1000 lbs\" scale.\n# If wt is unusually large, assume it's in pounds and convert to thousands of pounds.\ndf[\"wt_1000lbs\"] = df[\"wt\"].where(df[\"wt\"] <= 50, df[\"wt\"] / 1000.0)\n\n# Build a simple, easy-to-read summary chart: average MPG by number of cylinders\navg_mpg_by_cyl = df.groupby(\"cyl\")[\"mpg\"].mean().sort_index()\n\nplt.figure(figsize=(8, 5))\nax = avg_mpg_by_cyl.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\n\nax.set_title(\"Average MPG by Number of Cylinders\")\nax.set_xlabel(\"Cylinders\")\nax.set_ylabel(\"Average MPG\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\n# Add value labels\nfor p in ax.patches:\n    height = p.get_height()\n    ax.annotate(f\"{height:.1f}\",\n                (p.get_x() + p.get_width() / 2, height),\n                ha=\"center\", va=\"bottom\",\n                fontsize=9, xytext=(0, 3), textcoords=\"offset points\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the .plot(kind='bar') method on a pandas Series object. According to the hierarchy rules, this classifies the library as 'pandas' despite the use of matplotlib for styling. Because the resulting bars are vertical, the chart is classified as a Column chart."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4carsMod.csv\")\n\n# Average mpg by number of cylinders (simple \"read the data\" level)\navg_mpg_by_cyl = df.groupby(\"cyl\", as_index=False)[\"mpg\"].mean().sort_values(\"cyl\")\n\n# Plot: single chart\nplt.figure(figsize=(8, 5))\nplt.bar(avg_mpg_by_cyl[\"cyl\"].astype(int).astype(str), avg_mpg_by_cyl[\"mpg\"], color=\"#4C78A8\")\n\nplt.title(\"Average MPG by Number of Cylinders\")\nplt.xlabel(\"Cylinders\")\nplt.ylabel(\"Average MPG\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly from the matplotlib.pyplot library to create vertical bars, which classifies it as a Column chart. Although a specific hex color is used, there is no named color palette applied."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4carsMod.csv\")\n\n# Clean up types (some files store integers as floats)\ndf[\"cyl\"] = df[\"cyl\"].astype(int)\n\n# Group and summarize: average mpg by number of cylinders\nsummary = (\n    df.groupby(\"cyl\", as_index=False)[\"mpg\"]\n      .mean()\n      .sort_values(\"cyl\")\n)\n\n# Plot: simple bar chart (easy to read at a basic data literacy level)\nplt.figure(figsize=(8, 5))\nplt.bar(summary[\"cyl\"].astype(str), summary[\"mpg\"], edgecolor=\"black\")\nplt.title(\"Average Miles Per Gallon (mpg) by Number of Cylinders\")\nplt.xlabel(\"Cylinders\")\nplt.ylabel(\"Average mpg\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() to render the data directly, which is the standard matplotlib function for vertical bars. Based on the provided taxonomy, vertical bars are classified as a Column chart."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4carsMod.csv\")\n\n# Clean/standardize types and remove missing values for the plotted columns\nfor c in [\"mpg\", \"wt\", \"am\"]:\n    df[c] = pd.to_numeric(df[c], errors=\"coerce\")\ndf = df.dropna(subset=[\"mpg\", \"wt\", \"am\"])\n\n# Transmission labels (am: 0 = automatic, 1 = manual)\nlabels = df[\"am\"].round().astype(int).map({0: \"Automatic\", 1: \"Manual\"})\ncolors = labels.map({\"Automatic\": \"#1f77b4\", \"Manual\": \"#ff7f0e\"})\n\n# Single chart: scatter of MPG vs Weight, colored by transmission\nplt.figure(figsize=(8, 5.5), dpi=120)\n\nfor name in [\"Automatic\", \"Manual\"]:\n    m = labels == name\n    plt.scatter(df.loc[m, \"wt\"], df.loc[m, \"mpg\"], s=55, alpha=0.85, label=name, c=colors[m])\n\nplt.title(\"MPG vs Weight (Colored by Transmission)\")\nplt.xlabel(\"Weight (wt)\")\nplt.ylabel(\"Miles per Gallon (mpg)\")\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\nplt.legend(frameon=True, title=\"Transmission\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization is created using standard matplotlib.pyplot functions (plt.scatter) to map two quantitative variables ('wt' and 'mpg') to the X and Y axes. Although pandas is used for data manipulation, the rendering is handled directly by matplotlib."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"4carsMod.csv\")\n\n    # Some rows appear to have wt in mixed units; normalize if unusually large (likely pounds -> 1000 lbs)\n    if df[\"wt\"].max() > 50:\n        df[\"wt\"] = df[\"wt\"] / 1000.0\n\n    fig, ax = plt.subplots(figsize=(8, 5))\n\n    ax.scatter(df[\"wt\"], df[\"mpg\"], alpha=0.85, edgecolors=\"white\", linewidths=0.6)\n    ax.set_title(\"Fuel Efficiency vs Vehicle Weight\")\n    ax.set_xlabel(\"Weight (1000 lbs)\")\n    ax.set_ylabel(\"Miles per Gallon (mpg)\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib axes function 'ax.scatter()' with two quantitative variables (weight and mpg)."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"4carsMod.csv\")\n\n    # Clean: some 'wt' values appear to be in pounds (e.g., 2875) while others look like 1000 lbs units (e.g., 2.62)\n    # Convert large values (>100) from lbs to 1000 lbs to match the typical mtcars 'wt' scale.\n    df[\"wt_clean\"] = df[\"wt\"].where(df[\"wt\"] <= 100, df[\"wt\"] / 1000.0)\n\n    fig, ax = plt.subplots(figsize=(8, 5))\n    scatter = ax.scatter(\n        df[\"wt_clean\"],\n        df[\"mpg\"],\n        c=df[\"cyl\"],\n        cmap=\"viridis\",\n        s=70,\n        alpha=0.85,\n        edgecolors=\"white\",\n        linewidths=0.6,\n    )\n\n    ax.set_title(\"MPG vs Weight (colored by cylinders)\")\n    ax.set_xlabel(\"Weight (1000 lbs)\")\n    ax.set_ylabel(\"Miles per Gallon (mpg)\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n\n    cbar = plt.colorbar(scatter, ax=ax)\n    cbar.set_label(\"Cylinders\")\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "viridis", "reasoning": "The code uses matplotlib's axes-level function ax.scatter() to visualize two quantitative variables (wt_clean and mpg). Following the hierarchy rules, since it uses matplotlib functions directly rather than pandas or seaborn wrappers, the library is matplotlib."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Read data\ndf = pd.read_csv(\"4carsMod.csv\")\n\n# Ensure numeric columns are treated as numeric\nfor col in [\"mpg\", \"wt\", \"hp\", \"cyl\", \"am\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Single chart: MPG vs Weight, colored by transmission (am), sized by horsepower\ncolors = df[\"am\"].map({0.0: \"#1f77b4\", 1.0: \"#ff7f0e\"}).fillna(\"#7f7f7f\")\nsizes = (df[\"hp\"].fillna(df[\"hp\"].median()) ** 0.9) * 0.6\n\nplt.figure(figsize=(9, 6))\nplt.scatter(df[\"wt\"], df[\"mpg\"], s=sizes, c=colors, alpha=0.75, edgecolors=\"white\", linewidths=0.6)\n\n# Legend proxies (manual)\nplt.scatter([], [], s=80, c=\"#1f77b4\", alpha=0.75, edgecolors=\"white\", linewidths=0.6, label=\"am=0 (Automatic)\")\nplt.scatter([], [], s=80, c=\"#ff7f0e\", alpha=0.75, edgecolors=\"white\", linewidths=0.6, label=\"am=1 (Manual)\")\n\nplt.title(\"MPG vs Weight (colored by Transmission, sized by Horsepower)\")\nplt.xlabel(\"Weight (wt)\")\nplt.ylabel(\"Miles per Gallon (mpg)\")\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.35)\nplt.legend(frameon=True)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The code uses plt.scatter() from the matplotlib library to render the data. It maps two quantitative variables to the X and Y axes (wt and mpg) and uses a third quantitative variable (hp) to determine the size of the markers, which identifies it as a bubble chart according to the taxonomy."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"4carsMod.csv\")\n\n    # Un solo gráfico: dispersión hp vs mpg, coloreado por transmisión (am)\n    colors = df[\"am\"].map({0.0: \"#1f77b4\", 1.0: \"#ff7f0e\"}).fillna(\"#7f7f7f\")\n\n    plt.figure(figsize=(8, 5))\n    plt.scatter(df[\"hp\"], df[\"mpg\"], c=colors, alpha=0.85, edgecolors=\"white\", linewidths=0.6)\n\n    plt.title(\"Relación entre potencia (hp) y eficiencia (mpg)\")\n    plt.xlabel(\"Potencia (hp)\")\n    plt.ylabel(\"Millas por galón (mpg)\")\n    plt.grid(True, alpha=0.25)\n\n    # Leyenda simple sin crear gráficos adicionales\n    from matplotlib.lines import Line2D\n    legend_elems = [\n        Line2D([0], [0], marker='o', color='w', label='am=0 (Automática)',\n               markerfacecolor=\"#1f77b4\", markeredgecolor=\"white\", markersize=8),\n        Line2D([0], [0], marker='o', color='w', label='am=1 (Manual)',\n               markerfacecolor=\"#ff7f0e\", markeredgecolor=\"white\", markersize=8),\n    ]\n    plt.legend(handles=legend_elems, frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization uses the plt.scatter() function directly from the matplotlib library to plot two quantitative variables (hp and mpg)."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mticker\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"4carsMod.csv\")\n\n# Handle mixed wt units (some rows look like lbs while others look like 1000 lbs)\n# Rule: values > 100 are almost certainly pounds; convert to 1000 lbs for comparability.\ndf[\"wt_klbs\"] = np.where(df[\"wt\"] > 100, df[\"wt\"] / 1000.0, df[\"wt\"])\n\n# Plot: MPG vs Weight (1000 lbs), colored by cylinders\ncylinders = sorted(df[\"cyl\"].dropna().unique())\ncolors = plt.cm.Set2(np.linspace(0, 1, len(cylinders)))\n\nfig, ax = plt.subplots(figsize=(9.5, 5.5), dpi=140)\n\nfor c, col in zip(cylinders, colors):\n    sub = df[df[\"cyl\"] == c]\n    ax.scatter(\n        sub[\"wt_klbs\"],\n        sub[\"mpg\"],\n        s=55,\n        alpha=0.85,\n        color=col,\n        edgecolor=\"white\",\n        linewidth=0.7,\n        label=f\"{int(c)} cyl\" if float(c).is_integer() else f\"{c} cyl\",\n    )\n\nax.set_title(\"Fuel Efficiency vs Vehicle Weight (colored by cylinders)\", pad=10, weight=\"semibold\")\nax.set_xlabel(\"Weight (1000 lbs)\")\nax.set_ylabel(\"MPG\")\n\nax.grid(True, which=\"major\", linestyle=\"-\", linewidth=0.6, alpha=0.25)\nax.grid(True, which=\"minor\", linestyle=\"--\", linewidth=0.5, alpha=0.15)\nax.xaxis.set_minor_locator(mticker.AutoMinorLocator(2))\nax.yaxis.set_minor_locator(mticker.AutoMinorLocator(2))\n\nleg = ax.legend(title=\"Engine\", frameon=True, framealpha=0.95, borderpad=0.7)\nleg.get_frame().set_linewidth(0.6)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "Set2", "reasoning": "The code uses the standard matplotlib axes function ax.scatter() to plot two quantitative variables (weight and mpg). Although a third variable (cylinders) is used for color-coding, the size of the markers is constant (s=55), which identifies it as a scatterplot rather than a bubble chart. Following the hierarchy rules, it is classified as matplotlib because the data is rendered via direct axes method calls rather than seaborn or pandas wrappers."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"4carsMod.csv\")\n\n# Cast for clean grouping/legend labels\ndf[\"cyl\"] = df[\"cyl\"].astype(int)\ndf[\"am\"] = df[\"am\"].astype(int)\n\n# Handle mixed units in 'wt' (some rows appear in pounds while others are in 1000 lbs)\n# Heuristic: values > 50 are treated as pounds and converted to 1000 lbs.\nwt = df[\"wt\"].astype(float).copy()\ndf[\"wt_1000lb\"] = np.where(wt > 50, wt / 1000.0, wt)\n\n# Plot: MPG vs weight, colored by cylinders, marker by transmission\ncyl_order = sorted(df[\"cyl\"].unique())\ncolors = dict(zip(cyl_order, plt.cm.Set2(np.linspace(0.1, 0.9, len(cyl_order)))))\n\nfig, ax = plt.subplots(figsize=(10.5, 6.2))\n\nmarkers = {0: \"o\", 1: \"^\"}  # 0 = Automatic, 1 = Manual\nam_labels = {0: \"Automatic\", 1: \"Manual\"}\n\nfor am_val in sorted(df[\"am\"].unique()):\n    for cyl in cyl_order:\n        sub = df[(df[\"am\"] == am_val) & (df[\"cyl\"] == cyl)]\n        if sub.empty:\n            continue\n        ax.scatter(\n            sub[\"wt_1000lb\"],\n            sub[\"mpg\"],\n            s=70,\n            marker=markers[am_val],\n            c=[colors[cyl]],\n            edgecolor=\"white\",\n            linewidth=0.8,\n            alpha=0.9,\n        )\n\n# Add trend line (overall) with simple linear regression\nx = df[\"wt_1000lb\"].to_numpy()\ny = df[\"mpg\"].to_numpy()\nm, b = np.polyfit(x, y, 1)\nxx = np.linspace(x.min(), x.max(), 200)\nax.plot(xx, m * xx + b, color=\"#333333\", linewidth=2.0, label=\"Overall linear trend\")\n\n# Labels, formatting\nax.set_title(\"Fuel Economy vs Vehicle Weight (colored by cylinders; shape by transmission)\", pad=12)\nax.set_xlabel(\"Weight (1000 lb)\")\nax.set_ylabel(\"MPG\")\n\nax.grid(True, which=\"major\", axis=\"both\", linestyle=\"--\", linewidth=0.6, alpha=0.35)\nax.set_axisbelow(True)\n\n# Build a single combined legend (cyl colors + transmission markers + trend)\nfrom matplotlib.lines import Line2D\n\nlegend_items = []\nlegend_items.append(Line2D([], [], color=\"none\", label=\"Cylinders (color):\"))\nfor cyl in cyl_order:\n    legend_items.append(\n        Line2D([], [], marker=\"o\", linestyle=\"None\", markersize=8,\n               markerfacecolor=colors[cyl], markeredgecolor=\"white\", label=f\"{cyl}\")\n    )\n\nlegend_items.append(Line2D([], [], color=\"none\", label=\"Transmission (shape):\"))\nfor am_val in sorted(df[\"am\"].unique()):\n    legend_items.append(\n        Line2D([], [], marker=markers[am_val], linestyle=\"None\", markersize=8,\n               markerfacecolor=\"#666666\", markeredgecolor=\"white\", label=am_labels[am_val])\n    )\n\nlegend_items.append(Line2D([], [], color=\"#333333\", linewidth=2.0, label=\"Overall linear trend\"))\n\nax.legend(\n    handles=legend_items,\n    loc=\"upper right\",\n    frameon=True,\n    framealpha=0.95,\n    borderpad=0.8,\n    labelspacing=0.6,\n    handlelength=2.2\n)\n\n# Nice tick labels\nax.xaxis.set_major_formatter(FuncFormatter(lambda v, pos: f\"{v:.1f}\"))\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "Set2", "reasoning": "The visualization is created using the standard matplotlib axes function `ax.scatter()` to plot two quantitative variables (weight and MPG). While pandas is used for data handling, the rendering is performed directly through matplotlib functions, and the colors are explicitly derived from the 'Set2' colormap."}}
{"input_csv_file": "4carsMod.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4carsMod.csv\")\n\n# Coerce to numeric (robust to any stray non-numeric values)\nfor col in df.columns:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Scatter: horsepower vs mpg, colored by cylinders, sized by weight (robust scaling)\nx = df[\"hp\"].values\ny = df[\"mpg\"].values\ncyl = df[\"cyl\"].astype(\"Int64\")\n\n# Size by wt using percentiles to reduce outlier impact (notably mixed units in wt column)\nwt = df[\"wt\"].values\np05, p95 = np.nanpercentile(wt, [5, 95])\nwt_clip = np.clip(wt, p05, p95)\nsizes = 60 + 260 * (wt_clip - p05) / (p95 - p05 + 1e-9)\n\n# Color map for cylinders\ncyl_values = sorted([int(v) for v in pd.Series(cyl).dropna().unique()])\ncmap = plt.get_cmap(\"viridis\", max(len(cyl_values), 2))\ncolor_lookup = {cv: cmap(i) for i, cv in enumerate(cyl_values)}\ncolors = [color_lookup.get(int(v), (0.5, 0.5, 0.5, 1.0)) if pd.notna(v) else (0.5, 0.5, 0.5, 1.0) for v in cyl]\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 6))\n\nax.scatter(\n    x, y,\n    s=sizes,\n    c=colors,\n    alpha=0.85,\n    edgecolor=\"white\",\n    linewidth=0.7\n)\n\nax.set_title(\"Fuel Economy vs Power (colored by cylinders, size ~ weight)\", pad=12)\nax.set_xlabel(\"Horsepower (hp)\")\nax.set_ylabel(\"Miles per gallon (mpg)\")\n\n# Legend for cylinders (single chart)\nhandles = [\n    plt.Line2D([0], [0], marker='o', color='none',\n               markerfacecolor=color_lookup[cv], markeredgecolor=\"white\",\n               markersize=9, label=f\"{cv} cyl\")\n    for cv in cyl_values\n]\nax.legend(handles=handles, title=\"Cylinders\", frameon=True, loc=\"upper right\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "viridis", "reasoning": "The data is rendered using the standard matplotlib function ax.scatter(). It is classified as a Bubble chart because it maps two quantitative variables to the X and Y axes and a third quantitative variable (weight) to the size of the markers."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"4gapminder.csv\")\n\n# Scatter: GDP per Capita vs Life Expectancy, colored by continent, sized by population\ncontinents = sorted(df[\"continent\"].unique())\ncolors = {\n    \"Africa\": \"#1f77b4\",\n    \"Americas\": \"#ff7f0e\",\n    \"Asia\": \"#2ca02c\",\n    \"Europe\": \"#d62728\",\n    \"Oceania\": \"#9467bd\",\n}\n\n# Scale population to marker area (points^2)\npop = df[\"population\"].astype(float)\nsizes = 30 + 370 * (pop - pop.min()) / (pop.max() - pop.min())\n\nfig, ax = plt.subplots(figsize=(10, 6.5))\n\nfor cont in continents:\n    sub = df[df[\"continent\"] == cont]\n    sub_sizes = sizes[sub.index]\n    ax.scatter(\n        sub[\"gdpPerCap\"],\n        sub[\"lifeExp\"],\n        s=sub_sizes,\n        alpha=0.7,\n        c=colors.get(cont, \"#7f7f7f\"),\n        edgecolors=\"white\",\n        linewidths=0.6,\n        label=cont,\n    )\n\nax.set_xscale(\"log\")\nax.set_title(\"Life Expectancy vs GDP per Capita (Bubble size = Population)\")\nax.set_xlabel(\"GDP per Capita (log scale)\")\nax.set_ylabel(\"Life Expectancy (years)\")\n\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x:,.0f}\"))\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.6, alpha=0.35)\n\nax.legend(title=\"Continent\", frameon=True, loc=\"lower right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The plot is created using the standard matplotlib 'ax.scatter()' method rather than pandas or seaborn wrappers. It maps two quantitative variables to the X and Y axes and uses a third quantitative variable (population) to determine marker size ('s'), which classifies it as a Bubble chart."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4gapminder.csv\")\n\n# Summarize to an easy-to-read view: average life expectancy by continent\nsummary = (\n    df.groupby(\"continent\", as_index=False)[\"lifeExp\"]\n      .mean()\n      .sort_values(\"lifeExp\", ascending=False)\n)\n\n# Plot (single chart)\nplt.figure(figsize=(9, 5))\nplt.bar(summary[\"continent\"], summary[\"lifeExp\"], color=\"#4C78A8\")\nplt.title(\"Average Life Expectancy by Continent (All Years in File)\")\nplt.xlabel(\"Continent\")\nplt.ylabel(\"Average life expectancy (years)\")\nplt.ylim(0, max(85, summary[\"lifeExp\"].max() + 5))\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly from the matplotlib library to render data. Since plt.bar() generates vertical bars, it is classified as a Column chart rather than a Bar chart. A specific hex color is used, but no named color palette is specified."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4gapminder.csv\")\n\n# Make a simple \"read the data\" chart: average life expectancy by continent\navg_life = (\n    df.groupby(\"continent\", as_index=False)[\"lifeExp\"]\n    .mean()\n    .sort_values(\"lifeExp\", ascending=False)\n)\n\n# Plot (single chart)\nplt.figure(figsize=(9, 5))\nplt.bar(avg_life[\"continent\"], avg_life[\"lifeExp\"], color=\"#4C78A8\")\nplt.title(\"Average Life Expectancy by Continent (All Years in File)\")\nplt.xlabel(\"Continent\")\nplt.ylabel(\"Average life expectancy (years)\")\nplt.ylim(0, max(avg_life[\"lifeExp\"]) + 5)\n\nfor x, y in zip(avg_life[\"continent\"], avg_life[\"lifeExp\"]):\n    plt.text(x, y + 0.3, f\"{y:.1f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C78A8", "reasoning": "The code uses plt.bar() directly to create vertical bars representing a categorical variable (continent) and a quantitative value (average life expectancy). Since it uses standard matplotlib functions to render the data rather than pandas or seaborn wrappers, the library is matplotlib, and vertical bars are classified as a Column chart in the provided taxonomy."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4gapminder.csv\")\n\n# Aggregate: average life expectancy by continent\nsummary = (\n    df.groupby(\"continent\", as_index=False)[\"lifeExp\"]\n    .mean()\n    .sort_values(\"lifeExp\", ascending=False)\n)\n\n# Plot: single chart (bar chart)\nplt.figure(figsize=(8, 4.8))\nplt.bar(summary[\"continent\"], summary[\"lifeExp\"], color=\"#4C78A8\")\nplt.title(\"Average Life Expectancy by Continent (4gapminder.csv)\")\nplt.xlabel(\"Continent\")\nplt.ylabel(\"Average life expectancy (years)\")\nplt.ylim(0, max(summary[\"lifeExp\"]) * 1.15)\n\n# Add value labels\nfor i, v in enumerate(summary[\"lifeExp\"]):\n    plt.text(i, v + 0.5, f\"{v:.1f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, and since the bars are vertical (the default for plt.bar), it is classified as a Column chart. The library is matplotlib because the pandas .plot() wrapper was not used."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"4gapminder.csv\")\n\n    # Single chart: GDP per Capita vs Life Expectancy, colored by continent\n    continents = df[\"continent\"].unique()\n    cmap = plt.get_cmap(\"tab10\")\n    colors = {c: cmap(i % 10) for i, c in enumerate(sorted(continents))}\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    for c in sorted(continents):\n        d = df[df[\"continent\"] == c]\n        ax.scatter(\n            d[\"gdpPerCap\"],\n            d[\"lifeExp\"],\n            s=35,\n            alpha=0.75,\n            color=colors[c],\n            label=c,\n            edgecolors=\"none\",\n        )\n\n    ax.set_xscale(\"log\")\n    ax.set_xlabel(\"GDP per Capita (log scale)\")\n    ax.set_ylabel(\"Life Expectancy (years)\")\n    ax.set_title(\"Life Expectancy vs GDP per Capita (Gapminder sample)\")\n    ax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.6, alpha=0.4)\n    ax.legend(title=\"Continent\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "tab10", "reasoning": "The plot is rendered using matplotlib's 'ax.scatter' method directly. It visualizes two quantitative variables (gdpPerCap and lifeExp), and although color encodes a categorical variable, the size ('s=35') is constant, making it a Scatterplot according to the taxonomy."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"4gapminder.csv\")\n\n    # Aggregate to one value per continent to make a clean single chart\n    summary = (\n        df.groupby(\"continent\", as_index=False)\n          .agg(avg_lifeExp=(\"lifeExp\", \"mean\"))\n          .sort_values(\"avg_lifeExp\", ascending=True)\n    )\n\n    plt.figure(figsize=(9, 5))\n    plt.barh(summary[\"continent\"], summary[\"avg_lifeExp\"], color=\"#4C78A8\")\n    plt.xlabel(\"Average Life Expectancy\")\n    plt.ylabel(\"Continent\")\n    plt.title(\"Average Life Expectancy by Continent (4gapminder.csv)\")\n\n    for y, v in enumerate(summary[\"avg_lifeExp\"]):\n        plt.text(v + 0.2, y, f\"{v:.1f}\", va=\"center\", fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the plt.barh() function from the matplotlib library to render horizontal bars, which distinguishes it as a Bar chart rather than a Column chart. Although pandas is used for data manipulation, the drawing logic is handled directly by pyplot."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"4gapminder.csv\")\n\n    # Scatter: GDP per Capita vs Life Expectancy, colored by continent, bubble size by population\n    continents = [\"Africa\", \"Americas\", \"Asia\", \"Europe\", \"Oceania\"]\n    colors = {\n        \"Africa\": \"#1f77b4\",\n        \"Americas\": \"#ff7f0e\",\n        \"Asia\": \"#2ca02c\",\n        \"Europe\": \"#d62728\",\n        \"Oceania\": \"#9467bd\",\n    }\n\n    # Bubble size scaling (area in points^2)\n    pop = df[\"population\"].astype(float)\n    size = 20 + 380 * (pop - pop.min()) / (pop.max() - pop.min())\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    for cont in continents:\n        sub = df[df[\"continent\"] == cont].copy()\n        if sub.empty:\n            continue\n        ax.scatter(\n            sub[\"gdpPerCap\"],\n            sub[\"lifeExp\"],\n            s=size[sub.index],\n            c=colors.get(cont, \"gray\"),\n            alpha=0.7,\n            edgecolors=\"white\",\n            linewidths=0.5,\n            label=cont,\n        )\n\n    ax.set_xscale(\"log\")\n    ax.set_xlabel(\"GDP per Capita (log scale)\")\n    ax.set_ylabel(\"Life Expectancy (years)\")\n    ax.set_title(\"Life Expectancy vs GDP per Capita (Bubble size = Population)\")\n    ax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5, alpha=0.4)\n    ax.legend(title=\"Continent\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The plot is created using ax.scatter() from the matplotlib library. It maps two quantitative variables (GDP per capita and Life Expectancy) to the X and Y axes and a third quantitative variable (population) to the marker size ('s'), which matches the definition of a Bubble chart."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"4gapminder.csv\")\n\n    # Scatter: GDP per capita vs Life Expectancy, colored by continent, sized by population\n    continents = df[\"continent\"].unique()\n    colors = dict(zip(continents, plt.cm.tab10.colors[: len(continents)]))\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # Scale population to marker area\n    pop = df[\"population\"].astype(float)\n    sizes = 30 + 470 * (pop - pop.min()) / (pop.max() - pop.min())\n\n    for cont in continents:\n        sub = df[df[\"continent\"] == cont]\n        ax.scatter(\n            sub[\"gdpPerCap\"],\n            sub[\"lifeExp\"],\n            s=sizes[sub.index],\n            alpha=0.75,\n            c=[colors[cont]],\n            edgecolors=\"white\",\n            linewidths=0.5,\n            label=cont,\n        )\n\n    ax.set_xscale(\"log\")\n    ax.set_xlabel(\"GDP per Capita (log scale)\")\n    ax.set_ylabel(\"Life Expectancy (years)\")\n    ax.set_title(\"Life Expectancy vs GDP per Capita (bubble size ~ population)\")\n\n    ax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5, alpha=0.5)\n    ax.legend(title=\"Continent\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "tab10", "reasoning": "The code uses matplotlib's ax.scatter() directly to render the data. It visualizes two quantitative dimensions (gdpPerCap and lifeExp) on the axes and uses a third quantitative variable (population) to modulate the size of the markers, which classifies it as a Bubble chart."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"4gapminder.csv\")\n\n# Gráfico: Relación entre PIB per cápita y esperanza de vida (color por continente, tamaño por población)\ncontinents = df[\"continent\"].unique()\ncmap = plt.get_cmap(\"tab10\")\ncolor_map = {c: cmap(i % 10) for i, c in enumerate(continents)}\n\nplt.figure(figsize=(10, 6))\n\nfor cont in continents:\n    d = df[df[\"continent\"] == cont]\n    plt.scatter(\n        d[\"gdpPerCap\"],\n        d[\"lifeExp\"],\n        s=(d[\"population\"] / df[\"population\"].max()) * 1200 + 20,\n        alpha=0.65,\n        label=cont,\n        c=[color_map[cont]],\n        edgecolors=\"white\",\n        linewidths=0.6,\n    )\n\nplt.xscale(\"log\")\nplt.xlabel(\"PIB per cápita (escala log)\")\nplt.ylabel(\"Esperanza de vida (años)\")\nplt.title(\"PIB per cápita vs Esperanza de vida (tamaño = población)\")\nplt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.6, alpha=0.4)\nplt.legend(title=\"Continente\", frameon=True)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "tab10", "reasoning": "The code uses plt.scatter() directly to render data points. It plots two quantitative variables (PIB per cápita and life expectancy) and uses the 's' parameter to scale the marker size based on a third quantitative variable (population), which classifies it as a Bubble chart."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4gapminder.csv\")\n\n# Prepare for plot: log-scale GDP per capita for better spread\ndf[\"log_gdpPerCap\"] = np.log10(df[\"gdpPerCap\"])\n\n# Visual encodings\ncontinents = [\"Africa\", \"Americas\", \"Asia\", \"Europe\", \"Oceania\"]\ncolors = {\n    \"Africa\": \"#1b9e77\",\n    \"Americas\": \"#d95f02\",\n    \"Asia\": \"#7570b3\",\n    \"Europe\": \"#e7298a\",\n    \"Oceania\": \"#66a61e\",\n}\n\n# Bubble size from population (area proportional)\npop = df[\"population\"].astype(float)\nsizes = 20 + 480 * (np.sqrt(pop) - np.sqrt(pop.min())) / (np.sqrt(pop.max()) - np.sqrt(pop.min()))\n\n# Plot\nfig, ax = plt.subplots(figsize=(10.5, 6.5), dpi=130)\n\nfor c in continents:\n    sub = df[df[\"continent\"] == c]\n    ax.scatter(\n        sub[\"log_gdpPerCap\"],\n        sub[\"lifeExp\"],\n        s=sizes[sub.index],\n        c=colors[c],\n        alpha=0.75,\n        edgecolor=\"white\",\n        linewidth=0.6,\n        label=c,\n    )\n\n# Axis formatting: show log ticks as original values\nticks = np.array([500, 1000, 2000, 5000, 10000, 20000, 40000], dtype=float)\nax.set_xticks(np.log10(ticks))\nax.set_xticklabels([f\"{int(t):,}\" for t in ticks])\n\nax.set_title(\"Life Expectancy vs GDP per Capita (bubble size = population)\", pad=10)\nax.set_xlabel(\"GDP per Capita (USD, log scale)\")\nax.set_ylabel(\"Life Expectancy (years)\")\n\nax.grid(True, which=\"major\", linestyle=\"-\", linewidth=0.6, alpha=0.25)\nax.set_axisbelow(True)\n\nleg = ax.legend(title=\"Continent\", frameon=True, loc=\"lower right\")\nleg.get_frame().set_alpha(0.9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The code uses ax.scatter() from the matplotlib library to render data. It plots two quantitative variables (GDP per capita and Life Expectancy) and uses a third quantitative variable (population) to modulate the size of the markers, fitting the definition of a bubble chart."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"4gapminder.csv\")\n\n# Bubble scatter: GDP per capita vs Life Expectancy, colored by continent, sized by population\ncontinents = [\"Africa\", \"Americas\", \"Asia\", \"Europe\", \"Oceania\"]\ncolors = {\n    \"Africa\": \"#1b9e77\",\n    \"Americas\": \"#d95f02\",\n    \"Asia\": \"#7570b3\",\n    \"Europe\": \"#e7298a\",\n    \"Oceania\": \"#66a61e\",\n}\n\n# Scale population to marker area (points^2)\npop = df[\"population\"].astype(float)\nsizes = 20 + 800 * (pop - pop.min()) / (pop.max() - pop.min())\n\nfig, ax = plt.subplots(figsize=(10.5, 6.5))\n\nfor cont in continents:\n    sub = df[df[\"continent\"] == cont]\n    if sub.empty:\n        continue\n    ax.scatter(\n        sub[\"gdpPerCap\"],\n        sub[\"lifeExp\"],\n        s=sizes[sub.index],\n        c=colors.get(cont, \"#999999\"),\n        alpha=0.65,\n        edgecolors=\"white\",\n        linewidths=0.6,\n        label=cont,\n    )\n\n# Log scale for GDP per cap (standard for income comparisons)\nax.set_xscale(\"log\")\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x:,.0f}\"))\n\nax.set_title(\"Life Expectancy vs GDP per Capita (bubble size = population)\")\nax.set_xlabel(\"GDP per Capita (log scale)\")\nax.set_ylabel(\"Life Expectancy (years)\")\n\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.6, alpha=0.35)\nax.legend(title=\"Continent\", frameon=True, facecolor=\"white\", edgecolor=\"#dddddd\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The data is rendered using the standard Matplotlib 'ax.scatter()' method. It is classified as a bubble chart because it plots two quantitative variables (GDP per capita and Life Expectancy) and uses a third quantitative variable (population) to modulate the size of the markers."}}
{"input_csv_file": "4gapminder.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"4gapminder.csv\")\n\n# Clean/validate\nneeded = {\"country\", \"continent\", \"year\", \"lifeExp\", \"population\", \"gdpPerCap\"}\nmissing = needed - set(df.columns)\nif missing:\n    raise ValueError(f\"Missing columns in CSV: {sorted(missing)}\")\n\ndf = df.dropna(subset=[\"continent\", \"year\", \"lifeExp\", \"population\", \"gdpPerCap\"]).copy()\ndf = df[(df[\"population\"] > 0) & (df[\"gdpPerCap\"] > 0)]\n\n# Bubble scatter: GDP per capita vs Life Expectancy\n# - size encodes population (sqrt scaling)\n# - color encodes continent\ncontinents = sorted(df[\"continent\"].unique())\npalette = {\n    \"Africa\":   \"#1f77b4\",\n    \"Americas\": \"#ff7f0e\",\n    \"Asia\":     \"#2ca02c\",\n    \"Europe\":   \"#d62728\",\n    \"Oceania\":  \"#9467bd\",\n}\ncolors = df[\"continent\"].map(lambda c: palette.get(c, \"#7f7f7f\"))\n\n# Size scaling (area in points^2)\npop = df[\"population\"].to_numpy()\nsizes = 20 + 380 * (np.sqrt(pop) - np.sqrt(pop.min())) / (np.sqrt(pop.max()) - np.sqrt(pop.min()) + 1e-9)\n\nfig, ax = plt.subplots(figsize=(10.5, 6.5))\n\nsc = ax.scatter(\n    df[\"gdpPerCap\"],\n    df[\"lifeExp\"],\n    s=sizes,\n    c=colors,\n    alpha=0.72,\n    linewidth=0.6,\n    edgecolor=\"white\",\n)\n\n# Axes formatting\nax.set_xscale(\"log\")\nax.set_xlabel(\"GDP per Capita (log scale)\")\nax.set_ylabel(\"Life Expectancy (years)\")\nax.set_title(\"Life Expectancy vs GDP per Capita (bubble size = population)\")\n\nax.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.6, alpha=0.35)\n\n# Log tick formatting\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x:,.0f}\" if x >= 1 else f\"${x:g}\"))\n\n# Legend for continents\nhandles = [\n    plt.Line2D([0], [0], marker=\"o\", color=\"w\", label=cont,\n               markerfacecolor=palette.get(cont, \"#7f7f7f\"),\n               markeredgecolor=\"white\", markersize=9)\n    for cont in continents\n]\nleg1 = ax.legend(handles=handles, title=\"Continent\", loc=\"lower right\", frameon=True)\nleg1.get_frame().set_alpha(0.9)\n\n# Size guide (population)\ndef size_for_population(p):\n    return 20 + 380 * (np.sqrt(p) - np.sqrt(pop.min())) / (np.sqrt(pop.max()) - np.sqrt(pop.min()) + 1e-9)\n\nref_pops = np.array([5e6, 5e7, 2e8])\nref_sizes = [size_for_population(p) for p in ref_pops]\nsize_handles = [\n    plt.scatter([], [], s=s, facecolors=\"none\", edgecolors=\"#444\", linewidths=0.9,\n                label=f\"{int(p):,}\")\n    for p, s in zip(ref_pops, ref_sizes)\n]\nleg2 = ax.legend(handles=size_handles, title=\"Population\", loc=\"upper left\", frameon=True, scatterpoints=1)\nleg2.get_frame().set_alpha(0.9)\nax.add_artist(leg1)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The data is rendered using the `ax.scatter()` method from the matplotlib library. It is classified as a Bubble chart because it maps two quantitative variables to the X and Y axes (GDP and Life Expectancy) and uses the size of the points to encode a third quantitative dimension (Population)."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort by earnings gap\ndf = df.sort_values(\"Gap\", ascending=True)\n\n# Plot\nplt.figure(figsize=(10, 7))\nplt.barh(df[\"School\"], df[\"Gap\"], color=\"#4C78A8\")\nplt.title(\"Earnings Gap (Men - Women) by School\")\nplt.xlabel(\"Gap (thousands of $)\")\nplt.ylabel(\"School\")\n\n# Add value labels\nfor y, v in enumerate(df[\"Gap\"]):\n    plt.text(v + 0.8, y, str(v), va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is generated using plt.barh() which is a standard matplotlib function for creating horizontal bars. According to the taxonomy, horizontal bars represent a Bar chart, while vertical bars represent a Column chart."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load the data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort schools by pay gap (largest to smallest) for easier comparison\ndf = df.sort_values(\"Gap\", ascending=False)\n\n# Make a simple chart: Men vs Women earnings by school (with a clear legend)\nplt.figure(figsize=(12, 7))\nx = range(len(df))\n\nbar_w = 0.42\nplt.bar([i - bar_w/2 for i in x], df[\"Women\"], width=bar_w, label=\"Women\")\nplt.bar([i + bar_w/2 for i in x], df[\"Men\"], width=bar_w, label=\"Men\")\n\nplt.xticks(list(x), df[\"School\"], rotation=45, ha=\"right\")\nplt.ylabel(\"Median earnings (thousands of dollars)\")\nplt.title(\"Median Earnings by School: Women vs Men (sorted by Gap)\")\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization uses plt.bar() twice with an manual offset applied to the x-coordinates to create side-by-side vertical bars, which corresponds to a Grouped column chart. Since data is rendered using standard pyplot functions rather than DataFrame wrappers or seaborn, the library is classified as matplotlib."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort schools by earnings gap (largest to smallest)\ndf = df.sort_values(\"Gap\", ascending=False)\n\n# Plot: single chart showing the gender earnings gap by school\nplt.figure(figsize=(10, 7))\nplt.barh(df[\"School\"], df[\"Gap\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()\n\nplt.title(\"Earnings Gap by School (Men - Women)\")\nplt.xlabel(\"Gap (in thousands of dollars)\")\nplt.ylabel(\"School\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses plt.barh() from the matplotlib library to render horizontal bars, classifying it as a Bar chart according to the taxonomy."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort by pay gap (largest to smallest) for easier comparison\ndf = df.sort_values(\"Gap\", ascending=False)\n\n# Plot: horizontal bar chart of the earnings gap by school\nplt.figure(figsize=(10, 8))\nplt.barh(df[\"School\"], df[\"Gap\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()  # largest gap at the top\n\nplt.title(\"Earnings Gap (Men - Women) by School\")\nplt.xlabel(\"Gap (in thousands of dollars)\")\nplt.ylabel(\"School\")\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the `plt.barh()` function from matplotlib to render horizontal bars representing categorical school names and their corresponding quantitative earnings gap values."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort by gap (largest to smallest) for clearer comparison\ndf = df.sort_values(\"Gap\", ascending=False)\n\n# Plot: horizontal bar chart of the earnings gap\nplt.figure(figsize=(10, 7))\nplt.barh(df[\"School\"], df[\"Gap\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()\n\nplt.title(\"Earnings Gap (Men - Women) by School\")\nplt.xlabel(\"Gap\")\nplt.ylabel(\"School\")\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n\n# Annotate values\nfor i, v in enumerate(df[\"Gap\"].values):\n    plt.text(v + 0.8, i, str(v), va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses `plt.barh()` to render the data directly, which identifies the library as matplotlib. Since `plt.barh()` creates horizontal bars, it is classified as a 'Bar chart' according to the taxonomy."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort by Gap (descending) for clearer comparison\ndf = df.sort_values(\"Gap\", ascending=False)\n\n# Plot: single chart (horizontal bar chart of gender earnings gap)\nplt.figure(figsize=(10, 7))\nplt.barh(df[\"School\"], df[\"Gap\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()\n\nplt.title(\"Earnings Gap by School (Men - Women)\")\nplt.xlabel(\"Gap (thousands of dollars)\")\nplt.ylabel(\"School\")\n\n# Add value labels\nfor i, v in enumerate(df[\"Gap\"].values):\n    plt.text(v + 0.8, i, str(v), va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib function `plt.barh()` to render the data as horizontal bars, and does not use Seaborn or Pandas plotting methods."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    # Load data\n    df = pd.read_csv(\"4school_earnings.csv\")\n\n    # Sort by gap for clearer comparison\n    df = df.sort_values(\"Gap\", ascending=True)\n\n    # Single chart: horizontal bar chart of gender earnings gap by school\n    plt.figure(figsize=(10, 8))\n    plt.barh(df[\"School\"], df[\"Gap\"], color=\"#4C78A8\")\n    plt.xlabel(\"Earnings Gap (Men - Women)\")\n    plt.ylabel(\"School\")\n    plt.title(\"Earnings Gap by School (Men - Women)\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the plt.barh() function from the matplotlib library to render horizontal bars based on school names and earnings gap values."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"4school_earnings.csv\")\n    df = df.sort_values(\"Gap\", ascending=True)\n\n    fig, ax = plt.subplots(figsize=(10, 7))\n\n    ax.barh(df[\"School\"], df[\"Women\"], label=\"Women\", color=\"#4C78A8\")\n    ax.barh(df[\"School\"], df[\"Men\"], left=df[\"Women\"], label=\"Men\", color=\"#F58518\")\n\n    ax.set_title(\"Earnings by School (Women vs Men, stacked)\")\n    ax.set_xlabel(\"Earnings\")\n    ax.set_ylabel(\"School\")\n    ax.legend(loc=\"lower right\")\n\n    ax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n    ax.set_axisbelow(True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses the Matplotlib `ax.barh()` method directly to render the data. The 'left' parameter is used to stack the 'Men' data on top of the 'Women' data horizontally, which classifies it as a Stacked bar chart."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort by gap (descending) for clearer comparison\ndf = df.sort_values(\"Gap\", ascending=False)\n\n# Plot\nplt.figure(figsize=(10, 7))\nplt.barh(df[\"School\"], df[\"Gap\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()\n\nplt.title(\"Brecha salarial (Men - Women) por universidad\")\nplt.xlabel(\"Gap (miles de USD)\")\nplt.ylabel(\"School\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the matplotlib function plt.barh() to render the data directly, which creates horizontal bars. According to the taxonomy, horizontal layouts are classified as Bar charts, and the direct use of plt functions identifies the library as matplotlib."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort by earnings gap (largest to smallest)\ndf = df.sort_values(\"Gap\", ascending=False).reset_index(drop=True)\n\nschools = df[\"School\"].tolist()\nwomen = df[\"Women\"].to_numpy()\nmen = df[\"Men\"].to_numpy()\ngap = df[\"Gap\"].to_numpy()\ny = np.arange(len(df))\n\n# Figure\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 8.5))\n\n# Dumbbell (connected dots) chart\nfor i in range(len(df)):\n    ax.plot([women[i], men[i]], [y[i], y[i]], color=\"#9aa0a6\", lw=2.2, zorder=1)\n\nax.scatter(women, y, s=90, color=\"#1f77b4\", edgecolor=\"white\", linewidth=0.8, zorder=3, label=\"Women\")\nax.scatter(men, y, s=90, color=\"#d62728\", edgecolor=\"white\", linewidth=0.8, zorder=3, label=\"Men\")\n\n# Gap labels at the right of men's marker\nfor i in range(len(df)):\n    ax.text(men[i] + 1.5, y[i], f\"+{gap[i]}\", va=\"center\", ha=\"left\",\n            fontsize=9.5, color=\"#111827\")\n\n# Axes & labels\nax.set_yticks(y)\nax.set_yticklabels(schools, fontsize=10)\nax.invert_yaxis()\n\nxmin = min(women.min(), men.min()) - 5\nxmax = max(women.max(), men.max()) + 18\nax.set_xlim(xmin, xmax)\n\nax.set_xlabel(\"Median annual earnings (in $1,000s)\", fontsize=11)\nax.set_title(\"Median Earnings by Gender Across Top Universities\\n(Labels show Men's − Women's gap, $1,000s)\",\n             fontsize=13, weight=\"bold\", pad=12)\n\n# Legend\nax.legend(loc=\"lower right\", frameon=True, framealpha=0.95)\n\n# Clean spines\nfor spine in [\"top\", \"right\", \"left\"]:\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses standard matplotlib axes functions (ax.scatter and ax.plot) to render data. The chart uses a categorical Y-axis (Schools) and a quantitative X-axis (Earnings) with points, fitting the definition of a Dot plot."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort by gap (descending) for a ranked view\ndf = df.sort_values(\"Gap\", ascending=False).reset_index(drop=True)\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 8))\n\ny = np.arange(len(df))\nbar_color = \"#2b8cbe\"\n\nax.barh(y, df[\"Gap\"], color=bar_color)\n\n# Labels and formatting\nax.set_yticks(y)\nax.set_yticklabels(df[\"School\"])\nax.invert_yaxis()  # largest gap at top\nax.set_xlabel(\"Earnings Gap (Men - Women)\")\nax.set_title(\"Earnings Gap by School (Men vs Women)\")\n\n# Add value labels\nfor i, v in enumerate(df[\"Gap\"].values):\n    ax.text(v + max(df[\"Gap\"]) * 0.01, i, f\"{v}\", va=\"center\", ha=\"left\", fontsize=9)\n\n# X limits with padding\nax.set_xlim(0, df[\"Gap\"].max() * 1.15)\n\n# Subtle footnote\nfig.text(0.99, 0.01, \"Source: 4school_earnings.csv\", ha=\"right\", va=\"bottom\", fontsize=9, color=\"#444\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is created using the `ax.barh()` function from the Matplotlib library. Following the taxonomy, horizontal bars represent a 'Bar chart' (as opposed to vertical 'Column charts'). A single hex color is provided rather than a named categorical or sequential color palette."}}
{"input_csv_file": "4school_earnings.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"4school_earnings.csv\")\n\n# Sort by earnings gap (largest to smallest)\ndf = df.sort_values(\"Gap\", ascending=False).reset_index(drop=True)\n\n# Positions\ny = np.arange(len(df))\n\n# Figure\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 9))\n\n# Dumbbell chart (Men vs Women)\nax.hlines(y=y, xmin=df[\"Women\"], xmax=df[\"Men\"], color=\"#B0B0B0\", linewidth=2, zorder=1)\nax.scatter(df[\"Women\"], y, s=70, color=\"#2C7FB8\", label=\"Women\", zorder=3)\nax.scatter(df[\"Men\"], y, s=70, color=\"#D95F0E\", label=\"Men\", zorder=3)\n\n# Gap labels\nfor i, (w, m, g) in enumerate(zip(df[\"Women\"], df[\"Men\"], df[\"Gap\"])):\n    ax.text(m + 1.5, i, f\"+{g}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#444444\")\n\n# Axes & labels\nax.set_yticks(y)\nax.set_yticklabels(df[\"School\"])\nax.invert_yaxis()\nax.set_xlabel(\"Median earnings (in $1,000s)\")\nax.set_title(\"Earnings by School: Men vs Women (Sorted by Gap)\", pad=12)\n\n# Limits and formatting\nxmin = max(0, min(df[\"Women\"].min(), df[\"Men\"].min()) - 10)\nxmax = max(df[\"Women\"].max(), df[\"Men\"].max()) + 20\nax.set_xlim(xmin, xmax)\n\n# Legend\nax.legend(loc=\"lower right\", frameon=True)\n\n# Clean spines\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The visualization is created using standard matplotlib axes methods (ax.hlines and ax.scatter) directly rather than using seaborn or pandas plotting wrappers. It is classified as a Dot plot because it uses a discrete Y-axis (Schools) and quantitative X-axis (Earnings) with markers (scatter points) representing the data values."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Prepare plot\ncategories = df[\"category\"].tolist()\nactual = df[\"actual_sales\"].to_numpy()\ntarget = df[\"target_sales\"].to_numpy()\n\ny = range(len(categories))\nbar_h = 0.6\n\nplt.figure(figsize=(8, 3.5))\nax = plt.gca()\n\n# Target bars (background)\nax.barh(y, target, height=bar_h, color=\"#D9D9D9\", edgecolor=\"none\", label=\"Target\")\n\n# Actual bars (foreground)\nax.barh(y, actual, height=bar_h * 0.55, color=\"#4C78A8\", edgecolor=\"none\", label=\"Actual\")\n\n# Labels and styling\nax.set_yticks(list(y))\nax.set_yticklabels(categories)\nax.invert_yaxis()  # Q1 at top\nax.set_xlabel(\"Sales\")\nax.set_title(\"Sales Performance: Actual vs Target\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Legend\nax.legend(loc=\"lower right\", frameon=False)\n\n# Annotate values\nfor i, (a, t) in enumerate(zip(actual, target)):\n    ax.text(t + max(target) * 0.01, i, f\"Target {t}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#555555\")\n    ax.text(a + max(target) * 0.01, i, f\"Actual {a}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#1f3a5f\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() functions to overlay 'actual' sales bars on top of 'target' sales bars for specific categories, fitting the taxonomy definition of a Bullet chart (Categorical + two quantitative values where one is a reference)."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Sort categories in original order (as provided)\ncategories = df[\"category\"].tolist()\nactual = df[\"actual_sales\"].to_numpy()\ntarget = df[\"target_sales\"].to_numpy()\n\nx = np.arange(len(categories))\nwidth = 0.38\n\nfig, ax = plt.subplots(figsize=(8, 4.8))\n\n# Bars: Actual vs Target\nax.bar(x - width/2, actual, width, label=\"Actual Sales\", color=\"#2E86AB\")\nax.bar(x + width/2, target, width, label=\"Target Sales\", color=\"#B0B7C3\")\n\n# Labels and styling\nax.set_title(\"Actual vs Target Sales by Quarter\")\nax.set_xlabel(\"Category (Quarter)\")\nax.set_ylabel(\"Sales\")\nax.set_xticks(x)\nax.set_xticklabels(categories)\nax.set_ylim(0, max(actual.max(), target.max()) * 1.15)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nax.legend(frameon=False)\n\n# Annotate bars\nfor i, v in enumerate(actual):\n    ax.text(i - width/2, v + 1, str(v), ha=\"center\", va=\"bottom\", fontsize=9)\nfor i, v in enumerate(target):\n    ax.text(i + width/2, v + 1, str(v), ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.bar() function twice with calculated offsets to create vertical side-by-side bars for 'Actual' and 'Target' sales, which defines a grouped column chart."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Plot: Actual vs Target Sales by category\nx = range(len(df))\nwidth = 0.38\n\nplt.figure(figsize=(8, 4.5))\nplt.bar([i - width/2 for i in x], df[\"actual_sales\"], width=width, label=\"Actual Sales\")\nplt.bar([i + width/2 for i in x], df[\"target_sales\"], width=width, label=\"Target Sales\")\n\nplt.xticks(list(x), df[\"category\"])\nplt.ylabel(\"Sales\")\nplt.title(\"Actual vs Target Sales by Quarter\")\nplt.legend(frameon=False)\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly from the matplotlib library to render data. The bars are oriented vertically, making it a column chart, and it plots two distinct series (actual vs target sales) side-by-side for each categorical x-axis entry, which identifies it as a grouped column chart."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Plot: Actual vs Target Sales by Quarter\nx = range(len(df))\nplt.figure(figsize=(8, 4.5))\n\nplt.bar([i - 0.2 for i in x], df[\"actual_sales\"], width=0.4, label=\"Actual Sales\")\nplt.bar([i + 0.2 for i in x], df[\"target_sales\"], width=0.4, label=\"Target Sales\")\n\nplt.xticks(list(x), df[\"category\"])\nplt.ylabel(\"Sales\")\nplt.title(\"Actual vs Target Sales by Quarter\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, which identifies the library as matplotlib. Since the bars are vertical (plt.bar) and placed side-by-side using manual offsets for two different series (actual_sales vs target_sales) across categorical labels, it is classified as a Grouped column chart."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Plot: bullet-style horizontal bars (target as background, actual as foreground)\ndf_sorted = df.sort_values(\"category\")\ny = range(len(df_sorted))\n\nfig, ax = plt.subplots(figsize=(8, 3.6))\n\n# Target (background)\nax.barh(y, df_sorted[\"target_sales\"], color=\"#d9d9d9\", height=0.6, label=\"Target\")\n\n# Actual (foreground)\nax.barh(y, df_sorted[\"actual_sales\"], color=\"#2f5597\", height=0.35, label=\"Actual\")\n\n# Labels and styling\nax.set_yticks(list(y))\nax.set_yticklabels(df_sorted[\"category\"])\nax.set_xlabel(\"Sales\")\nax.set_title(\"Sales Performance: Actual vs Target\")\n\n# Add value labels for actual\nfor i, (a, t) in enumerate(zip(df_sorted[\"actual_sales\"], df_sorted[\"target_sales\"])):\n    ax.text(a + max(df_sorted[\"target_sales\"]) * 0.01, i, f\"{a}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#2f5597\")\n    ax.text(t + max(df_sorted[\"target_sales\"]) * 0.01, i, f\"{t}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#666666\")\n\nax.set_xlim(0, max(df_sorted[\"target_sales\"]) * 1.15)\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.3)\nax.legend(loc=\"lower right\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() to visualize categorical data (categories) against two quantitative dimensions (actual_sales and target_sales), where the target acts as a reference value. This structure follows the taxonomy definition for a Bullet chart."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Sort categories if needed (Q1~Q4)\norder = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\ndf[\"category\"] = pd.Categorical(df[\"category\"], categories=order, ordered=True)\ndf = df.sort_values(\"category\")\n\n# Create bullet-style chart (single chart)\nfig, ax = plt.subplots(figsize=(8, 3.2))\n\ny = np.arange(len(df))\nmax_val = max(df[\"actual_sales\"].max(), df[\"target_sales\"].max()) * 1.15\n\n# Background (target) bars\nax.barh(y, df[\"target_sales\"], height=0.55, color=\"#d9d9d9\", edgecolor=\"none\", label=\"Target\")\n\n# Foreground (actual) bars\nax.barh(y, df[\"actual_sales\"], height=0.28, color=\"#2b6cb0\", edgecolor=\"none\", label=\"Actual\")\n\n# Target markers (thin line at target)\nfor i, t in enumerate(df[\"target_sales\"]):\n    ax.vlines(t, i - 0.30, i + 0.30, colors=\"#444444\", linewidth=2)\n\n# Labels and styling\nax.set_yticks(y)\nax.set_yticklabels(df[\"category\"])\nax.set_xlim(0, max_val)\nax.set_xlabel(\"Sales\")\nax.set_title(\"Sales Performance (Bullet Chart)\")\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Legend\nax.legend(loc=\"lower right\", frameon=False, ncols=2)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's 'ax.barh' and 'ax.vlines' functions directly to render the data. The visualization is classified as a Bullet chart because it represents actual versus target performance across categorical variables using overlapping horizontal bars and reference markers."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Prepare\ncategories = df[\"category\"].astype(str).tolist()\nactual = df[\"actual_sales\"].to_numpy()\ntarget = df[\"target_sales\"].to_numpy()\ny = np.arange(len(categories))\n\n# Figure (single chart)\nfig, ax = plt.subplots(figsize=(9, 4.8))\n\n# Background (target) bars\nax.barh(y, target, height=0.55, color=\"#d9d9d9\", edgecolor=\"none\", label=\"Target\")\n\n# Foreground (actual) bars\nax.barh(y, actual, height=0.28, color=\"#2c7fb8\", edgecolor=\"none\", label=\"Actual\")\n\n# Labels/annotations\nfor i, (a, t) in enumerate(zip(actual, target)):\n    ax.text(max(a, t) + 1, i, f\"Actual {a} / Target {t}\", va=\"center\", ha=\"left\", fontsize=9)\n\n# Styling\nax.set_yticks(y, labels=categories)\nax.invert_yaxis()  # Q1 at top\nax.set_xlabel(\"Sales\")\nax.set_title(\"Sales Performance (Actual vs Target)\")\nax.set_xlim(0, max(target.max(), actual.max()) * 1.25)\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.legend(loc=\"lower right\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() to create horizontal bars comparing categorical categories with two quantitative variables (actual_sales and target_sales), which fits the taxonomy definition of a Bullet chart (Bar chart with reference values)."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Read data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Sort to keep a consistent order (Q1..Q4 if present)\ndf[\"category\"] = pd.Categorical(df[\"category\"], categories=sorted(df[\"category\"].unique()), ordered=True)\ndf = df.sort_values(\"category\")\n\n# Plot: bullet-style horizontal bars (target as background, actual as overlay)\nfig, ax = plt.subplots(figsize=(8, 3.2))\n\ny = range(len(df))\nax.barh(y, df[\"target_sales\"], color=\"#d0d0d0\", height=0.55, label=\"Target\")\nax.barh(y, df[\"actual_sales\"], color=\"#2c7fb8\", height=0.28, label=\"Actual\")\n\nax.set_yticks(list(y))\nax.set_yticklabels(df[\"category\"])\nax.set_xlabel(\"Sales\")\nax.set_title(\"Sales Performance: Actual vs Target\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\n\n# Add value labels for actual\nfor i, (a, t) in enumerate(zip(df[\"actual_sales\"], df[\"target_sales\"])):\n    ax.text(a + max(df[\"target_sales\"]) * 0.01, i, f\"{a}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#1b4f72\")\n    ax.text(t + max(df[\"target_sales\"]) * 0.01, i, f\"{t}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#555555\")\n\nax.legend(loc=\"lower right\", frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"error": "JSON Parsing Failed: Expecting property name enclosed in double quotes: line 6 column 1 (char 318)", "raw_text": "{\n    \"library\": \"matplotlib\",\n    \"chart_type\": \"Bullet chart\",\n    \"color_palette\": null,\n    \"reasoning\": \"The visualization uses matplotlib's ax.barh() to overlay two different quantitative metrics (Actual and Target) against a categorical dimension, which aligns with the taxonomy definition of a Bullet chart.\",\n}"}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Create chart\nplt.figure(figsize=(8, 4.5))\nx = range(len(df))\n\nplt.bar(x, df[\"actual_sales\"], width=0.6, color=\"#4C78A8\", label=\"Actual\")\nplt.plot(x, df[\"target_sales\"], color=\"#F58518\", marker=\"o\", linewidth=2, label=\"Target\")\n\nplt.xticks(list(x), df[\"category\"])\nplt.ylabel(\"Sales\")\nplt.title(\"Sales Performance: Actual vs Target by Quarter\")\nplt.ylim(0, max(df[\"actual_sales\"].max(), df[\"target_sales\"].max()) * 1.15)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.legend(frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's plt.bar and plt.plot functions directly to render data. It represents a categorical variable (category) against two quantitative variables (actual_sales and target_sales), where the target line serves as a reference value. This structure matches the taxonomy definition for a Bullet chart (a bar chart with reference values and two quantitative variables)."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Sort to keep the displayed order (Q1..Q4)\ndf[\"category\"] = pd.Categorical(df[\"category\"], categories=df[\"category\"].tolist(), ordered=True)\ndf = df.sort_values(\"category\")\n\n# Figure\nplt.rcParams.update({\"font.size\": 11})\nfig, ax = plt.subplots(figsize=(8, 3.2))\n\ny = range(len(df))\nbar_h = 0.55\n\n# Target (background) bars\nax.barh(\n    y,\n    df[\"target_sales\"],\n    height=bar_h,\n    color=\"#d9d9d9\",\n    edgecolor=\"none\",\n    label=\"Target\"\n)\n\n# Actual bars (foreground)\nactual_colors = [\"#2ca02c\" if a >= t else \"#1f77b4\" for a, t in zip(df[\"actual_sales\"], df[\"target_sales\"])]\nax.barh(\n    y,\n    df[\"actual_sales\"],\n    height=bar_h * 0.65,\n    color=actual_colors,\n    edgecolor=\"none\",\n    label=\"Actual\"\n)\n\n# Labels and annotations\nax.set_yticks(list(y))\nax.set_yticklabels(df[\"category\"])\nax.invert_yaxis()\n\nxmax = max(df[\"target_sales\"].max(), df[\"actual_sales\"].max()) * 1.15\nax.set_xlim(0, xmax)\nax.set_xlabel(\"Sales\")\nax.set_title(\"Bullet Chart: Actual vs Target Sales\")\n\nfor i, (a, t) in enumerate(zip(df[\"actual_sales\"], df[\"target_sales\"])):\n    ax.text(a + xmax * 0.01, i, f\"{a}\", va=\"center\", ha=\"left\")\n    ax.text(t + xmax * 0.01, i, f\"Target {t}\", va=\"center\", ha=\"left\", color=\"#555555\")\n\n# Style\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nfor spine in [\"top\", \"right\", \"left\"]:\n    ax.spines[spine].set_visible(False)\nax.legend(loc=\"lower right\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"error": "JSON Parsing Failed: Expecting property name enclosed in double quotes: line 6 column 1 (char 394)", "raw_text": "{\n    \"library\": \"matplotlib\",\n    \"chart_type\": \"Bullet chart\",\n    \"color_palette\": null,\n    \"reasoning\": \"The visualization uses matplotlib's ax.barh() to layer two horizontal bars per category (Actual vs. Target), which fits the taxonomy definition for a Bullet chart. Since it uses direct axes methods for rendering rather than pandas wrappers, the library is classified as matplotlib.\",\n}"}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Prepare\ncategories = df[\"category\"].astype(str).tolist()\nactual = df[\"actual_sales\"].to_numpy()\ntarget = df[\"target_sales\"].to_numpy()\n\ny = np.arange(len(categories))\n\n# Figure\nfig, ax = plt.subplots(figsize=(9, 3.8), dpi=140)\n\n# Colors\ntarget_color = \"#D6DCE5\"   # light gray-blue\nactual_color = \"#2F6FED\"   # blue\ntext_color = \"#1F2937\"\n\n# Plot \"bullet\" bars: target as background, actual as foreground\nax.barh(y, target, height=0.55, color=target_color, edgecolor=\"none\", zorder=1, label=\"Target\")\nax.barh(y, actual, height=0.28, color=actual_color, edgecolor=\"none\", zorder=2, label=\"Actual\")\n\n# Annotations and delta\nfor i, (a, t) in enumerate(zip(actual, target)):\n    delta = a - t\n    delta_str = f\"{delta:+d}\"\n    ax.text(max(a, t) + 1.2, i, f\"Actual {a}  |  Target {t}  ({delta_str})\",\n            va=\"center\", ha=\"left\", fontsize=9, color=text_color)\n\n# Styling\nax.set_yticks(y)\nax.set_yticklabels(categories, fontsize=10, color=text_color)\nax.invert_yaxis()  # Q1 at top\n\nxmax = int(max(target.max(), actual.max()) * 1.18)\nax.set_xlim(0, xmax)\n\nax.set_title(\"Sales Performance (Bullet Chart): Actual vs Target by Quarter\",\n             fontsize=12, pad=10, color=text_color)\n\nax.grid(axis=\"x\", color=\"#E5E7EB\", linewidth=0.8)\nax.set_axisbelow(True)\n\nfor spine in [\"top\", \"right\", \"left\"]:\n    ax.spines[spine].set_visible(False)\nax.spines[\"bottom\"].set_color(\"#E5E7EB\")\n\nax.tick_params(axis=\"x\", colors=\"#374151\")\nax.tick_params(axis=\"y\", length=0)\n\nax.legend(loc=\"lower right\", frameon=False, fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() function to create a comparison between two quantitative variables (actual and target) against a categorical dimension, which fits the taxonomy definition of a Bullet chart."}}
{"input_csv_file": "5_bullet_sales_performance.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"5_bullet_sales_performance.csv\")\n\n# Sort categories in file order\ndf[\"category\"] = pd.Categorical(df[\"category\"], categories=df[\"category\"].tolist(), ordered=True)\ndf = df.sort_values(\"category\")\n\n# Plot (single chart)\nfig, ax = plt.subplots(figsize=(9, 4.8))\n\ny = range(len(df))\nbar_h = 0.55\n\n# Target bars (background)\nax.barh(\n    y,\n    df[\"target_sales\"],\n    height=bar_h,\n    color=\"#D6D9DE\",\n    edgecolor=\"none\",\n    label=\"Target\",\n    zorder=1,\n)\n\n# Actual bars (foreground)\nax.barh(\n    y,\n    df[\"actual_sales\"],\n    height=bar_h * 0.65,\n    color=\"#2A6FBB\",\n    edgecolor=\"none\",\n    label=\"Actual\",\n    zorder=2,\n)\n\n# Value labels\nfor i, (a, t) in enumerate(zip(df[\"actual_sales\"], df[\"target_sales\"])):\n    ax.text(a + 1, i, f\"{a}\", va=\"center\", ha=\"left\", fontsize=10, color=\"#1F2D3D\")\n    ax.text(t + 1, i, f\"Target {t}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#6B7280\")\n\n# Axes / styling\nax.set_yticks(list(y))\nax.set_yticklabels(df[\"category\"], fontsize=11)\nax.invert_yaxis()\n\nax.set_xlabel(\"Sales\", fontsize=11)\nax.set_title(\"Sales Performance vs Target (Bullet-Style)\", fontsize=13, pad=10)\n\nmax_x = max(df[\"target_sales\"].max(), df[\"actual_sales\"].max())\nax.set_xlim(0, max_x * 1.18)\n\nax.grid(axis=\"x\", linestyle=\"--\", linewidth=0.7, alpha=0.35, zorder=0)\nfor spine in [\"top\", \"right\", \"left\"]:\n    ax.spines[spine].set_visible(False)\nax.spines[\"bottom\"].set_alpha(0.3)\n\nax.legend(loc=\"lower right\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The visualization is created using direct calls to matplotlib's axes object (ax.barh). It is classified as a Bullet chart because it displays horizontal bars comparing a categorical variable against two quantitative dimensions (actual vs. target) using a reference-value layout."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ncsv_path = \"5_bullet_student_scores_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Sort for consistent ordering\ngrade_order = [\"Middle\", \"High\", \"College\"]\nsubject_order = [\"Math\", \"Science\", \"History\", \"English\", \"Art\"]\n\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grade_order, ordered=True)\ndf[\"subject\"] = pd.Categorical(df[\"subject\"], categories=subject_order, ordered=True)\ndf = df.sort_values([\"subject\", \"grade_level\"])\n\n# Prepare plotting positions (grouped by subject)\nsubjects = df[\"subject\"].cat.categories.tolist()\ngrades = df[\"grade_level\"].cat.categories.tolist()\n\nx_centers = np.arange(len(subjects))\noffsets = np.linspace(-0.25, 0.25, len(grades))\nbar_width = 0.22\n\nfig, ax = plt.subplots(figsize=(11, 6))\n\n# Bars for average scores by grade level\nfor i, grade in enumerate(grades):\n    sub = df[df[\"grade_level\"] == grade].set_index(\"subject\").reindex(subjects)\n    ax.bar(\n        x_centers + offsets[i],\n        sub[\"average_score\"].values,\n        width=bar_width,\n        label=f\"Average ({grade})\",\n        zorder=2\n    )\n\n# Benchmark markers (same for all grades within each subject)\nbench = df.drop_duplicates(\"subject\").set_index(\"subject\").reindex(subjects)[\"benchmark_score\"].values\nax.scatter(\n    x_centers,\n    bench,\n    color=\"black\",\n    marker=\"_\",\n    s=600,\n    linewidths=3,\n    label=\"Benchmark\",\n    zorder=3\n)\n\n# Styling\nax.set_title(\"Student Average Scores vs Benchmark by Subject and Grade Level\")\nax.set_xlabel(\"Subject\")\nax.set_ylabel(\"Score\")\nax.set_xticks(x_centers)\nax.set_xticklabels(subjects)\nax.set_ylim(0, 100)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35, zorder=1)\nax.legend(ncols=2, frameon=False, loc=\"upper left\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.bar` function within a loop using manual offsets to create grouped vertical bars for each 'grade_level' category within each 'subject'. This structure classifies it as a Grouped column chart."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_student_scores_large.csv\")\n\n# Keep a consistent grade order\ngrade_order = [\"Middle\", \"High\", \"College\"]\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grade_order, ordered=True)\n\n# Pivot so we can make grouped bars by subject and grade\npivot_avg = df.pivot(index=\"subject\", columns=\"grade_level\", values=\"average_score\").loc[\n    [\"Math\", \"Science\", \"History\", \"English\", \"Art\"]\n]\npivot_bench = df.groupby(\"subject\")[\"benchmark_score\"].first().loc[pivot_avg.index]\n\nsubjects = pivot_avg.index.tolist()\ngrades = pivot_avg.columns.tolist()\n\n# Plot (single chart)\nfig, ax = plt.subplots(figsize=(11, 5.5))\n\nx = np.arange(len(subjects))\nwidth = 0.22\noffsets = np.linspace(-width, width, len(grades))\n\ncolors = {\"Middle\": \"#4C78A8\", \"High\": \"#F58518\", \"College\": \"#54A24B\"}\n\nfor i, g in enumerate(grades):\n    ax.bar(\n        x + offsets[i],\n        pivot_avg[g].values,\n        width=width,\n        label=f\"{g} (Average)\",\n        color=colors.get(g, None),\n        alpha=0.9,\n        edgecolor=\"white\",\n        linewidth=0.7,\n    )\n\n# Benchmark lines per subject (thin dashed segment spanning the group)\nfor xi, subj in enumerate(subjects):\n    yb = float(pivot_bench.loc[subj])\n    ax.hlines(\n        yb,\n        xi - (width * 1.5),\n        xi + (width * 1.5),\n        colors=\"black\",\n        linestyles=\"--\",\n        linewidth=1.6,\n    )\n\nax.set_title(\"Student Average Scores vs Benchmark by Subject and Grade Level\")\nax.set_xlabel(\"Subject\")\nax.set_ylabel(\"Score\")\nax.set_xticks(x)\nax.set_xticklabels(subjects)\nax.set_ylim(65, 100)\n\n# Legend entry for benchmark\nfrom matplotlib.lines import Line2D\nbench_handle = Line2D([0], [0], color=\"black\", lw=1.6, linestyle=\"--\", label=\"Benchmark\")\nhandles, labels = ax.get_legend_handles_labels()\nhandles.append(bench_handle)\nlabels.append(\"Benchmark\")\nax.legend(handles, labels, ncols=2, frameon=False, loc=\"upper left\")\n\nax.grid(axis=\"y\", linestyle=\":\", alpha=0.5)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.bar()` function to draw data directly. The plot consists of vertical bars grouped by 'grade_level' for each 'subject', which fits the definition of a Grouped column chart. While benchmark lines are added, the primary rendering of the quantitative data is through grouped vertical bars."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_student_scores_large.csv\")\n\n# Ensure grade level order\ngrade_order = [\"Middle\", \"High\", \"College\"]\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grade_order, ordered=True)\n\n# Sort for consistent plotting\ndf = df.sort_values([\"subject\", \"grade_level\"]).reset_index(drop=True)\n\n# Prepare colors based on meeting benchmark\ndf[\"meets_benchmark\"] = df[\"average_score\"] >= df[\"benchmark_score\"]\ncolors = df[\"meets_benchmark\"].map({True: \"#2ca02c\", False: \"#d62728\"}).to_list()\n\n# Create a single chart: dot plot of Average vs Benchmark per Subject-Grade\nfig, ax = plt.subplots(figsize=(11, 7))\n\ny = np.arange(len(df))\n\n# Plot average scores (colored by whether they meet benchmark)\nax.scatter(df[\"average_score\"], y, s=120, c=colors, edgecolor=\"black\", linewidth=0.6, zorder=3, label=\"Average score\")\n\n# Plot benchmark scores (same benchmark shown as a reference 'x' for each row)\nax.scatter(df[\"benchmark_score\"], y, s=90, marker=\"x\", c=\"#1f77b4\", linewidth=2.2, zorder=4, label=\"Benchmark\")\n\n# Add subtle guide lines\nfor i in range(len(df)):\n    ax.hlines(y=i, xmin=min(df.loc[i, \"average_score\"], df.loc[i, \"benchmark_score\"]),\n              xmax=max(df.loc[i, \"average_score\"], df.loc[i, \"benchmark_score\"]),\n              color=\"0.85\", linewidth=2, zorder=1)\n\n# Labels for each row (Subject - Grade)\nrow_labels = df.apply(lambda r: f\"{r['subject']} - {r['grade_level']}\", axis=1)\nax.set_yticks(y)\nax.set_yticklabels(row_labels)\n\n# Axis formatting\nxmin = min(df[\"average_score\"].min(), df[\"benchmark_score\"].min()) - 5\nxmax = max(df[\"average_score\"].max(), df[\"benchmark_score\"].max()) + 5\nax.set_xlim(xmin, xmax)\nax.set_xlabel(\"Score\")\nax.set_title(\"Student Average Scores vs Benchmarks by Subject and Grade Level\")\n\n# Legend and grid\nax.legend(loc=\"lower right\", frameon=True)\nax.grid(axis=\"x\", color=\"0.9\", linewidth=1)\nax.set_axisbelow(True)\n\n# Add a simple key for colors (meets / below benchmark) using dummy points\nax.scatter([], [], s=120, c=\"#2ca02c\", edgecolor=\"black\", linewidth=0.6, label=\"Meets benchmark\")\nax.scatter([], [], s=120, c=\"#d62728\", edgecolor=\"black\", linewidth=0.6, label=\"Below benchmark\")\nhandles, labels = ax.get_legend_handles_labels()\n# Remove duplicates while preserving order\nseen = set()\nunique = []\nfor h, l in zip(handles, labels):\n    if l not in seen:\n        unique.append((h, l))\n        seen.add(l)\nax.legend([h for h, _ in unique], [l for _, l in unique], loc=\"lower right\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The visualization uses matplotlib's ax.scatter() to plot quantitative scores against a discrete Y-axis (representing subject and grade level categories), which aligns with the definition of a Dot plot. The coloring is handled via manual hex code mapping rather than a named palette."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_student_scores_large.csv\")\n\n# Prepare labels and values\ndf[\"label\"] = df[\"subject\"] + \" - \" + df[\"grade_level\"]\navg = df[\"average_score\"].to_numpy()\nbench = df[\"benchmark_score\"].to_numpy()\ny = np.arange(len(df))\n\n# Plot (single chart)\nplt.figure(figsize=(10, 6))\nplt.barh(y, avg, color=\"#4C78A8\", label=\"Average score\")\nplt.scatter(bench, y, color=\"#F58518\", s=60, zorder=3, label=\"Benchmark\")\n\n# Styling\nplt.yticks(y, df[\"label\"])\nplt.xlabel(\"Score\")\nplt.title(\"Student Average Scores vs Benchmark (by Subject and Grade Level)\")\nplt.xlim(0, 100)\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nplt.legend(loc=\"lower right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's plt.barh() and plt.scatter() functions to render data directly. It visualizes a categorical variable (subject/grade label) alongside two quantitative variables (average score and benchmark score), where the scatter point acts as a reference value, fitting the taxonomy definition of a Bullet chart."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_student_scores_large.csv\")\n\n# Order categories\nsubjects = [\"Math\", \"Science\", \"History\", \"English\", \"Art\"]\ngrades = [\"Middle\", \"High\", \"College\"]\n\ndf[\"subject\"] = pd.Categorical(df[\"subject\"], categories=subjects, ordered=True)\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grades, ordered=True)\ndf = df.sort_values([\"subject\", \"grade_level\"])\n\n# Build positions\nx = np.arange(len(subjects))\nbar_w = 0.22\noffsets = {\"Middle\": -bar_w, \"High\": 0.0, \"College\": bar_w}\n\nfig, ax = plt.subplots(figsize=(11, 6))\n\n# Plot average scores as grouped bars and benchmark as markers\ncolors = {\"Middle\": \"#4C78A8\", \"High\": \"#F58518\", \"College\": \"#54A24B\"}\n\nfor g in grades:\n    sub = df[df[\"grade_level\"] == g].set_index(\"subject\").reindex(subjects)\n    xpos = x + offsets[g]\n    ax.bar(xpos, sub[\"average_score\"].values, width=bar_w, color=colors[g], label=f\"Average ({g})\")\n    ax.scatter(xpos, sub[\"benchmark_score\"].values, color=\"black\", s=30, zorder=5, label=f\"Benchmark ({g})\" if g == \"Middle\" else None)\n\n# Styling\nax.set_title(\"Student Average Scores vs Benchmark by Subject and Grade Level\")\nax.set_xlabel(\"Subject\")\nax.set_ylabel(\"Score\")\nax.set_xticks(x)\nax.set_xticklabels(subjects)\nax.set_ylim(60, 100)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n# De-duplicate legend entries\nhandles, labels = ax.get_legend_handles_labels()\nseen = set()\nh2, l2 = [], []\nfor h, l in zip(handles, labels):\n    if l and l not in seen:\n        h2.append(h); l2.append(l); seen.add(l)\nax.legend(h2, l2, ncol=2, frameon=False, loc=\"upper left\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.bar() function directly to render data. It creates a grouped layout by manually calculating offsets for vertical bars based on two categorical variables ('subject' and 'grade_level'), which fits the 'Grouped column chart' definition."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ncsv_path = \"5_bullet_student_scores_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Ensure desired ordering\ngrade_order = [\"Middle\", \"High\", \"College\"]\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grade_order, ordered=True)\n\nsubjects = sorted(df[\"subject\"].unique())\nx = np.arange(len(subjects))\nbar_width = 0.22\n\n# Prepare plot\nplt.figure(figsize=(11, 6))\nax = plt.gca()\n\n# Plot grouped bars for average_score by grade level\nfor i, grade in enumerate(grade_order):\n    sub = df[df[\"grade_level\"] == grade].set_index(\"subject\").reindex(subjects)\n    ax.bar(\n        x + (i - 1) * bar_width,\n        sub[\"average_score\"].values,\n        width=bar_width,\n        label=f\"Average ({grade})\",\n        edgecolor=\"white\",\n        linewidth=0.6,\n    )\n\n# Overlay benchmark as a marker per subject (benchmark is consistent across grade within each subject)\nbench = df.groupby(\"subject\", as_index=False)[\"benchmark_score\"].first().set_index(\"subject\").reindex(subjects)\nax.scatter(\n    x,\n    bench[\"benchmark_score\"].values,\n    color=\"black\",\n    marker=\"D\",\n    s=45,\n    label=\"Benchmark\",\n    zorder=5,\n)\n\n# Styling\nax.set_title(\"Average Student Scores by Subject and Grade Level vs Benchmark\")\nax.set_xlabel(\"Subject\")\nax.set_ylabel(\"Score\")\nax.set_xticks(x)\nax.set_xticklabels(subjects)\nax.set_ylim(60, 100)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nax.legend(ncols=2, frameon=False, loc=\"upper left\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.bar() function to create vertical bars. By iterating through grade levels and offsetting the x-positions, it constructs a vertical grouped bar layout, which is classified as a Grouped column chart in the taxonomy."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"5_bullet_student_scores_large.csv\")\n\n# Ensure grade order\ngrade_order = [\"Middle\", \"High\", \"College\"]\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grade_order, ordered=True)\n\nsubjects = df[\"subject\"].unique().tolist()\nn = len(subjects)\n\nfig, axes = plt.subplots(nrows=n, ncols=1, figsize=(10, 12), sharex=True)\nif n == 1:\n    axes = [axes]\n\nbar_color = \"#4C78A8\"\nbench_color = \"#E45756\"\n\nfor ax, subject in zip(axes, subjects):\n    sub = df[df[\"subject\"] == subject].sort_values(\"grade_level\")\n    ax.bar(sub[\"grade_level\"].astype(str), sub[\"average_score\"], color=bar_color, width=0.6)\n    bench = sub[\"benchmark_score\"].iloc[0]\n    ax.axhline(bench, color=bench_color, linestyle=\"--\", linewidth=2)\n\n    ax.set_title(subject, loc=\"left\", fontsize=12, fontweight=\"bold\")\n    ax.set_ylim(0, max(sub[\"average_score\"].max(), bench) + 10)\n    ax.grid(axis=\"y\", linestyle=\":\", alpha=0.5)\n    ax.set_ylabel(\"Score\")\n\naxes[-1].set_xlabel(\"Grade level\")\nfig.suptitle(\"Average Scores vs Benchmark by Subject (Bullet-style)\", fontsize=14, fontweight=\"bold\", y=0.995)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.bar` and `ax.axhline` functions to create the plot. It is classified as a Bullet chart because it represents a categorical variable ('grade_level'), a quantitative variable ('average_score'), and a reference/benchmark value ('benchmark_score') for comparison, which matches the taxonomy definition for a Bullet chart."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_student_scores_large.csv\")\n\n# Order grade levels\ngrade_order = [\"Middle\", \"High\", \"College\"]\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grade_order, ordered=True)\n\n# Sort for consistent plotting\ndf = df.sort_values([\"subject\", \"grade_level\"])\n\nsubjects = df[\"subject\"].unique()\nx = np.arange(len(subjects))\nwidth = 0.24\n\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\n# Plot grouped bars for average_score by grade level\nfor i, g in enumerate(grade_order):\n    sub = df[df[\"grade_level\"] == g].set_index(\"subject\").reindex(subjects)\n    ax.bar(\n        x + (i - 1) * width,\n        sub[\"average_score\"].values,\n        width=width,\n        label=f\"Average ({g})\",\n        edgecolor=\"white\",\n        linewidth=0.6,\n    )\n\n# Plot benchmark markers (one per subject, same across grades in this dataset)\nbench = df.groupby(\"subject\")[\"benchmark_score\"].first().reindex(subjects)\nax.scatter(x, bench.values, color=\"black\", s=45, marker=\"D\", label=\"Benchmark\")\n\n# Formatting\nax.set_title(\"Student Average Scores vs Benchmark by Subject and Grade Level\")\nax.set_xlabel(\"Subject\")\nax.set_ylabel(\"Score\")\nax.set_xticks(x)\nax.set_xticklabels(subjects)\nax.set_ylim(0, max(df[\"average_score\"].max(), df[\"benchmark_score\"].max()) + 10)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nax.legend(ncol=2, frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization is created using ax.bar() in a loop to render vertical bars grouped by subject and grade level, which fits the definition of a Grouped column chart. Since the data is rendered using standard matplotlib axes functions rather than pandas or seaborn wrappers, the library is classified as matplotlib. No specific color palette was declared."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"5_bullet_student_scores_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Ensure consistent ordering\ngrade_order = [\"Middle\", \"High\", \"College\"]\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grade_order, ordered=True)\ndf = df.sort_values([\"subject\", \"grade_level\"])\n\nsubjects = df[\"subject\"].unique()\n\n# Plot settings\nfig, ax = plt.subplots(figsize=(12, 6))\nbar_width = 0.22\nx = range(len(subjects))\n\n# Colors per grade level\ncolors = {\"Middle\": \"#4C78A8\", \"High\": \"#F58518\", \"College\": \"#54A24B\"}\n\n# Draw grouped bars for average scores by grade level\nfor i, grade in enumerate(grade_order):\n    sub = df[df[\"grade_level\"] == grade].set_index(\"subject\").reindex(subjects)\n    ax.bar([xi + (i - 1) * bar_width for xi in x],\n           sub[\"average_score\"].values,\n           width=bar_width,\n           label=f\"Average ({grade})\",\n           color=colors[grade])\n\n# Benchmark markers per subject (single benchmark used per subject in the file)\nbench = df.groupby(\"subject\")[\"benchmark_score\"].first().reindex(subjects).values\nax.plot([xi for xi in x], bench, linestyle=\"--\", color=\"black\", linewidth=2, label=\"Benchmark\")\n\n# Labels & styling\nax.set_title(\"Student Average Scores vs Benchmark by Subject and Grade Level\")\nax.set_xlabel(\"Subject\")\nax.set_ylabel(\"Score\")\nax.set_xticks(list(x))\nax.set_xticklabels(subjects)\nax.set_ylim(0, 100)\nax.grid(axis=\"y\", linestyle=\":\", alpha=0.5)\nax.legend(ncols=2, frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the matplotlib axes method 'ax.bar()' directly. The chart features vertical bars grouped by 'grade_level' for each 'subject' category, which classifies it as a Grouped column chart."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"5_bullet_student_scores_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Ensure desired ordering\nsubjects_order = [\"Math\", \"Science\", \"History\", \"English\", \"Art\"]\nlevels_order = [\"Middle\", \"High\", \"College\"]\ndf[\"subject\"] = pd.Categorical(df[\"subject\"], categories=subjects_order, ordered=True)\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=levels_order, ordered=True)\ndf = df.sort_values([\"subject\", \"grade_level\"]).reset_index(drop=True)\n\n# Layout parameters (bullet-style panels)\nn_subjects = len(subjects_order)\nrow_h = 1.25\npanel_gap = 0.9\ny0 = 0.6\n\n# Compute y positions\nys = []\npanel_center = {}\nfor si, s in enumerate(subjects_order):\n    base = y0 + (n_subjects - 1 - si) * (3 * row_h + panel_gap)\n    centers = [base + (2 - li) * row_h for li in range(3)]  # Middle top, College bottom\n    for li, lvl in enumerate(levels_order):\n        ys.append((s, lvl, centers[li]))\n    panel_center[s] = sum(centers) / 3.0\n\n# Map to dataframe\ny_map = {(s, lvl): y for s, lvl, y in ys}\ndf[\"y\"] = df.apply(lambda r: y_map[(r[\"subject\"], r[\"grade_level\"])], axis=1)\n\n# Axis range\nx_max = max(df[\"average_score\"].max(), df[\"benchmark_score\"].max())\nx_max = max(100, int(((x_max + 4) // 5) * 5))  # round up to 5s; at least 100\n\n# Plot\nplt.rcParams.update({\n    \"axes.spines.top\": False,\n    \"axes.spines.right\": False,\n    \"axes.spines.left\": False,\n    \"axes.spines.bottom\": True,\n    \"font.size\": 10,\n})\n\nfig_h = 1.2 + n_subjects * (3 * row_h + panel_gap) / 2.2\nfig, ax = plt.subplots(figsize=(10.5, fig_h))\n\n# Background \"range\" bar (0..100) for each bullet line\nbar_h = 0.38\nax.barh(df[\"y\"], [100] * len(df), left=0, height=bar_h, color=\"#E9ECEF\", edgecolor=\"none\", zorder=1)\n\n# Actual score bar\ncolors = {\"Middle\": \"#3B82F6\", \"High\": \"#2563EB\", \"College\": \"#1D4ED8\"}\nax.barh(df[\"y\"], df[\"average_score\"], left=0, height=bar_h, color=df[\"grade_level\"].map(colors), edgecolor=\"none\", zorder=2)\n\n# Benchmark marker\nfor _, r in df.iterrows():\n    ax.vlines(r[\"benchmark_score\"], r[\"y\"] - bar_h * 0.65, r[\"y\"] + bar_h * 0.65,\n              color=\"#111827\", linewidth=2.0, zorder=3)\n\n# Labels for each bullet line (grade level)\nfor _, r in df.iterrows():\n    ax.text(-2, r[\"y\"], r[\"grade_level\"], va=\"center\", ha=\"right\", color=\"#374151\")\n\n# Subject labels (panel titles)\nfor s in subjects_order:\n    ax.text(-2, panel_center[s] + row_h * 1.05, s, va=\"bottom\", ha=\"right\",\n            fontsize=11, fontweight=\"bold\", color=\"#111827\")\n\n# Separator lines between subject panels\nfor si in range(n_subjects - 1):\n    s_next = subjects_order[si + 1]\n    s_curr = subjects_order[si]\n    y_sep = (panel_center[s_curr] - (1.5 * row_h)) - panel_gap / 2\n    ax.hlines(y_sep, 0, x_max, color=\"#D1D5DB\", linewidth=1, zorder=0)\n\n# Annotations (score values)\nfor _, r in df.iterrows():\n    ax.text(min(r[\"average_score\"] + 1.2, x_max - 1), r[\"y\"], f'{r[\"average_score\"]}',\n            va=\"center\", ha=\"left\", color=\"#111827\", fontsize=9)\n\n# Axes formatting\nax.set_xlim(0, x_max)\nax.set_ylim(y0 - 1, y0 + (n_subjects) * (3 * row_h + panel_gap))\nax.set_yticks([])\nax.set_xlabel(\"Score\")\nax.set_title(\"Student Average Scores vs Benchmark (Bullet Chart by Subject & Grade Level)\", pad=12)\n\n# Legend (single)\nhandles = [plt.Line2D([0], [0], color=colors[lvl], lw=8) for lvl in levels_order]\nhandles.append(plt.Line2D([0], [0], color=\"#111827\", lw=2))\nlabels = levels_order + [\"Benchmark\"]\nax.legend(handles, labels, ncol=4, frameon=False, loc=\"upper right\", bbox_to_anchor=(1, 1.02))\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib (ax.barh, ax.vlines) to construct a visualization featuring horizontal bars for actual scores alongside vertical reference markers for benchmarks, which matches the definition of a Bullet chart. The data rendering is done using standard matplotlib axes functions rather than pandas wrappers or seaborn."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_student_scores_large.csv\")\n\n# Ordering\nsubjects = [\"Math\", \"Science\", \"History\", \"English\", \"Art\"]\ngrades = [\"Middle\", \"High\", \"College\"]\n\ndf[\"subject\"] = pd.Categorical(df[\"subject\"], categories=subjects, ordered=True)\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grades, ordered=True)\ndf = df.sort_values([\"subject\", \"grade_level\"]).reset_index(drop=True)\n\n# Prepare positions for grouped horizontal bullet bars\ny_positions = []\ny_labels = []\ny = 0\ngap_between_subjects = 0.9\ngap_within_subject = 0.28\n\nfor subj in subjects:\n    sub = df[df[\"subject\"] == subj]\n    for g in grades:\n        y_positions.append(y)\n        y_labels.append(f\"{subj} — {g}\")\n        y += gap_within_subject\n    y += gap_between_subjects\n\npos_map = {(row.subject, row.grade_level): yp for (row, yp) in zip(df.itertuples(index=False), y_positions)}\n\n# Figure\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 7))\n\n# Colors\nbar_color = \"#2E86AB\"\nbenchmark_color = \"#111111\"\n\n# Draw bars and benchmark markers\nfor row in df.itertuples(index=False):\n    yp = pos_map[(row.subject, row.grade_level)]\n    ax.barh(yp, row.average_score, height=0.18, color=bar_color, alpha=0.9)\n    ax.vlines(row.benchmark_score, yp - 0.12, yp + 0.12, color=benchmark_color, linewidth=2)\n\n# Axis formatting\nax.set_yticks(y_positions)\nax.set_yticklabels(y_labels, fontsize=10)\nax.invert_yaxis()\n\nax.set_xlim(0, 100)\nax.set_xlabel(\"Score (0–100)\", fontsize=11)\nax.set_title(\"Student Average Scores vs Benchmark (Bullet Chart by Subject and Grade Level)\", fontsize=13, pad=12)\n\n# Legend (single chart)\nfrom matplotlib.lines import Line2D\nlegend_items = [\n    Line2D([0], [0], color=bar_color, lw=8, label=\"Average score\"),\n    Line2D([0], [0], color=benchmark_color, lw=2, label=\"Benchmark\"),\n]\nax.legend(handles=legend_items, loc=\"lower right\", frameon=True)\n\n# Lighten spines for a clean look\nfor spine in [\"top\", \"right\"]:\n    ax.spines[spine].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.barh()` and `ax.vlines()` to render the data directly. It is classified as a Bullet chart because it combines horizontal bars representing a quantitative value (average_score) with markers (vlines) representing a second reference quantitative value (benchmark_score) across categorical dimensions (subject/grade)."}}
{"input_csv_file": "5_bullet_student_scores_large.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ncsv_path = \"5_bullet_student_scores_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Order grade levels\ngrade_order = [\"Middle\", \"High\", \"College\"]\ndf[\"grade_level\"] = pd.Categorical(df[\"grade_level\"], categories=grade_order, ordered=True)\ndf = df.sort_values([\"subject\", \"grade_level\"])\n\nsubjects = df[\"subject\"].unique().tolist()\ny_positions = np.arange(len(subjects))\n\n# Colors by grade level\ngrade_colors = {\n    \"Middle\": \"#4C78A8\",\n    \"High\": \"#F58518\",\n    \"College\": \"#54A24B\",\n}\n\n# Figure\nfig, ax = plt.subplots(figsize=(10.5, 6.5), dpi=130)\n\n# Axis range with padding\nxmin = max(0, min(df[\"average_score\"].min(), df[\"benchmark_score\"].min()) - 8)\nxmax = min(100, max(df[\"average_score\"].max(), df[\"benchmark_score\"].max()) + 6)\nax.set_xlim(xmin, xmax)\n\n# Draw benchmark ranges per subject (as thin line from min to max benchmark; benchmark is constant per subject here)\nbench_by_subject = df.groupby(\"subject\")[\"benchmark_score\"].first().reindex(subjects)\n\n# Offsets for grade-level dots within each subject row\noffsets = {\"Middle\": -0.18, \"High\": 0.0, \"College\": 0.18}\n\n# Plot: benchmark marker + average markers per grade\nfor i, subject in enumerate(subjects):\n    sub = df[df[\"subject\"] == subject]\n    bench = float(bench_by_subject.loc[subject])\n\n    # Benchmark vertical tick\n    ax.vlines(bench, i - 0.32, i + 0.32, color=\"#222222\", lw=2.2, zorder=2)\n    ax.scatter([bench], [i], s=55, marker=\"D\", color=\"#222222\", zorder=3, label=\"_nolegend_\")\n\n    # Average scores for each grade level\n    for _, r in sub.iterrows():\n        g = r[\"grade_level\"]\n        y = i + offsets[str(g)]\n        ax.scatter(\n            r[\"average_score\"],\n            y,\n            s=90,\n            color=grade_colors[str(g)],\n            edgecolor=\"white\",\n            linewidth=0.8,\n            zorder=4,\n            label=str(g) if i == 0 else \"_nolegend_\",\n        )\n\n        # Connecting line from benchmark to average (shows above/below benchmark)\n        ax.hlines(\n            y,\n            xmin=min(bench, r[\"average_score\"]),\n            xmax=max(bench, r[\"average_score\"]),\n            color=grade_colors[str(g)],\n            lw=1.6,\n            alpha=0.35,\n            zorder=1,\n        )\n\n# Labels & styling\nax.set_yticks(y_positions)\nax.set_yticklabels(subjects, fontsize=11)\nax.set_xlabel(\"Score\", fontsize=11)\nax.set_title(\"Student Average Scores vs Benchmark (by Subject and Grade Level)\", fontsize=13, pad=12)\n\n# Grid\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nax.grid(axis=\"y\", visible=False)\n\n# Legend\nhandles, labels = ax.get_legend_handles_labels()\n# Add benchmark legend entry\nfrom matplotlib.lines import Line2D\nhandles.append(Line2D([0], [0], color=\"#222222\", lw=2.2, marker=\"D\", markersize=6, label=\"Benchmark\"))\nlabels.append(\"Benchmark\")\nax.legend(handles, labels, title=\"Markers\", frameon=False, loc=\"lower right\", fontsize=10, title_fontsize=10)\n\n# Annotate a few key deltas (only when notable)\nfor i, subject in enumerate(subjects):\n    sub = df[df[\"subject\"] == subject]\n    bench = float(bench_by_subject.loc[subject])\n    for _, r in sub.iterrows():\n        delta = int(r[\"average_score\"] - bench)\n        if abs(delta) >= 4:\n            g = str(r[\"grade_level\"])\n            y = i + offsets[g]\n            x = r[\"average_score\"]\n            txt = f\"{delta:+d}\"\n            ax.text(\n                x + (0.8 if delta >= 0 else -0.8),\n                y,\n                txt,\n                va=\"center\",\n                ha=\"left\" if delta >= 0 else \"right\",\n                fontsize=9,\n                color=grade_colors[g],\n            )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses matplotlib's axes-level functions like ax.scatter(), ax.vlines(), and ax.hlines() to draw the data points and reference lines. The Y-axis is discrete (categorical subjects) while the X-axis is quantitative (scores), which classifies it as a Dot plot according to the taxonomy."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ncsv_path = \"5_bullet_system_metrics_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Prepare grouped data: metrics on x-axis, servers as series\nmetrics = df[\"metric\"].unique().tolist()\nservers = sorted(df[\"server\"].unique().tolist())\n\npivot_current = df.pivot(index=\"metric\", columns=\"server\", values=\"current_value\").reindex(metrics)\nref_limit = df.groupby(\"metric\")[\"reference_limit\"].first().reindex(metrics)\n\n# Plot\nfig, ax = plt.subplots(figsize=(10, 5))\nx = np.arange(len(metrics))\nwidth = 0.18\n\nfor i, srv in enumerate(servers):\n    offset = (i - (len(servers) - 1) / 2) * width\n    ax.bar(x + offset, pivot_current[srv].values, width=width, label=f\"Server {srv}\")\n\n# Reference limits as markers (one per metric)\nax.plot(x, ref_limit.values, color=\"black\", linestyle=\"--\", linewidth=1.5, marker=\"o\", label=\"Reference limit\")\n\n# Highlight values exceeding reference limit with red edge\nfor i, srv in enumerate(servers):\n    values = pivot_current[srv].values\n    exceeds = values > ref_limit.values\n    if np.any(exceeds):\n        offset = (i - (len(servers) - 1) / 2) * width\n        ax.bar(\n            x[exceeds] + offset,\n            values[exceeds],\n            width=width,\n            facecolor=\"none\",\n            edgecolor=\"red\",\n            linewidth=2.0,\n            label=\"_nolegend_\",\n            zorder=3,\n        )\n\nax.set_title(\"System Metrics by Server vs Reference Limits\")\nax.set_xlabel(\"Metric\")\nax.set_ylabel(\"Value\")\nax.set_xticks(x)\nax.set_xticklabels(metrics)\nax.legend(ncols=3, frameon=False)\nax.grid(axis=\"y\", linestyle=\":\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the matplotlib axes method `ax.bar()` to draw vertical bars. It implements a grouped layout by calculating offsets for each server within a loop, mapping two categorical dimensions (metrics and servers) to one quantitative dimension (value)."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_system_metrics_large.csv\")\n\n# Sort for consistent display\nmetrics_order = [\"CPU\", \"Memory\", \"Disk\", \"Network\"]\nservers_order = [\"A\", \"B\", \"C\", \"D\"]\ndf[\"metric\"] = pd.Categorical(df[\"metric\"], categories=metrics_order, ordered=True)\ndf[\"server\"] = pd.Categorical(df[\"server\"], categories=servers_order, ordered=True)\ndf = df.sort_values([\"metric\", \"server\"]).reset_index(drop=True)\n\n# X positions and labels\nlabels = [f\"{m}-{s}\" for m, s in zip(df[\"metric\"], df[\"server\"])]\nx = np.arange(len(df))\n\ncurrent = df[\"current_value\"].to_numpy()\nlimit = df[\"reference_limit\"].to_numpy()\nover = current > limit\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(14, 6))\n\n# Bar chart for current values\ncolors = np.where(over, \"#d62728\", \"#1f77b4\")  # red if over limit else blue\nax.bar(x, current, color=colors, edgecolor=\"black\", linewidth=0.6, label=\"Current value\")\n\n# Reference limit markers (single chart; per-row targets shown as markers)\nax.scatter(x, limit, color=\"black\", s=45, marker=\"_\", linewidths=2.5, label=\"Reference limit\")\n\n# Annotate exceedances\nfor xi, cv, rl, is_over in zip(x, current, limit, over):\n    if is_over:\n        ax.text(xi, cv + 1.2, f\"+{cv-rl}\", ha=\"center\", va=\"bottom\", fontsize=9, color=\"#d62728\")\n\nax.set_title(\"System Metrics by Server (Current vs Reference Limit)\")\nax.set_ylabel(\"Value\")\nax.set_xticks(x)\nax.set_xticklabels(labels, rotation=45, ha=\"right\")\n\nax.set_ylim(0, max(current.max(), limit.max()) + 10)\nax.legend(frameon=True, loc=\"upper left\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses the matplotlib axes API (ax.bar and ax.scatter) to render the data directly. The visualization is classified as a Bullet chart because it displays categorical data (metric-server) alongside two quantitative variables: the current value (rendered as a bar) and a reference limit (rendered as a marker), which matches the taxonomy's definition of a bar-based chart with reference values. Although the bars are vertical, 'Bullet chart' is the only category that accounts for the inclusion of reference values and the two-quantitative-variable data structure."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_system_metrics_large.csv\")\n\n# Aggregate to one chart: average current value vs average reference limit by metric\nsummary = (\n    df.groupby(\"metric\", as_index=False)\n      .agg(avg_current=(\"current_value\", \"mean\"),\n           avg_limit=(\"reference_limit\", \"mean\"))\n)\n\nmetrics = summary[\"metric\"].tolist()\nx = np.arange(len(metrics))\n\n# Figure\nplt.figure(figsize=(9, 5))\n\n# Bars for current values\nplt.bar(x, summary[\"avg_current\"], color=\"#4C78A8\", width=0.6, label=\"Avg current value\")\n\n# Overlay reference limit as markers/line\nplt.plot(x, summary[\"avg_limit\"], color=\"#F58518\", marker=\"o\", linewidth=2, label=\"Avg reference limit\")\n\n# Labels and formatting\nplt.xticks(x, metrics)\nplt.ylabel(\"Value\")\nplt.title(\"Average System Metrics vs Reference Limits (Across Servers)\")\nplt.ylim(0, max(summary[\"avg_current\"].max(), summary[\"avg_limit\"].max()) * 1.15)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.legend(frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's plt.bar() and plt.plot() directly to render the data. The visualization displays a categorical variable (metrics) alongside a primary quantitative value (avg_current) and a second quantitative dimension used as a reference (avg_limit), which aligns with the taxonomy definition for a Bullet chart."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_system_metrics_large.csv\")\n\n# Prepare labels and values\ndf[\"label\"] = df[\"metric\"] + \" - \" + df[\"server\"]\nvalues = df[\"current_value\"].to_numpy()\nlimits = df[\"reference_limit\"].to_numpy()\nlabels = df[\"label\"].to_list()\n\n# Color bars by whether they exceed the reference limit\ncolors = np.where(values > limits, \"#d62728\", \"#1f77b4\")  # red if over limit, blue otherwise\n\n# Plot\nfig, ax = plt.subplots(figsize=(12, 6))\nx = np.arange(len(df))\n\nax.bar(x, values, color=colors, edgecolor=\"black\", linewidth=0.6)\nax.plot(x, limits, color=\"black\", linewidth=2, marker=\"o\", markersize=4, label=\"Reference limit\")\n\n# Formatting\nax.set_title(\"System Metrics: Current Value vs Reference Limit\")\nax.set_ylabel(\"Value\")\nax.set_xticks(x)\nax.set_xticklabels(labels, rotation=45, ha=\"right\")\nax.set_ylim(0, max(values.max(), limits.max()) + 10)\n\n# Legend for bar colors (single chart)\nfrom matplotlib.patches import Patch\nlegend_handles = [\n    Patch(facecolor=\"#1f77b4\", edgecolor=\"black\", label=\"At/under limit\"),\n    Patch(facecolor=\"#d62728\", edgecolor=\"black\", label=\"Over limit\"),\n]\nax.legend(handles=legend_handles + [ax.lines[0]], loc=\"upper left\")\n\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.bar()` and `ax.plot()` to visualize quantitative values against categorical labels along with a second quantitative variable (reference limits). According to the taxonomy, a bar chart with reference values is classified as a Bullet chart."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ncsv_path = \"5_bullet_system_metrics_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Ensure expected columns exist\nexpected_cols = {\"metric\", \"server\", \"current_value\", \"reference_limit\"}\nmissing = expected_cols - set(df.columns)\nif missing:\n    raise ValueError(f\"Missing columns in CSV: {missing}\")\n\n# Order metrics and servers for consistent plotting\nmetrics = list(pd.unique(df[\"metric\"]))\nservers = list(pd.unique(df[\"server\"]))\n\n# Pivot current values to a metric x server table\ncurr = df.pivot(index=\"metric\", columns=\"server\", values=\"current_value\").reindex(index=metrics, columns=servers)\n\n# Reference limits per metric (assumes same limit across servers for a metric)\nref = df.groupby(\"metric\")[\"reference_limit\"].first().reindex(metrics)\n\n# Plot: grouped bars for servers + dashed reference line per metric\nx = np.arange(len(metrics))\nbar_width = 0.18\n\nfig, ax = plt.subplots(figsize=(10, 5))\n\nfor i, s in enumerate(servers):\n    ax.bar(\n        x + (i - (len(servers)-1)/2) * bar_width,\n        curr[s].values,\n        width=bar_width,\n        label=f\"Server {s}\"\n    )\n\nax.plot(x, ref.values, linestyle=\"--\", color=\"black\", linewidth=2, label=\"Reference limit\")\n\nax.set_title(\"System Metrics by Server vs Reference Limits\")\nax.set_xlabel(\"Metric\")\nax.set_ylabel(\"Value\")\nax.set_xticks(x)\nax.set_xticklabels(metrics)\nax.grid(axis=\"y\", linestyle=\":\", alpha=0.5)\nax.legend(ncols=3, frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization is created using standard Matplotlib axes functions (ax.bar) rather than pandas or seaborn wrappers. It displays vertical bars grouped by server for each metric, which classifies it as a Grouped column chart according to the taxonomy. Although it includes a reference line, the vertical orientation excludes it from being a 'Bullet chart' or 'Bar chart' under the provided strict definitions."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"5_bullet_system_metrics_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Prepare plotting positions (metric groups with server offsets)\nmetric_order = [\"CPU\", \"Memory\", \"Disk\", \"Network\"]\nserver_order = [\"A\", \"B\", \"C\", \"D\"]\ndf[\"metric\"] = pd.Categorical(df[\"metric\"], categories=metric_order, ordered=True)\ndf[\"server\"] = pd.Categorical(df[\"server\"], categories=server_order, ordered=True)\ndf = df.sort_values([\"metric\", \"server\"]).reset_index(drop=True)\n\n# Map base positions per metric and small offsets per server\nmetric_to_x = {m: i for i, m in enumerate(metric_order)}\nserver_offsets = {\"A\": -0.27, \"B\": -0.09, \"C\": 0.09, \"D\": 0.27}\ndf[\"x\"] = df[\"metric\"].map(metric_to_x).astype(float) + df[\"server\"].map(server_offsets).astype(float)\n\n# Plot\nfig, ax = plt.subplots(figsize=(10, 5))\n\n# Color by whether current exceeds reference\ncolors = [\"#d62728\" if cv > rl else \"#1f77b4\" for cv, rl in zip(df[\"current_value\"], df[\"reference_limit\"])]\n\nax.scatter(df[\"x\"], df[\"current_value\"], s=90, c=colors, edgecolor=\"black\", linewidth=0.6, zorder=3)\n\n# Add horizontal reference lines per metric\nfor m in metric_order:\n    rl = df.loc[df[\"metric\"] == m, \"reference_limit\"].iloc[0]\n    ax.hlines(rl, metric_to_x[m] - 0.45, metric_to_x[m] + 0.45, colors=\"#444444\", linestyles=\"--\", linewidth=1.2, zorder=2)\n\n# Annotate points with server labels\nfor _, r in df.iterrows():\n    ax.text(r[\"x\"], r[\"current_value\"] + 1.2, str(r[\"server\"]), ha=\"center\", va=\"bottom\", fontsize=9)\n\n# Axes formatting\nax.set_xticks([metric_to_x[m] for m in metric_order])\nax.set_xticklabels(metric_order)\nax.set_ylabel(\"Current Value\")\nax.set_title(\"System Metrics by Server (Current vs Reference Limit)\")\n\n# Legend (custom)\nfrom matplotlib.lines import Line2D\nlegend_items = [\n    Line2D([0], [0], marker='o', color='w', label='Within limit', markerfacecolor=\"#1f77b4\",\n           markeredgecolor=\"black\", markersize=9),\n    Line2D([0], [0], marker='o', color='w', label='Exceeds limit', markerfacecolor=\"#d62728\",\n           markeredgecolor=\"black\", markersize=9),\n    Line2D([0], [0], color=\"#444444\", lw=1.2, linestyle=\"--\", label=\"Reference limit\"),\n]\nax.legend(handles=legend_items, loc=\"upper left\", frameon=True)\n\nax.grid(axis=\"y\", alpha=0.25)\nax.set_xlim(-0.6, len(metric_order) - 0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.scatter()` to plot quantitative values against categories (metrics/servers) which are mapped to numerical positions on the x-axis. Although it mimics a bullet chart's purpose by including reference lines (`ax.hlines`), it is classified as a Dot plot according to the taxonomy because it uses points rather than bars and represents categorical vs. quantitative data."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ncsv_path = \"5_bullet_system_metrics_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Prepare values\ndf[\"within_limit\"] = df[\"current_value\"] <= df[\"reference_limit\"]\ndf[\"over_by\"] = (df[\"current_value\"] - df[\"reference_limit\"]).clip(lower=0)\n\nmetrics = [\"CPU\", \"Memory\", \"Disk\", \"Network\"]\nservers = [\"A\", \"B\", \"C\", \"D\"]\n\n# Pivot to a stable grid (metrics x servers)\npivot_current = df.pivot(index=\"metric\", columns=\"server\", values=\"current_value\").reindex(index=metrics, columns=servers)\npivot_limit = df.pivot(index=\"metric\", columns=\"server\", values=\"reference_limit\").reindex(index=metrics, columns=servers)\npivot_over = (pivot_current - pivot_limit).clip(lower=0)\n\n# Plot: grouped bars for current values; red hatched segment indicates exceedance\nfig, ax = plt.subplots(figsize=(11, 6))\nx = np.arange(len(metrics))\ngroup_width = 0.8\nbar_w = group_width / len(servers)\n\nfor i, s in enumerate(servers):\n    xs = x - group_width / 2 + (i + 0.5) * bar_w\n    curr = pivot_current[s].values\n    over = pivot_over[s].values\n\n    ax.bar(xs, curr, width=bar_w, label=f\"Server {s}\", alpha=0.85)\n    ax.bar(xs, over, width=bar_w, bottom=curr - over, color=\"crimson\", alpha=0.75, hatch=\"//\")\n\n# Reference limits (one line per metric, same for all servers)\nax.plot(x, pivot_limit.mean(axis=1).values, color=\"black\", linestyle=\"--\", linewidth=2, label=\"Reference limit\")\n\nax.set_title(\"System Metrics by Server (Current vs Reference Limit)\")\nax.set_xticks(x)\nax.set_xticklabels(metrics)\nax.set_ylabel(\"Value\")\nax.set_ylim(0, max(pivot_current.max().max(), pivot_limit.max().max()) + 10)\nax.grid(axis=\"y\", linestyle=\":\", alpha=0.5)\n\n# Legend: servers + limit + exceedance patch\nfrom matplotlib.patches import Patch\nhandles, labels = ax.get_legend_handles_labels()\nhandles.append(Patch(facecolor=\"crimson\", alpha=0.75, hatch=\"//\", label=\"Exceeds limit portion\"))\nax.legend(handles=handles, loc=\"upper left\", ncol=2, frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib Axes method `ax.bar()` to render data. It creates vertical bars that are grouped by server within each metric category using calculated offsets, which aligns with the taxonomy definition for a Grouped column chart."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ncsv_path = \"5_bullet_system_metrics_large.csv\"\ndf = pd.read_csv(csv_path)\n\n# Create unique label for each row (Metric-Server)\ndf[\"label\"] = df[\"metric\"].astype(str) + \" - \" + df[\"server\"].astype(str)\n\n# Colors: exceed limit -> red, otherwise -> steelblue\ncolors = [\"#d62728\" if cv > rl else \"#1f77b4\" for cv, rl in zip(df[\"current_value\"], df[\"reference_limit\"])]\n\n# Plot (single chart)\nfig, ax = plt.subplots(figsize=(10, 6))\n\ny = range(len(df))\nax.barh(y, df[\"current_value\"], color=colors, alpha=0.9, label=\"Current value\")\nax.scatter(df[\"reference_limit\"], y, color=\"black\", marker=\"|\", s=250, linewidths=2, label=\"Reference limit\")\n\nax.set_yticks(list(y))\nax.set_yticklabels(df[\"label\"])\nax.invert_yaxis()\n\nax.set_xlabel(\"Value\")\nax.set_title(\"System Metrics by Server: Current vs Reference Limit\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n\n# Legend\nax.legend(loc=\"lower right\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib (ax.barh and ax.scatter) to render data. It fits the 'Bullet chart' taxonomy definition as it combines horizontal bars (ax.barh) with reference values (ax.scatter using the '|' marker) to compare a quantitative metric against a limit across categories."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load CSV\ndf = pd.read_csv(\"5_bullet_system_metrics_large.csv\")\n\n# Order metrics and servers for consistent plotting\nmetrics_order = [\"CPU\", \"Memory\", \"Disk\", \"Network\"]\nservers_order = sorted(df[\"server\"].unique())\n\n# Pivot to wide format for plotting\ncur = df.pivot(index=\"metric\", columns=\"server\", values=\"current_value\").reindex(metrics_order)\nref = df.pivot(index=\"metric\", columns=\"server\", values=\"reference_limit\").reindex(metrics_order)\n\n# Build grouped horizontal bullet chart (single chart)\nn_metrics = len(metrics_order)\nn_servers = len(servers_order)\n\ny_base = np.arange(n_metrics)\nbar_h = 0.18\noffsets = (np.arange(n_servers) - (n_servers - 1) / 2) * (bar_h * 1.3)\n\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\ncolors = plt.cm.Set2(np.linspace(0, 1, n_servers))\n\nfor j, srv in enumerate(servers_order):\n    y = y_base + offsets[j]\n\n    # Background reference bar (limit)\n    ax.barh(\n        y,\n        ref[srv].values,\n        height=bar_h,\n        color=\"lightgray\",\n        edgecolor=\"none\",\n        zorder=1\n    )\n\n    # Current value bar\n    ax.barh(\n        y,\n        cur[srv].values,\n        height=bar_h,\n        color=colors[j],\n        edgecolor=\"none\",\n        zorder=2,\n        label=f\"Server {srv}\"\n    )\n\n    # Mark reference limit with a thin vertical line at the end of the reference bar\n    for i, m in enumerate(metrics_order):\n        x_ref = ref.loc[m, srv]\n        ax.vlines(x_ref, y[i] - bar_h / 2, y[i] + bar_h / 2, color=\"dimgray\", linewidth=1, zorder=3)\n\n# Axis & labels\nax.set_yticks(y_base)\nax.set_yticklabels(metrics_order)\nax.set_xlabel(\"Value\")\nax.set_title(\"System Metrics by Server (Current vs Reference Limit)\")\n\n# X limit with padding\nx_max = max(df[\"reference_limit\"].max(), df[\"current_value\"].max())\nax.set_xlim(0, x_max + 10)\n\n# Grid\nax.xaxis.grid(True, linestyle=\"--\", alpha=0.35)\nax.set_axisbelow(True)\n\n# Legend\nax.legend(ncol=2, frameon=False, loc=\"lower right\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": "Set2", "reasoning": "The code uses matplotlib's 'ax.barh' and 'ax.vlines' functions directly to render the data. The visualization is classified as a Bullet chart because it displays current quantitative values against reference limits (quantitative) for specific metrics (categorical)."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.lines import Line2D\n\n# Load data\ndf = pd.read_csv(\"5_bullet_system_metrics_large.csv\")\n\n# Order metrics as they appear in the file\nmetric_order = df[\"metric\"].drop_duplicates().tolist()\n\n# Aggregate to one row per metric (average across servers)\ng = (\n    df.groupby(\"metric\", sort=False)\n      .agg(current_value=(\"current_value\", \"mean\"),\n           reference_limit=(\"reference_limit\", \"mean\"))\n      .reindex(metric_order)\n      .reset_index()\n)\n\n# Determine status (any server exceeding limit)\nexceed = (\n    df.assign(exceeds=lambda x: x[\"current_value\"] > x[\"reference_limit\"])\n      .groupby(\"metric\", sort=False)[\"exceeds\"]\n      .any()\n      .reindex(metric_order)\n      .to_list()\n)\ng[\"status\"] = [\"Exceeds (any server)\" if e else \"Within (all servers)\" for e in exceed]\n\n# Plot settings\nmax_x = max(df[\"current_value\"].max(), df[\"reference_limit\"].max()) * 1.10\n\nfig, ax = plt.subplots(figsize=(10, 4.8))\ny = range(len(g))\n\n# Background \"limit\" bars (bullet style)\nax.barh(\n    y, g[\"reference_limit\"],\n    height=0.62, color=\"#E6E6E6\", edgecolor=\"none\",\n    label=\"Reference limit\"\n)\n\n# Foreground \"current\" bars, colored by status\ncolors = [\"#D55E00\" if s.startswith(\"Exceeds\") else \"#0072B2\" for s in g[\"status\"]]\nax.barh(\n    y, g[\"current_value\"],\n    height=0.34, color=colors, edgecolor=\"none\",\n    label=\"Current (avg across servers)\"\n)\n\n# Limit marker line\nfor yi, lim in zip(y, g[\"reference_limit\"]):\n    ax.vlines(lim, yi - 0.38, yi + 0.38, color=\"#4D4D4D\", linewidth=1.6)\n\n# Labels & styling\nax.set_yticks(list(y))\nax.set_yticklabels(g[\"metric\"])\nax.invert_yaxis()\nax.set_xlim(0, max_x)\nax.set_xlabel(\"Value\")\nax.set_title(\"System Metrics vs Reference Limits (Bullet Chart, Avg Across Servers)\")\n\n# Legend (single chart)\nhandles = [\n    plt.Rectangle((0, 0), 1, 1, color=\"#E6E6E6\", ec=\"none\", label=\"Reference limit\"),\n    plt.Rectangle((0, 0), 1, 1, color=\"#0072B2\", ec=\"none\", label=\"Current (within)\"),\n    plt.Rectangle((0, 0), 1, 1, color=\"#D55E00\", ec=\"none\", label=\"Current (exceeds)\"),\n    Line2D([0], [0], color=\"#4D4D4D\", lw=1.6, label=\"Limit marker\"),\n]\nax.legend(handles=handles, loc=\"lower right\", frameon=False)\n\nax.grid(axis=\"x\", color=\"#DDDDDD\", linewidth=0.8)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# Annotate values\nfor yi, cur, lim in zip(y, g[\"current_value\"], g[\"reference_limit\"]):\n    ax.text(cur + max_x * 0.01, yi, f\"{cur:.1f}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#1A1A1A\")\n    ax.text(lim + max_x * 0.01, yi - 0.22, f\"limit {lim:.0f}\", va=\"center\", ha=\"left\", fontsize=8, color=\"#4D4D4D\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses standard matplotlib axes functions (ax.barh and ax.vlines) to construct a visualization representing categorical metrics against two quantitative values (current_value and reference_limit), which fits the taxonomy definition of a Bullet chart."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"5_bullet_system_metrics_large.csv\")\n\n# Prepare ordering\nmetrics = [\"CPU\", \"Memory\", \"Disk\", \"Network\"]\nservers = [\"A\", \"B\", \"C\", \"D\"]\n\ndf[\"metric\"] = pd.Categorical(df[\"metric\"], categories=metrics, ordered=True)\ndf[\"server\"] = pd.Categorical(df[\"server\"], categories=servers, ordered=True)\ndf = df.sort_values([\"metric\", \"server\"])\n\n# Layout: one \"bullet-style\" row per (metric, server)\nn_metrics = len(metrics)\nn_servers = len(servers)\nN = len(df)\n\nrow_y = np.arange(N)\nbar_h = 0.72\n\n# Colors\nbg_color = \"#E9EEF5\"       # reference limit band\nok_color = \"#2F6FED\"       # current value (<= limit)\nbad_color = \"#E24A33\"      # current value (> limit)\nlimit_line = \"#3A3A3A\"\n\n# For consistent scaling, use max reference limit across all rows\nx_max = int(max(df[\"reference_limit\"].max(), df[\"current_value\"].max()) * 1.15)\n\nfig, ax = plt.subplots(figsize=(10.5, 7.5))\n\n# Draw reference limit \"band\" from 0 to reference_limit\nax.barh(\n    row_y,\n    df[\"reference_limit\"].values,\n    height=bar_h,\n    color=bg_color,\n    edgecolor=\"none\",\n    zorder=1,\n)\n\n# Draw current value, coloring breaches\ncolors = np.where(df[\"current_value\"].values > df[\"reference_limit\"].values, bad_color, ok_color)\nax.barh(\n    row_y,\n    df[\"current_value\"].values,\n    height=bar_h * 0.62,\n    color=colors,\n    edgecolor=\"none\",\n    zorder=3,\n)\n\n# Draw limit marker line per row\nfor y, lim in zip(row_y, df[\"reference_limit\"].values):\n    ax.vlines(lim, y - bar_h / 2, y + bar_h / 2, colors=limit_line, linewidth=1.6, zorder=4)\n\n# Labels on bars\nfor y, cur, lim in zip(row_y, df[\"current_value\"].values, df[\"reference_limit\"].values):\n    ax.text(\n        cur + x_max * 0.01,\n        y,\n        f\"{cur}\",\n        va=\"center\",\n        ha=\"left\",\n        fontsize=9,\n        color=\"#111111\",\n        zorder=5,\n    )\n    ax.text(\n        lim + x_max * 0.01,\n        y - bar_h * 0.40,\n        f\"limit {lim}\",\n        va=\"center\",\n        ha=\"left\",\n        fontsize=8,\n        color=\"#333333\",\n        zorder=5,\n    )\n\n# Y tick labels: \"Metric — Server\"\nyticklabels = [f\"{m} — Server {s}\" for m, s in zip(df[\"metric\"].astype(str), df[\"server\"].astype(str))]\nax.set_yticks(row_y)\nax.set_yticklabels(yticklabels, fontsize=10)\n\n# Add subtle separators between metric groups\nfor i in range(1, n_metrics):\n    y_sep = i * n_servers - 0.5\n    ax.hlines(y_sep, 0, x_max, colors=\"#D6DCE6\", linewidth=1.0, zorder=2)\n\n# Axes formatting\nax.set_xlim(0, x_max)\nax.invert_yaxis()\nax.set_xlabel(\"Utilization / Value\", fontsize=11)\nax.set_title(\"System Metrics by Server: Current vs Reference Limit (Bullet-Style)\", fontsize=13, pad=12)\n\nax.grid(axis=\"x\", color=\"#DCE3EE\", linewidth=1, alpha=0.9)\nax.set_axisbelow(True)\n\n# Clean spines\nfor spine in [\"top\", \"right\", \"left\"]:\n    ax.spines[spine].set_visible(False)\nax.spines[\"bottom\"].set_color(\"#B8C2D1\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code manually constructs a bullet-style visualization using matplotlib's `ax.barh` to create horizontal bars for current values and reference bands, combined with `ax.vlines` for the reference limit markers. This satisfies the Bullet chart definition of a categorical variable with two quantitative dimensions (current vs reference)."}}
{"input_csv_file": "5_bullet_system_metrics_large.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"5_bullet_system_metrics_large.csv\")\n\nmetrics = [\"CPU\", \"Memory\", \"Disk\", \"Network\"]\nservers = [\"A\", \"B\", \"C\", \"D\"]\n\n# Layout\nn_rows = len(metrics)\nn_cols = len(servers)\n\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(12, 7), sharex=True, sharey=True)\nfig.patch.set_facecolor(\"white\")\n\n# Colors\nbar_ok = \"#4C78A8\"\nbar_over = \"#E45756\"\nlimit_color = \"#333333\"\n\n# Compute a common x-limit for comparability\nxmax = max(df[\"current_value\"].max(), df[\"reference_limit\"].max()) * 1.12\n\nfor i, metric in enumerate(metrics):\n    for j, server in enumerate(servers):\n        ax = axes[i, j]\n        row = df[(df[\"metric\"] == metric) & (df[\"server\"] == server)].iloc[0]\n        val = float(row[\"current_value\"])\n        limit = float(row[\"reference_limit\"])\n\n        # Background track\n        ax.barh([0], [xmax], color=\"#EEF2F6\", height=0.6, edgecolor=\"none\", zorder=0)\n\n        # Value bar (color-coded vs limit)\n        color = bar_over if val > limit else bar_ok\n        ax.barh([0], [val], color=color, height=0.6, edgecolor=\"none\", zorder=2)\n\n        # Reference limit marker\n        ax.vlines(limit, -0.35, 0.35, colors=limit_color, linewidth=2.0, zorder=3)\n\n        # Labels\n        ax.text(min(val + xmax * 0.01, xmax * 0.985), 0, f\"{int(val)}\",\n                va=\"center\", ha=\"left\", fontsize=9, color=\"#111111\", zorder=4)\n\n        # Ax styling\n        ax.set_xlim(0, xmax)\n        ax.set_ylim(-1, 1)\n        ax.set_yticks([])\n        ax.grid(False)\n        for spine in ax.spines.values():\n            spine.set_visible(False)\n\n        # Row/column headers\n        if i == 0:\n            ax.set_title(f\"Server {server}\", fontsize=11, pad=10)\n        if j == 0:\n            ax.text(-0.02, 0.5, metric, transform=ax.transAxes,\n                    ha=\"right\", va=\"center\", fontsize=11, color=\"#111111\")\n\n# X-axis ticks on bottom row only\nfor ax in axes[-1, :]:\n    ax.set_xlabel(\"Utilization (%)\", fontsize=10)\n    ax.tick_params(axis=\"x\", labelsize=9, colors=\"#333333\")\nfor ax in axes[:-1, :].ravel():\n    ax.tick_params(axis=\"x\", which=\"both\", bottom=False, labelbottom=False)\n\nfig.suptitle(\"System Metrics vs Reference Limits (Bullet Small Multiples)\", fontsize=14, y=0.98)\nplt.tight_layout(rect=[0.06, 0.04, 1, 0.95])\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bullet chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh and ax.vlines to create horizontal bars with associated reference markers, which explicitly satisfies the taxonomy definition for a Bullet chart. Since data is rendered via matplotlib.pyplot/axes methods rather than sns or df.plot, the library is matplotlib."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"6apple_products.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\n# Parse RAM like \"4 GB\" -> 4 (numeric)\ndf[\"Ram_GB\"] = (\n    df[\"Ram\"]\n    .astype(str)\n    .str.extract(r\"(\\d+)\")\n    .astype(float)\n)\n\n# Aggregate: average sale price per RAM size\nagg = (\n    df.dropna(subset=[\"Ram_GB\", \"Sale Price\"])\n      .groupby(\"Ram_GB\", as_index=False)[\"Sale Price\"]\n      .mean()\n      .sort_values(\"Ram_GB\")\n)\n\nplt.figure(figsize=(9, 5.5))\nplt.plot(agg[\"Ram_GB\"], agg[\"Sale Price\"], marker=\"o\", linewidth=2)\nplt.title(\"Average iPhone Sale Price by RAM (GB)\")\nplt.xlabel(\"RAM (GB)\")\nplt.ylabel(\"Average Sale Price\")\nplt.grid(True, alpha=0.3)\nplt.xticks(agg[\"Ram_GB\"])\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The plot is rendered using the plt.plot() function directly from matplotlib, rather than using seaborn or pandas plotting wrappers. The use of plt.plot() to connect points representing quantitative variables results in a Line chart."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6apple_products.csv\")\n\n# Clean/parse RAM (e.g., \"4 GB\" -> 4)\ndf[\"Ram_GB\"] = (\n    df[\"Ram\"].astype(str).str.extract(r\"(\\d+)\")[0].astype(float)\n)\n\n# Aggregate: average sale price by RAM size\ng = (\n    df.groupby(\"Ram_GB\", dropna=True)[\"Sale Price\"]\n      .mean()\n      .sort_index()\n)\n\n# Plot: simple, \"read the data\" level chart\nplt.figure(figsize=(8, 4.8))\nplt.bar(g.index.astype(int).astype(str), g.values, color=\"#4C78A8\")\nplt.title(\"Average Sale Price by RAM (Apple Products)\")\nplt.xlabel(\"RAM (GB)\")\nplt.ylabel(\"Average Sale Price (INR)\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, which identifies the library as 'matplotlib' based on the hierarchy rules. Since plt.bar() produces vertical bars representing a categorical variable (RAM) and a quantitative variable (Average Sale Price), it is classified as a 'Column chart'."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6apple_products.csv\")\n\n# Clean/prepare RAM (e.g., \"4 GB\" -> 4)\ndf[\"Ram_GB\"] = (\n    df[\"Ram\"]\n    .astype(str)\n    .str.extract(r\"(\\d+)\")\n    .astype(float)\n)\n\n# Aggregate: average sale price by RAM size\nram_price = (\n    df.dropna(subset=[\"Ram_GB\", \"Sale Price\"])\n      .groupby(\"Ram_GB\", as_index=False)[\"Sale Price\"]\n      .mean()\n      .sort_values(\"Ram_GB\")\n)\n\n# Plot: simple bar chart (good for basic data reading)\nplt.figure(figsize=(8, 5))\nplt.bar(ram_price[\"Ram_GB\"].astype(int).astype(str) + \" GB\", ram_price[\"Sale Price\"], color=\"#4C78A8\")\nplt.title(\"Average Sale Price by RAM (Apple Products)\")\nplt.xlabel(\"RAM\")\nplt.ylabel(\"Average Sale Price (INR)\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the plt.bar() function directly from matplotlib to render vertical bars, making it a Column chart. Although pandas is used for data manipulation, the rendering is done via the matplotlib.pyplot API."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6apple_products.csv\")\n\n# Convert Ram like \"4 GB\" -> 4 (numeric)\ndf[\"Ram_GB\"] = (\n    df[\"Ram\"]\n    .astype(str)\n    .str.replace(\"GB\", \"\", regex=False)\n    .str.strip()\n)\ndf[\"Ram_GB\"] = pd.to_numeric(df[\"Ram_GB\"], errors=\"coerce\")\n\n# Keep rows with valid RAM and rating\nplot_df = df.dropna(subset=[\"Ram_GB\", \"Star Rating\"]).copy()\n\n# Prepare simple summary: average rating by RAM size\nsummary = (\n    plot_df.groupby(\"Ram_GB\")[\"Star Rating\"]\n    .mean()\n    .sort_index()\n)\n\n# Plot: Average star rating by RAM (single chart)\nplt.figure(figsize=(8, 4.5))\nplt.bar(summary.index.astype(int).astype(str), summary.values, color=\"#4C78A8\")\n\nplt.title(\"Average Star Rating by RAM (GB) — Apple Products\")\nplt.xlabel(\"RAM (GB)\")\nplt.ylabel(\"Average Star Rating\")\nplt.ylim(0, 5)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\nfor i, v in enumerate(summary.values):\n    plt.text(i, v + 0.05, f\"{v:.2f}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() to render the data directly. Since plt.bar() produces vertical bars and the input involves a discrete variable (RAM size) vs. a quantitative variable (average rating), it is classified as a Column chart."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport re\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"6apple_products.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\ndef extract_model(name: str) -> str:\n    s = str(name).strip()\n    m = re.search(r\"\\b(iPhone\\s+[^(\\n]+)\", s, flags=re.IGNORECASE)\n    if m:\n        model = m.group(1).strip()\n    else:\n        model = s.split(\"(\")[0].strip()\n\n    model = re.sub(r\"\\s*\\(.*?\\)\\s*\", \"\", model).strip()\n    model = re.sub(r\"\\s+\\(.*$\", \"\", model).strip()\n    model = re.sub(r\"\\s+\\(\\s*$\", \"\", model).strip()\n    model = re.sub(r\"\\s{2,}\", \" \", model)\n    model = re.sub(r\"^APPLE\\s+\", \"\", model, flags=re.IGNORECASE)\n    model = re.sub(r\"^Apple\\s+\", \"\", model, flags=re.IGNORECASE)\n    model = re.sub(r\"^\\s*iPhone\\s+\", \"iPhone \", model, flags=re.IGNORECASE)\n    return model\n\ndf[\"Model\"] = df[\"Product Name\"].apply(extract_model)\n\nmodel_price = (\n    df.groupby(\"Model\", as_index=False)[\"Sale Price\"]\n      .median()\n      .sort_values(\"Sale Price\", ascending=False)\n)\n\nplt.figure(figsize=(12, 7))\nplt.barh(model_price[\"Model\"], model_price[\"Sale Price\"], color=\"#1f77b4\")\nplt.gca().invert_yaxis()\nplt.xlabel(\"Median Sale Price (INR)\")\nplt.title(\"Median Sale Price by iPhone Model (from 6apple_products.csv)\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `plt.barh()` function directly to render the data. Based on the provided taxonomy, horizontal bar visualizations are classified as Bar charts (as opposed to vertical Column charts). Although a hex color '#1f77b4' is specified, it is a single color value rather than a named palette like 'viridis' or 'Set2', so color_palette is null."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef parse_gb(x):\n    if pd.isna(x):\n        return None\n    s = str(x).strip().upper()\n    if \"GB\" in s:\n        s = s.replace(\"GB\", \"\").strip()\n    try:\n        return float(s)\n    except ValueError:\n        return None\n\ndf = pd.read_csv(\"6apple_products.csv\")\n\ndf[\"Ram_GB\"] = df[\"Ram\"].apply(parse_gb)\nplot_df = df.dropna(subset=[\"Ram_GB\", \"Sale Price\", \"Star Rating\"]).copy()\n\nplot_df[\"Sale Price\"] = pd.to_numeric(plot_df[\"Sale Price\"], errors=\"coerce\")\nplot_df[\"Star Rating\"] = pd.to_numeric(plot_df[\"Star Rating\"], errors=\"coerce\")\nplot_df = plot_df.dropna(subset=[\"Sale Price\", \"Star Rating\"])\n\nplt.figure(figsize=(10, 6))\n\nsizes = (plot_df[\"Number Of Ratings\"].fillna(0).clip(lower=0) ** 0.5) * 3 + 20\nscatter = plt.scatter(\n    plot_df[\"Sale Price\"],\n    plot_df[\"Star Rating\"],\n    c=plot_df[\"Ram_GB\"],\n    s=sizes,\n    alpha=0.8,\n    cmap=\"viridis\",\n    edgecolors=\"white\",\n    linewidths=0.5,\n)\n\ncbar = plt.colorbar(scatter)\ncbar.set_label(\"RAM (GB)\")\n\nplt.title(\"Apple Products: Sale Price vs Star Rating (size = √ratings, color = RAM)\")\nplt.xlabel(\"Sale Price (INR)\")\nplt.ylabel(\"Star Rating\")\nplt.ylim(4.4, 4.8)\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "viridis", "reasoning": "The code uses matplotlib's plt.scatter() function to render the data. Because it uses two quantitative dimensions for the X and Y axes (Sale Price and Star Rating) and modulates the marker size ('s') based on a third quantitative dimension (Number Of Ratings), it is classified as a Bubble chart."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6apple_products.csv\")\n\n# Clean/parse RAM (e.g., \"4 GB\" -> 4)\ndf[\"Ram_GB\"] = (\n    df[\"Ram\"]\n    .astype(str)\n    .str.extract(r\"(\\d+(?:\\.\\d+)?)\")[0]\n    .astype(float)\n)\n\n# Aggregate: average sale price by RAM size\nram_price = (\n    df.dropna(subset=[\"Ram_GB\", \"Sale Price\"])\n      .groupby(\"Ram_GB\", as_index=False)[\"Sale Price\"]\n      .mean()\n      .sort_values(\"Ram_GB\")\n)\n\n# Plot: single chart\nplt.figure(figsize=(8, 5))\nplt.plot(ram_price[\"Ram_GB\"], ram_price[\"Sale Price\"], marker=\"o\", linewidth=2)\nplt.title(\"Average Sale Price by RAM (Apple Products)\")\nplt.xlabel(\"RAM (GB)\")\nplt.ylabel(\"Average Sale Price\")\nplt.xticks(ram_price[\"Ram_GB\"])\nplt.grid(True, linestyle=\"--\", alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using standard matplotlib.pyplot functions (plt.plot) to render a line connecting quantitative points (RAM vs Sale Price), making the library 'matplotlib' and the chart type 'Line chart'."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nCSV_PATH = \"6apple_products.csv\"\n\ndf = pd.read_csv(CSV_PATH)\n\nplt.figure(figsize=(8.5, 6.5))\nplt.scatter(\n    df[\"Sale Price\"],\n    df[\"Star Rating\"],\n    s=(df[\"Number Of Ratings\"].clip(lower=1) ** 0.5) * 2.5,\n    alpha=0.65,\n    edgecolor=\"white\",\n    linewidth=0.5,\n)\n\nplt.title(\"Apple 产品：售价 vs 星级评分（点大小=评分人数）\")\nplt.xlabel(\"Sale Price\")\nplt.ylabel(\"Star Rating\")\nplt.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.4)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The code uses plt.scatter() directly from the matplotlib.pyplot module to render the data. It maps two quantitative variables to the axes and a third quantitative variable (Number Of Ratings) to the size parameter 's', classifying it as a Bubble chart according to the taxonomy."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"6apple_products.csv\")\n\n# Limpiar/asegurar tipos numéricos\nnum_cols = [\"Sale Price\", \"Mrp\", \"Discount Percentage\", \"Number Of Ratings\", \"Star Rating\"]\nfor c in num_cols:\n    df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n# Gráfico: dispersión Precio vs Rating, tamaño por número de valoraciones, color por % descuento\nplt.figure(figsize=(10, 6))\n\nsizes = (df[\"Number Of Ratings\"].fillna(0) / max(df[\"Number Of Ratings\"].max(), 1)) * 900 + 30\n\nsc = plt.scatter(\n    df[\"Sale Price\"],\n    df[\"Star Rating\"],\n    s=sizes,\n    c=df[\"Discount Percentage\"].fillna(0),\n    cmap=\"viridis\",\n    alpha=0.75,\n    edgecolors=\"white\",\n    linewidths=0.5,\n)\n\nplt.title(\"Apple: Relación entre precio de venta y calificación\\n(Tamaño = nº de valoraciones, Color = % descuento)\")\nplt.xlabel(\"Sale Price (INR)\")\nplt.ylabel(\"Star Rating\")\nplt.ylim(0, 5)\nplt.grid(True, linestyle=\"--\", alpha=0.3)\n\ncbar = plt.colorbar(sc)\ncbar.set_label(\"Discount Percentage (%)\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "viridis", "reasoning": "The visualization uses plt.scatter to plot two quantitative dimensions (Sale Price and Star Rating) while modulating the size of the markers (s=sizes) based on a third quantitative dimension (Number of Ratings), fitting the taxonomy for a Bubble chart. The data is rendered using standard matplotlib.pyplot functions."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6apple_products.csv\")\n\n# Clean/parse RAM (e.g., \"4 GB\" -> 4)\ndf[\"Ram_GB\"] = (\n    df[\"Ram\"]\n    .astype(str)\n    .str.extract(r\"(\\d+)\")\n    .astype(float)\n)\n\n# Keep valid rows\nplot_df = df.dropna(subset=[\"Ram_GB\", \"Sale Price\", \"Star Rating\"]).copy()\n\n# Aggregate to avoid duplicates: mean rating per RAM, and count of products\nagg = (\n    plot_df.groupby(\"Ram_GB\", as_index=False)\n    .agg(avg_star=(\"Star Rating\", \"mean\"), n_products=(\"Product Name\", \"count\"))\n    .sort_values(\"Ram_GB\")\n)\n\n# --- Single chart: bubble scatter (x=RAM, y=avg rating, size=#products) ---\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9.5, 5.5))\n\nsizes = (agg[\"n_products\"] / agg[\"n_products\"].max()) * 1200  # scale bubble areas\nsc = ax.scatter(\n    agg[\"Ram_GB\"],\n    agg[\"avg_star\"],\n    s=sizes,\n    c=agg[\"avg_star\"],\n    cmap=\"viridis\",\n    alpha=0.85,\n    edgecolor=\"white\",\n    linewidth=1.2,\n)\n\nax.set_title(\"Average Star Rating by RAM (Bubble Size = # Products)\", pad=12, weight=\"bold\")\nax.set_xlabel(\"RAM (GB)\")\nax.set_ylabel(\"Average Star Rating\")\nax.set_xticks(sorted(agg[\"Ram_GB\"].unique()))\nax.set_ylim(4.35, 4.75)\n\n# Annotate bubbles with product counts\nfor _, r in agg.iterrows():\n    ax.annotate(\n        f\"{int(r['n_products'])}\",\n        (r[\"Ram_GB\"], r[\"avg_star\"]),\n        textcoords=\"offset points\",\n        xytext=(0, 8),\n        ha=\"center\",\n        fontsize=9,\n        color=\"#1f1f1f\",\n        weight=\"bold\",\n    )\n\ncbar = plt.colorbar(sc, ax=ax, pad=0.02)\ncbar.set_label(\"Average Star Rating\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "viridis", "reasoning": "The visualization uses Matplotlib's `ax.scatter()` to plot two quantitative variables (RAM and Star Rating). A third quantitative variable (count of products) is used to modulate the size of the points via the 's' parameter, which fits the definition of a Bubble chart."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport re\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6apple_products.csv\")\n\n# Parse storage (GB) from Product Name, e.g., \"(Gold, 64 GB)\" or \"(Space Grey, 256 GB)\"\ndef extract_storage_gb(name: str):\n    if not isinstance(name, str):\n        return None\n    m = re.search(r\"(\\d+)\\s*GB\", name, flags=re.IGNORECASE)\n    return int(m.group(1)) if m else None\n\ndf[\"Storage (GB)\"] = df[\"Product Name\"].apply(extract_storage_gb)\n\n# Keep only rows with parsed storage\nd = df.dropna(subset=[\"Storage (GB)\"]).copy()\nd[\"Storage (GB)\"] = d[\"Storage (GB)\"].astype(int)\n\n# Aggregate: median sale price and count per storage\ng = (\n    d.groupby(\"Storage (GB)\", as_index=False)\n    .agg(\n        Median_Sale_Price=(\"Sale Price\", \"median\"),\n        Models=(\"Product Name\", \"count\"),\n    )\n    .sort_values(\"Storage (GB)\")\n)\n\n# Plot: single chart (bar with model counts annotated)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\nbars = ax.bar(\n    g[\"Storage (GB)\"].astype(str),\n    g[\"Median_Sale_Price\"],\n    color=\"#2F6BFF\",\n    edgecolor=\"#1b1b1b\",\n    linewidth=0.6,\n)\n\nax.set_title(\"Median Sale Price by Storage Capacity (Apple products)\")\nax.set_xlabel(\"Storage (GB)\")\nax.set_ylabel(\"Median Sale Price (₹)\")\n\nax.yaxis.set_major_formatter(lambda x, pos: f\"₹{int(x):,}\")\n\n# Annotate each bar with model count\nfor bar, n in zip(bars, g[\"Models\"]):\n    ax.text(\n        bar.get_x() + bar.get_width() / 2,\n        bar.get_height(),\n        f\"{n} models\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n        color=\"#111111\",\n        rotation=0,\n        clip_on=False,\n    )\n\nax.margins(y=0.12)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using the matplotlib axes method `ax.bar()`, which draws vertical bars representing categorical data (Storage GB as strings) and quantitative data (Median Sale Price). According to the taxonomy, vertical bars are classified as a Column chart."}}
{"input_csv_file": "6apple_products.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport re\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# --- Load data ---\ncsv_path = \"6apple_products.csv\"\ndf = pd.read_csv(csv_path)\n\n# --- Parse storage (GB) from Product Name ---\n# Matches patterns like \"64 GB\", \"128 GB\", \"256 GB\", \"512 GB\"\ndef extract_storage_gb(name: str):\n    m = re.search(r'(\\d+)\\s*GB', str(name))\n    return int(m.group(1)) if m else np.nan\n\ndf[\"Storage (GB)\"] = df[\"Product Name\"].apply(extract_storage_gb)\n\n# Keep valid storage rows\nplot_df = df.dropna(subset=[\"Storage (GB)\", \"Sale Price\"]).copy()\n\n# Aggregate: median sale price by storage\nagg = (\n    plot_df.groupby(\"Storage (GB)\", as_index=False)\n    .agg(median_sale_price=(\"Sale Price\", \"median\"), count=(\"Sale Price\", \"size\"))\n    .sort_values(\"Storage (GB)\")\n)\n\n# --- Plot (single chart) ---\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\nbars = ax.bar(\n    agg[\"Storage (GB)\"].astype(int).astype(str),\n    agg[\"median_sale_price\"],\n    color=\"#1f77b4\",\n    edgecolor=\"white\",\n    linewidth=1.0\n)\n\nax.set_title(\"Median Sale Price by Storage (Apple iPhone Listings)\", pad=12, weight=\"bold\")\nax.set_xlabel(\"Storage\")\nax.set_ylabel(\"Median Sale Price (₹)\")\n\n# Add count labels above bars (n listings per storage)\nymax = agg[\"median_sale_price\"].max()\nfor b, n in zip(bars, agg[\"count\"]):\n    ax.text(\n        b.get_x() + b.get_width() / 2,\n        b.get_height() + 0.015 * ymax,\n        f\"n={int(n)}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=10,\n        color=\"#333333\"\n    )\n\nax.set_ylim(0, ymax * 1.12)\nax.tick_params(axis=\"x\", rotation=0)\n\n# Tight layout and show\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using the matplotlib function `ax.bar()`, which renders vertical bars representing categorical data (Storage) and quantitative values (Median Sale Price). According to the taxonomy, vertical bar charts are classified as Column charts."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\n\n# Parse Month as datetime\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Plot (single chart)\nfig, ax = plt.subplots(figsize=(11, 5))\nax.plot(df[\"Month\"], df[\"Monthly beer production\"], linewidth=2, color=\"#1f77b4\")\n\nax.set_title(\"Monthly Beer Production (1956–1964)\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Monthly beer production\")\nax.grid(True, which=\"major\", linestyle=\"--\", alpha=0.3)\n\nax.xaxis.set_major_locator(mdates.YearLocator())\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nax.xaxis.set_minor_locator(mdates.MonthLocator(bymonth=(1, 4, 7, 10)))\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the matplotlib Axes method `ax.plot()` to render a temporal sequence of beer production values, which classifies it as a Line chart within the matplotlib library."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Create a single chart: time series line plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 5))\n\nax.plot(df[\"Month\"], df[\"Monthly beer production\"], linewidth=2, color=\"#1f77b4\")\n\nax.set_title(\"Monthly Beer Production (1956–1964)\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Monthly beer production\")\n\nax.xaxis.set_major_locator(mdates.YearLocator())\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nax.margins(x=0)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib axes function `ax.plot()` to render the data. It visualizes temporal (Month) and quantitative (Monthly beer production) variables, which defines a Line chart according to the taxonomy."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\n\n# Parse dates and sort (safe even if already sorted)\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Plot (single chart)\nfig, ax = plt.subplots(figsize=(11, 5))\nax.plot(df[\"Month\"], df[\"Monthly beer production\"], linewidth=2)\n\nax.set_title(\"Monthly Beer Production (1956–1964)\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Monthly beer production\")\n\n# Make the time axis readable\nax.xaxis.set_major_locator(mdates.YearLocator())\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.6)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using ax.plot() directly from the matplotlib library. The chart visualizes a quantitative variable (beer production) against a temporal variable (Month), which classifies it as a Line chart."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Plot (single chart)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 5))\n\nax.plot(df[\"Month\"], df[\"Monthly beer production\"], linewidth=2)\n\nax.set_title(\"Monthly Beer Production (1956–1964)\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Monthly beer production\")\n\nax.xaxis.set_major_locator(mdates.YearLocator())\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the Matplotlib library (ax.plot) to plot a temporal variable (Month) against a quantitative variable (Monthly beer production), which fits the definition of a line chart."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Plot\nfig, ax = plt.subplots(figsize=(10, 5))\nax.plot(df[\"Month\"], df[\"Monthly beer production\"], linewidth=2, color=\"#1f77b4\")\n\nax.set_title(\"Monthly Beer Production (1956–1964)\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Monthly beer production\")\nax.grid(True, alpha=0.3)\n\nax.xaxis.set_major_locator(mdates.YearLocator(1))\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nfig.autofmt_xdate()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the `ax.plot()` method directly from the matplotlib library. The visualization displays a temporal dimension (Month) and a quantitative dimension (Monthly beer production) connected by a line."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\n\n# Parse dates and sort\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Plot (single chart)\nplt.figure(figsize=(12, 5))\nplt.plot(df[\"Month\"], df[\"Monthly beer production\"], linewidth=2)\n\nplt.title(\"Monthly Beer Production (1956–1964)\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Monthly beer production\")\nplt.grid(True, alpha=0.3)\n\nax = plt.gca()\nax.xaxis.set_major_locator(mdates.YearLocator())\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nax.xaxis.set_minor_locator(mdates.MonthLocator(interval=3))\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly to create the visualization, which maps a temporal dimension (Month) to a quantitative dimension (Monthly beer production). According to the hierarchy rules, since it uses matplotlib.pyplot functions directly and not pandas .plot() or seaborn, the library is matplotlib."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\ndef main():\n    df = pd.read_csv(\"6beer.csv\")\n    df[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\n    df = df.sort_values(\"Month\")\n\n    fig, ax = plt.subplots(figsize=(11, 5))\n    ax.plot(df[\"Month\"], df[\"Monthly beer production\"], linewidth=2)\n\n    ax.set_title(\"Monthly Beer Production (1956–1964)\")\n    ax.set_xlabel(\"Month\")\n    ax.set_ylabel(\"Monthly beer production\")\n\n    ax.xaxis.set_major_locator(mdates.YearLocator())\n    ax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\n    ax.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered directly using the matplotlib axis method `ax.plot()`. The chart uses temporal (Month) and quantitative (Monthly beer production) variables, which classifies it as a Line chart."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Single chart: time series line plot\nplt.figure(figsize=(10, 4.8))\nplt.plot(df[\"Month\"], df[\"Monthly beer production\"], linewidth=2)\n\nplt.title(\"Monthly Beer Production (1956–1964)\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Monthly beer production\")\n\nax = plt.gca()\nax.xaxis.set_major_locator(mdates.YearLocator())\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nax.xaxis.set_minor_locator(mdates.MonthLocator(bymonth=(1, 7)))\n\nplt.grid(True, which=\"major\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the plt.plot() function from matplotlib directly to visualize temporal data (Month) against a quantitative variable (Monthly beer production)."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"6beer.csv\")\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Gráfico (una sola figura, una sola serie)\nplt.figure(figsize=(11, 5))\nplt.plot(df[\"Month\"], df[\"Monthly beer production\"], linewidth=2, color=\"tab:blue\")\nplt.title(\"Producción mensual de cerveza (1956–1964)\")\nplt.xlabel(\"Mes\")\nplt.ylabel(\"Producción mensual de cerveza\")\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses plt.plot() to map a temporal dimension (Month) against a quantitative dimension (Monthly beer production), which identifies it as a line chart drawn directly with matplotlib."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11.5, 5.5))\n\nax.plot(\n    df[\"Month\"],\n    df[\"Monthly beer production\"],\n    color=\"#1f77b4\",\n    linewidth=2.2,\n)\n\n# Highlight max and min\ni_max = df[\"Monthly beer production\"].idxmax()\ni_min = df[\"Monthly beer production\"].idxmin()\n\nax.scatter(df.loc[i_max, \"Month\"], df.loc[i_max, \"Monthly beer production\"], color=\"#d62728\", s=45, zorder=3)\nax.scatter(df.loc[i_min, \"Month\"], df.loc[i_min, \"Monthly beer production\"], color=\"#2ca02c\", s=45, zorder=3)\n\nax.annotate(\n    f\"Peak: {df.loc[i_max, 'Monthly beer production']:.1f}\",\n    (df.loc[i_max, \"Month\"], df.loc[i_max, \"Monthly beer production\"]),\n    xytext=(10, 10),\n    textcoords=\"offset points\",\n    fontsize=10,\n    color=\"#d62728\",\n)\nax.annotate(\n    f\"Low: {df.loc[i_min, 'Monthly beer production']:.1f}\",\n    (df.loc[i_min, \"Month\"], df.loc[i_min, \"Monthly beer production\"]),\n    xytext=(10, -16),\n    textcoords=\"offset points\",\n    fontsize=10,\n    color=\"#2ca02c\",\n)\n\n# Formatting\nax.set_title(\"Monthly Beer Production (1956–1964)\", fontsize=14, pad=10)\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Production\")\n\nax.xaxis.set_major_locator(mdates.YearLocator())\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nax.xaxis.set_minor_locator(mdates.MonthLocator(bymonth=(1, 7)))\n\nax.margins(x=0.01)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses the `ax.plot()` method from matplotlib to render data. It displays temporal (Month) and quantitative (Production) data over time, which defines a Line chart."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 5.5))\n\nax.plot(\n    df[\"Month\"],\n    df[\"Monthly beer production\"],\n    color=\"#2C7FB8\",\n    linewidth=2.2\n)\n\nax.set_title(\"Monthly Beer Production (1956–1964)\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Production\")\n\nax.xaxis.set_major_locator(mdates.YearLocator())\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nax.xaxis.set_minor_locator(mdates.MonthLocator(bymonth=(1, 7)))\n\nax.margins(x=0.01)\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the ax.plot() method from the matplotlib library. The visualization maps temporal (Month) and quantitative (Monthly beer production) dimensions using a line, which corresponds to the Line chart taxonomy."}}
{"input_csv_file": "6beer.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6beer.csv\")\ndf[\"Month\"] = pd.to_datetime(df[\"Month\"], format=\"%Y-%m\")\ndf = df.sort_values(\"Month\")\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 5))\n\nax.plot(\n    df[\"Month\"],\n    df[\"Monthly beer production\"],\n    color=\"#1f77b4\",\n    linewidth=2.2,\n)\n\n# Formatting\nax.set_title(\"Monthly Beer Production (1956–1964)\", pad=10)\nax.set_xlabel(\"Month\")\nax.set_ylabel(\"Production\")\n\nax.xaxis.set_major_locator(mdates.YearLocator(1))\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nax.xaxis.set_minor_locator(mdates.MonthLocator(bymonth=(1, 7)))\n\nax.margins(x=0)\nfig.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using the Matplotlib library's `ax.plot()` function directly on the data. It maps temporal (Month) and quantitative (Monthly beer production) variables onto a continuous line, which corresponds to the 'Line chart' taxonomy."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6big mac.csv\")\n\n# Parse dates\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\n\n# Keep only the 6 currencies (raw misvaluation vs those base currencies)\ncols = [\"USD_raw\", \"EUR_raw\", \"GBP_raw\", \"JPY_raw\", \"CNY_raw\"]\nplot_df = df[[\"date\"] + cols].dropna().sort_values(\"date\")\n\n# Aggregate by date (in case multiple rows per date exist)\nplot_df = plot_df.groupby(\"date\", as_index=True)[cols].mean()\n\n# Plot\nplt.figure(figsize=(10, 5.5))\nfor c in cols:\n    plt.plot(plot_df.index, plot_df[c] * 100, linewidth=2, label=c.replace(\"_raw\", \"\"))\n\nplt.axhline(0, color=\"black\", linewidth=1, alpha=0.6)\nplt.title(\"Big Mac Index: Average implied misvaluation vs major base currencies\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Misvaluation (%)\")\nplt.legend(title=\"Base currency\", ncols=3, frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib.pyplot function 'plt.plot()' within a loop to draw lines for each currency. It uses temporal (date), quantitative (misvaluation), and categorical (base currency) dimensions, fitting the Line chart definition."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6big mac.csv\")\n\n# Parse dates\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"date\"])\n\n# Compare Big Mac prices in USD for a few selected economies over time\nfocus = [\"United States\", \"Euro area\", \"Britain\", \"Japan\", \"China\", \"Switzerland\"]\nplot_df = (\n    df[df[\"name\"].isin(focus)]\n    .sort_values([\"name\", \"date\"])\n    .pivot(index=\"date\", columns=\"name\", values=\"dollar_price\")\n)\n\n# Plot: one chart (multi-line)\nplt.figure(figsize=(10, 5))\nfor col in plot_df.columns:\n    plt.plot(plot_df.index, plot_df[col], linewidth=2, label=col)\n\nplt.title(\"Big Mac Price in USD (Selected Economies)\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Big Mac price (USD)\")\nplt.grid(True, alpha=0.3)\nplt.legend(title=\"Country/Region\", ncols=2, frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses plt.plot() directly within a loop to render individual lines from a pivoted DataFrame. Following the hierarchy rules, since no seaborn or pandas plotting functions are used to draw the data, it is classified as matplotlib."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6big mac.csv\")\n\n# Parse date and compute average dollar_price by date\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\navg_by_date = (\n    df.dropna(subset=[\"date\", \"dollar_price\"])\n      .groupby(\"date\", as_index=False)[\"dollar_price\"]\n      .mean()\n      .sort_values(\"date\")\n)\n\n# Single chart: average Big Mac price in USD over time\nplt.figure(figsize=(9, 4.8))\nplt.plot(avg_by_date[\"date\"], avg_by_date[\"dollar_price\"], marker=\"o\", linewidth=2)\nplt.title(\"Average Big Mac Price (USD) Over Time\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Average Big Mac price (USD)\")\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the plt.plot() function from matplotlib directly to visualize temporal (date) and quantitative (average price) data. Since it does not use pandas' .plot() wrapper or seaborn functions, the library is classified as matplotlib."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Load data\ndf = pd.read_csv(\"6big mac.csv\")\n\n# Ensure date is datetime\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\n\n# Use the latest date available\nlatest_date = df[\"date\"].max()\nd = df[df[\"date\"] == latest_date].copy()\n\n# Keep only rows with needed values\nd = d.dropna(subset=[\"name\", \"dollar_price\", \"USD_raw\"])\n\n# Select 10 countries for a readable chart:\n# biggest undervaluation (most negative USD_raw) and biggest overvaluation (most positive USD_raw)\nd = d.sort_values(\"USD_raw\")\nlow = d.head(5)\nhigh = d.tail(5)\nplot_df = pd.concat([low, high]).copy()\n\n# Sort for plotting\nplot_df = plot_df.sort_values(\"USD_raw\")\n\n# Colors: undervalued (negative) vs overvalued (positive)\ncolors = [\"#1f77b4\" if v < 0 else \"#d62728\" for v in plot_df[\"USD_raw\"]]\n\n# Plot\nfig, ax = plt.subplots(figsize=(10, 6))\nax.barh(plot_df[\"name\"], plot_df[\"USD_raw\"], color=colors)\n\nax.axvline(0, color=\"black\", linewidth=1)\nax.xaxis.set_major_formatter(mtick.PercentFormatter(xmax=1.0))\n\nax.set_title(f\"Big Mac Index vs USD (raw): Over/Undervaluation by Country\\nLatest date: {latest_date.date()}\")\nax.set_xlabel(\"Undervaluation (−) / Overvaluation (+) vs USD\")\nax.set_ylabel(\"Country\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is rendered using the `ax.barh()` method from the matplotlib library, which creates horizontal bars. The colors are defined using a custom conditional list of hex codes rather than a named color palette."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6big mac.csv\")\n\n# Parse dates and keep only country rows (exclude Euro area aggregate)\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"date\"])\ndf = df[df[\"iso_a3\"] != \"EUZ\"].copy()\n\n# Use the latest date in the file\nlatest_date = df[\"date\"].max()\nlatest = df[df[\"date\"] == latest_date].copy()\n\n# Pick top 10 most overvalued vs USD (highest USD_raw), excluding USA (0 baseline)\nlatest = latest[latest[\"iso_a3\"] != \"USA\"]\nlatest = latest.sort_values(\"USD_raw\", ascending=False).head(10)\n\n# Plot\nplt.figure(figsize=(10, 6))\nplt.bar(latest[\"name\"], latest[\"USD_raw\"] * 100, color=\"#4C78A8\")\nplt.axhline(0, color=\"black\", linewidth=1)\n\nplt.title(f\"Big Mac Index: Top 10 Overvalued Currencies vs USD ({latest_date.date()})\")\nplt.ylabel(\"Implied over/undervaluation vs USD (%)\")\nplt.xlabel(\"Country\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the plt.bar() function directly from matplotlib to create vertical bars. Following the taxonomy, vertical bars are classified as a Column chart."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"6big mac.csv\")\n    df[\"date\"] = pd.to_datetime(df[\"date\"])\n\n    # Pivot to get dollar_price time series per country\n    pivot = df.pivot_table(index=\"date\", columns=\"name\", values=\"dollar_price\", aggfunc=\"mean\").sort_index()\n\n    fig, ax = plt.subplots(figsize=(10, 5))\n\n    for country in pivot.columns:\n        ax.plot(pivot.index, pivot[country], linewidth=2 if country == \"United States\" else 1.2,\n                alpha=1.0 if country == \"United States\" else 0.8, label=country)\n\n    ax.set_title(\"Big Mac Price in USD Over Time (by Country)\")\n    ax.set_xlabel(\"Date\")\n    ax.set_ylabel(\"Dollar price (USD)\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\n    ax.legend(title=\"Country\", ncol=2, fontsize=9, title_fontsize=10, frameon=False)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the matplotlib Axes function 'ax.plot()' to render temporal data (date) against quantitative data (dollar_price) for multiple categories (countries) in a loop, which defines a line chart."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load CSV\ndf = pd.read_csv(\"6big mac.csv\")\n\n# Parse date\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\n\n# Keep only the 6 currency mispricing columns (raw)\nraw_cols = [\"USD_raw\", \"EUR_raw\", \"GBP_raw\", \"JPY_raw\", \"CNY_raw\"]\nplot_df = df[[\"date\"] + raw_cols].copy()\n\n# Aggregate by date (in case multiple rows per date exist)\nplot_df = plot_df.groupby(\"date\", as_index=True)[raw_cols].mean().sort_index()\n\n# Plot: one chart with all 5 lines\nplt.figure(figsize=(10, 5.5))\nfor col in raw_cols:\n    plt.plot(plot_df.index, plot_df[col], marker=\"o\", linewidth=2, label=col.replace(\"_raw\", \"\"))\n\nplt.axhline(0, color=\"black\", linewidth=1, alpha=0.6)\nplt.title(\"Big Mac Index: Raw Mispricing vs Major Currencies (Mean across Countries)\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Raw mispricing (0 = fair value)\")\nplt.grid(True, linestyle=\"--\", alpha=0.35)\nplt.legend(title=\"Currency\", ncols=3, frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot interface (plt.plot) to render data over time (temporal dimension) with categorical series (currencies) and quantitative values (mispricing), fitting the definition of a line chart."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Read data\ndf = pd.read_csv(\"6big mac.csv\")\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\n\n# Use one date snapshot (latest available) and compare Big Mac prices in USD\nlatest_date = df[\"date\"].max()\nsnap = df[df[\"date\"] == latest_date].copy()\n\n# Clean and sort\nsnap = snap.dropna(subset=[\"dollar_price\", \"name\"])\nsnap = snap.sort_values(\"dollar_price\", ascending=True)\n\n# Plot (single chart)\nplt.figure(figsize=(10, 8))\nplt.barh(snap[\"name\"], snap[\"dollar_price\"], color=\"#4C78A8\")\nplt.xlabel(\"Big Mac price (USD)\")\nplt.ylabel(\"Country/Region\")\nplt.title(f\"Big Mac Price by Country (USD) — {latest_date.date()}\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization is created using `plt.barh()`, which is a standard matplotlib function for rendering horizontal bars. Following the taxonomy, horizontal bars are classified as a 'Bar chart'."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"6big mac.csv\")\n\n# Preparación\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"date\", \"dollar_price\", \"name\"])\n\n# Calcular promedio por fecha (precio del Big Mac en USD)\navg_by_date = (\n    df.groupby(\"date\", as_index=False)[\"dollar_price\"]\n      .mean()\n      .sort_values(\"date\")\n)\n\n# Gráfico (un solo chart)\nplt.figure(figsize=(10, 5))\nplt.plot(avg_by_date[\"date\"], avg_by_date[\"dollar_price\"], marker=\"o\", linewidth=2)\nplt.title(\"Precio promedio del Big Mac en USD por fecha\")\nplt.xlabel(\"Fecha\")\nplt.ylabel(\"Precio (USD)\")\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization uses plt.plot() directly to render data, identifying the library as matplotlib. It plots a temporal variable (date) against a quantitative variable (price), which fits the taxonomy definition for a Line chart."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# --- Load ---\ndf = pd.read_csv(\"6big mac.csv\")\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"date\"])\n\n# Keep the countries present across the most dates (for a clean multi-line chart)\ncoverage = df.groupby(\"name\")[\"date\"].nunique().sort_values(ascending=False)\ntop_names = coverage.head(12).index  # enough variety; still readable\ndff = df[df[\"name\"].isin(top_names)].copy()\n\n# --- Prepare (Big Mac \"valuation vs USD\" = USD_raw; treat as % difference) ---\n# Pivot to wide form for plotting\nwide = (\n    dff.pivot_table(index=\"date\", columns=\"name\", values=\"USD_raw\", aggfunc=\"mean\")\n    .sort_index()\n)\n\n# --- Plot (single chart) ---\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 6.5))\n\nfor col in wide.columns:\n    ax.plot(wide.index, wide[col], linewidth=2, label=col)\n\nax.axhline(0, color=\"black\", linewidth=1, alpha=0.8)\n\nax.set_title(\"Big Mac Index vs USD (USD_raw) — Over/Undervaluation by Country\", pad=12)\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Implied valuation vs USD\")\nax.yaxis.set_major_formatter(mtick.PercentFormatter(xmax=1.0))\n\n# Legend outside for readability\nax.legend(title=\"Country\", loc=\"center left\", bbox_to_anchor=(1.02, 0.5), frameon=True)\n\nfig.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib axes function ax.plot() within a loop for each category. Since it uses temporal, categorical, and quantitative dimensions to draw lines over time, it is classified as a Line chart."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Load data\ndf = pd.read_csv(\"6big mac.csv\")\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\n\n# Keep rows with valid dates and needed fields\ndf = df.dropna(subset=[\"date\", \"USD_raw\", \"name\"])\n\n# Choose a few countries with multiple observations (best for time-series visibility)\nmin_points = 2\ncounts = df.groupby(\"name\")[\"USD_raw\"].count().sort_values(ascending=False)\ncountries = counts[counts >= min_points].head(8).index.tolist()\n\nplot_df = df[df[\"name\"].isin(countries)].copy()\nplot_df = plot_df.sort_values([\"name\", \"date\"])\n\n# Plot: Big Mac \"undervaluation/overvaluation\" vs USD (USD_raw) over time\nfig, ax = plt.subplots(figsize=(11, 6))\n\nfor name, g in plot_df.groupby(\"name\"):\n    ax.plot(g[\"date\"], g[\"USD_raw\"], marker=\"o\", linewidth=2, label=name)\n\nax.axhline(0, color=\"black\", linewidth=1, alpha=0.6)\n\nax.set_title(\"Big Mac Index vs USD (USD_raw): Undervaluation (-) / Overvaluation (+)\")\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"USD_raw (relative to USD)\")\n\nax.xaxis.set_major_locator(mdates.YearLocator())\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\nax.grid(True, which=\"major\", axis=\"both\", alpha=0.25)\n\nax.legend(title=\"Country\", ncol=2, frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.plot() function directly to visualize a temporal variable (date) against a quantitative variable (USD_raw) across multiple categories (countries), which corresponds to the definition of a line chart."}}
{"input_csv_file": "6big mac.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"6big mac.csv\")\ndf[\"date\"] = pd.to_datetime(df[\"date\"], errors=\"coerce\")\n\n# Keep 2000-2002 (as provided) and focus on \"Big Mac implied dollar price\"\ndf = df.dropna(subset=[\"date\", \"dollar_price\", \"name\"])\ndf = df.sort_values([\"date\", \"name\"])\n\n# Plot: each country's implied USD price over time\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6))\n\nfor country, g in df.groupby(\"name\", sort=False):\n    ax.plot(g[\"date\"], g[\"dollar_price\"], marker=\"o\", linewidth=2, label=country, alpha=0.9)\n\nax.set_title(\"Big Mac implied dollar price by country (2000–2002)\")\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Implied price (USD)\")\nax.legend(title=\"Country\", ncol=2, fontsize=9, title_fontsize=10, frameon=True)\nax.margins(x=0.02)\nfig.tight_layout()\n\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The visualization is created using standard matplotlib axes plotting (ax.plot) within a loop. It plots a temporal variable (date) against a quantitative variable (dollar_price) for different categories (countries), which classifies it as a Line chart."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"7bloodtype.csv\")\n\nblood_cols = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']\n\n# Compute population-weighted global distribution (ignore NaNs)\nweights = df['Population'].astype(float)\nweighted = {}\nfor col in blood_cols:\n    valid = df[col].notna() & weights.notna()\n    if valid.any():\n        weighted[col] = np.average(df.loc[valid, col].astype(float), weights=weights.loc[valid])\n    else:\n        weighted[col] = np.nan\n\ndist = pd.Series(weighted).dropna()\n\n# Plot single chart: population-weighted blood type distribution across countries\nplt.figure(figsize=(10, 5))\nbars = plt.bar(dist.index, dist.values, color=[\n    \"#4C78A8\", \"#F58518\", \"#54A24B\", \"#E45756\",\n    \"#72B7B2\", \"#B279A2\", \"#FF9DA6\", \"#9D755D\"\n][:len(dist)])\n\nplt.title(\"Population-weighted Blood Type Distribution (across countries in 7bloodtype.csv)\")\nplt.ylabel(\"Percent of population (%)\")\nplt.ylim(0, max(60, dist.max() * 1.15))\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width()/2, h + 0.7, f\"{h:.1f}%\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render vertical bars based on a pandas Series, which falls under matplotlib according to the hierarchy rules. Since the bars are vertical, it is classified as a Column chart."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7bloodtype.csv\")\n\n# Blood type percentage columns\nbt_cols = [\"O+\", \"A+\", \"B+\", \"AB+\", \"O-\", \"A-\", \"B-\", \"AB-\"]\n\n# Compute population-weighted global distribution (ignoring NaNs)\nweighted = {}\nfor col in bt_cols:\n    mask = df[col].notna()\n    weighted[col] = (df.loc[mask, \"Population\"] * (df.loc[mask, col] / 100.0)).sum()\n\ntotal_weighted = sum(weighted.values())\nglobal_pct = {k: (v / total_weighted) * 100 for k, v in weighted.items()}\n\n# Prepare series in desired order\nseries = pd.Series(global_pct).reindex(bt_cols)\n\n# Plot: single chart\nplt.figure(figsize=(10, 5.5))\nbars = plt.bar(series.index, series.values, color=\"#4C78A8\")\n\nplt.title(\"Estimated Global Blood Type Distribution (Population-Weighted Across Countries)\")\nplt.xlabel(\"Blood type\")\nplt.ylabel(\"Share of people (%)\")\nplt.ylim(0, max(series.values) * 1.2)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n# Value labels\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h + 0.3, f\"{h:.1f}%\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function `plt.bar()` to render data directly rather than using pandas or seaborn wrappers. Since the bars are vertical, it is classified as a Column chart per the taxonomy."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7bloodtype.csv\")\n\n# Blood type columns (percentages)\nbt_cols = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']\n\n# Convert to numeric (handles any unexpected text); keep NaN if present\nfor c in bt_cols:\n    df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n# Pick 10 most populous countries to keep the chart readable\ntop = df.nlargest(10, \"Population\").copy()\n\n# Create a 100% stacked bar chart (percent composition)\nplot_df = top.set_index(\"Country\")[bt_cols]\n\nax = plot_df.plot(\n    kind=\"bar\",\n    stacked=True,\n    figsize=(12, 6),\n    width=0.85\n)\n\nax.set_title(\"Blood Type Distribution (%) — 10 Most Populous Countries\")\nax.set_xlabel(\"Country\")\nax.set_ylabel(\"Percent of population\")\nax.set_ylim(0, 100)\n\n# Legend outside for readability\nax.legend(\n    title=\"Blood type\",\n    bbox_to_anchor=(1.02, 1),\n    loc=\"upper left\",\n    borderaxespad=0\n)\n\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The data is rendered using the DataFrame.plot() wrapper with kind='bar' and stacked=True. Since pandas 'bar' charts are vertical by default, it is classified as a Stacked column chart."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7bloodtype.csv\")\n\n# Columns for positive blood types\npos_cols = [\"O+\", \"A+\", \"B+\", \"AB+\"]\n\n# Ensure numeric (in case of stray strings)\nfor c in pos_cols + [\"Population\"]:\n    df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n# Pick top 10 countries by population for readability\ntop = df.sort_values(\"Population\", ascending=False).head(10).copy()\ntop = top.sort_values(\"Population\", ascending=True)  # for nicer horizontal ordering\n\n# Plot: stacked horizontal bar chart of positive blood types (%)\nfig, ax = plt.subplots(figsize=(11, 6))\nleft = pd.Series([0.0] * len(top), index=top.index)\n\ncolors = {\"O+\": \"#4C78A8\", \"A+\": \"#F58518\", \"B+\": \"#54A24B\", \"AB+\": \"#B279A2\"}\n\nfor col in pos_cols:\n    ax.barh(top[\"Country\"], top[col], left=left, label=col, color=colors[col], edgecolor=\"white\", linewidth=0.6)\n    left = left + top[col].fillna(0)\n\nax.set_title(\"Distribution of Positive Blood Types (Top 10 Countries by Population)\")\nax.set_xlabel(\"Percent of population (%)\")\nax.set_ylabel(\"Country\")\nax.set_xlim(0, 100)\nax.legend(title=\"Blood type\", ncol=4, frameon=False, loc=\"lower right\")\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() method in a loop, utilizing the 'left' parameter to stack different blood types on top of each other horizontally. Since the bars are horizontal and stacked, it is classified as a Stacked bar chart."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7bloodtype.csv\")\n\n# Blood type columns\nbt_cols = [\"O+\", \"A+\", \"B+\", \"AB+\", \"O-\", \"A-\", \"B-\", \"AB-\"]\n\n# Ensure numeric (handles any stray strings / NaNs)\nfor c in bt_cols:\n    df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n# Population-weighted global average percentage for each blood type\npop = df[\"Population\"].astype(float)\nweighted = {}\nfor c in bt_cols:\n    mask = df[c].notna() & pop.notna()\n    weighted[c] = np.average(df.loc[mask, c], weights=pop.loc[mask])\n\n# Plot single chart\nlabels = list(weighted.keys())\nvalues = [weighted[k] for k in labels]\n\nplt.figure(figsize=(10, 5.5))\nbars = plt.bar(labels, values, color=[\"#4C78A8\"] * 4 + [\"#F58518\"] * 4)\nplt.title(\"Population-weighted Global Average Blood Type Distribution (from 7bloodtype.csv)\")\nplt.ylabel(\"Percent of population (%)\")\nplt.ylim(0, max(values) * 1.2)\n\n# Value labels\nfor b, v in zip(bars, values):\n    plt.text(b.get_x() + b.get_width() / 2, v + 0.2, f\"{v:.2f}%\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using `plt.bar()` directly, which classifies the library as 'matplotlib' based on the hierarchy rules. Since the bars are vertical, it is categorized as a 'Column chart' per the provided taxonomy."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"7bloodtype.csv\")\n\n# Blood type columns (percentages)\nblood_cols = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']\n\n# Compute population-weighted global distribution (ignore NaNs per column)\nweights = df['Population'].astype(float)\nweighted = {}\nfor c in blood_cols:\n    vals = df[c].astype(float)\n    mask = vals.notna() & weights.notna()\n    if mask.sum() == 0:\n        weighted[c] = np.nan\n    else:\n        # vals are percentages, so multiply by population then divide by total population considered\n        weighted[c] = (vals[mask] / 100.0 * weights[mask]).sum() / weights[mask].sum() * 100.0\n\ndist = pd.Series(weighted).dropna()\n\n# Plot: single chart (bar)\nplt.figure(figsize=(10, 5))\ncolors = ['#4C78A8', '#F58518', '#E45756', '#72B7B2', '#54A24B', '#EECA3B', '#B279A2', '#FF9DA6'][:len(dist)]\nplt.bar(dist.index, dist.values, color=colors, edgecolor='black', linewidth=0.6)\n\nplt.title(\"Population-weighted Global Blood Type Distribution (from 7bloodtype.csv)\")\nplt.ylabel(\"Estimated share of population (%)\")\nplt.xlabel(\"Blood type\")\nplt.ylim(0, max(60, dist.max() * 1.15))\nplt.grid(axis='y', linestyle='--', alpha=0.35)\n\n# Annotate values\nfor x, y in zip(dist.index, dist.values):\n    plt.text(x, y + 0.6, f\"{y:.1f}%\", ha='center', va='bottom', fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses the plt.bar() function from the matplotlib.pyplot library to render vertical bars. While the data is prepared using pandas, the plotting is done directly through matplotlib rather than a wrapper. Since the bars are vertical, it is classified as a Column chart."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"7bloodtype.csv\")\n\n    blood_cols = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']\n    for c in blood_cols:\n        df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n    # Population-weighted global average (%) for each blood type\n    weights = df[\"Population\"].astype(float)\n    weighted_avg = (df[blood_cols].multiply(weights, axis=0).sum(axis=0) / weights.sum()).sort_values(ascending=False)\n\n    plt.figure(figsize=(10, 5))\n    ax = weighted_avg.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\", linewidth=0.5)\n\n    ax.set_title(\"Population-weighted Global Average Blood Type Distribution\")\n    ax.set_xlabel(\"Blood Type\")\n    ax.set_ylabel(\"Average (%)\")\n    ax.set_ylim(0, max(60, float(weighted_avg.max()) * 1.15))\n    ax.grid(axis=\"y\", alpha=0.3)\n\n    for p in ax.patches:\n        h = p.get_height()\n        ax.annotate(f\"{h:.1f}%\", (p.get_x() + p.get_width() / 2, h),\n                    ha=\"center\", va=\"bottom\", fontsize=9, xytext=(0, 3),\n                    textcoords=\"offset points\")\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is generated using the pandas Series.plot() wrapper with kind='bar'. According to the library priority rules, if .plot() is used, the library is classified as pandas. Because the bars are oriented vertically, the chart is categorized as a Column chart."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"7bloodtype.csv\")\n\n    blood_cols = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']\n    missing = [c for c in ['Country', 'Population'] + blood_cols if c not in df.columns]\n    if missing:\n        raise ValueError(f\"Missing required columns: {missing}\")\n\n    # Convert blood type percentages to numeric and handle missing values\n    for c in blood_cols:\n        df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n    # Compute population-weighted global distribution (ignoring NaNs per column)\n    weights = df['Population'].astype(float)\n    weighted_pct = {}\n    for c in blood_cols:\n        valid = df[c].notna() & weights.notna()\n        denom = weights[valid].sum()\n        weighted_pct[c] = float((df.loc[valid, c] * weights[valid]).sum() / denom) if denom > 0 else float(\"nan\")\n\n    s = pd.Series(weighted_pct).sort_values(ascending=False)\n\n    plt.figure(figsize=(10, 5.5))\n    bars = plt.bar(s.index, s.values, color=\"#4C78A8\")\n    plt.title(\"Population-Weighted Average Blood Type Distribution (101 Countries)\")\n    plt.ylabel(\"Percentage (%)\")\n    plt.ylim(0, max(5, (s.max() if pd.notna(s.max()) else 0) * 1.15))\n    plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n    for b in bars:\n        h = b.get_height()\n        if pd.notna(h):\n            plt.text(b.get_x() + b.get_width() / 2, h, f\"{h:.2f}%\", ha=\"center\", va=\"bottom\", fontsize=9)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() to render the data directly, which classifies the library as matplotlib. Since plt.bar() creates vertical bars by default, it is classified as a Column chart. The color is specified using a single hex code (#4C78A8) rather than a named palette."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"7bloodtype.csv\")\n\n# Columnas de tipos de sangre\nblood_cols = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']\n\n# Promedio global (ignorando NaN)\navg = df[blood_cols].mean(skipna=True).sort_values(ascending=False)\n\n# Gráfico (una sola figura)\nplt.figure(figsize=(10, 5))\nplt.bar(avg.index, avg.values, color=\"#4C78A8\")\nplt.title(\"Promedio global de distribución de tipos de sangre (por país)\")\nplt.xlabel(\"Tipo de sangre\")\nplt.ylabel(\"Porcentaje promedio (%)\")\nplt.ylim(0, max(avg.values) * 1.15)\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "#4C78A8", "reasoning": "The visualization is created using plt.bar() directly, which renders vertical bars and classifies as a Column chart under the provided taxonomy. Since the data is rendered via matplotlib.pyplot rather than a pandas .plot() wrapper or seaborn, the library is identified as matplotlib."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7bloodtype.csv\")\n\n# Blood type columns\nbt_cols = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']\n\n# Ensure numeric + handle missing\nfor c in bt_cols + ['Population']:\n    df[c] = pd.to_numeric(df[c], errors='coerce')\n\ndf = df.dropna(subset=['Population'])\ndf[bt_cols] = df[bt_cols].fillna(0.0)\n\n# Compute population-weighted global distribution\npop = df['Population'].to_numpy(dtype=float)\nvals = df[bt_cols].to_numpy(dtype=float) / 100.0\nweighted = (vals * pop[:, None]).sum(axis=0) / pop.sum()\nweighted_pct = weighted * 100\n\n# Colors: ABO hues, Rh- darkened\nbase = {'O': '#4C78A8', 'A': '#54A24B', 'B': '#E45756', 'AB': '#F2B701'}\ndef color_for(bt):\n    abo = bt.replace('+', '').replace('-', '')\n    col = base[abo]\n    if bt.endswith('-'):\n        # darken for Rh-\n        import matplotlib.colors as mcolors\n        rgb = np.array(mcolors.to_rgb(col))\n        rgb = (rgb * 0.72).clip(0, 1)\n        return rgb\n    return col\n\ncolors = [color_for(c) for c in bt_cols]\n\n# Plot\nplt.rcParams.update({\n    \"figure.dpi\": 140,\n    \"font.size\": 10,\n    \"axes.titlesize\": 12,\n    \"axes.labelsize\": 10\n})\n\nfig, ax = plt.subplots(figsize=(9.5, 4.8))\n\norder = np.argsort(weighted_pct)[::-1]\nlabels = [bt_cols[i] for i in order]\ny = weighted_pct[order]\nc = [colors[i] for i in order]\n\nbars = ax.barh(labels, y, color=c, edgecolor=(0, 0, 0, 0.15), linewidth=0.8)\nax.invert_yaxis()\n\n# Value labels\nfor b, v in zip(bars, y):\n    ax.text(b.get_width() + 0.25, b.get_y() + b.get_height()/2,\n            f\"{v:.1f}%\", va=\"center\", ha=\"left\", color=\"#222\")\n\nax.set_xlim(0, max(45, y.max() + 6))\nax.set_xlabel(\"Estimated share of world population (%) — population-weighted across listed countries\")\nax.set_title(\"Global blood type distribution (population-weighted from 7bloodtype.csv)\")\nax.grid(axis=\"x\", color=\"#000\", alpha=0.10, linewidth=0.8)\nax.set_axisbelow(True)\n\n# Subtle note about coverage\ncovered = df['Population'].sum()\nax.text(0.0, -0.16,\n        f\"Coverage: {len(df)} countries; total population in file ≈ {covered:,.0f}. \"\n        f\"Missing blood-type cells treated as 0 for weighting.\",\n        transform=ax.transAxes, ha=\"left\", va=\"top\", fontsize=8.5, color=\"#444\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot uses 'ax.barh()' directly to create a horizontal bar visualization, which classifies the library as matplotlib and the chart type as a Bar chart according to the horizontal orientation rule."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7bloodtype.csv\")\n\n# Blood type columns\nbt_cols = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']\n\n# Compute population-weighted global distribution (ignore NaNs per type)\npop = df['Population'].astype(float)\nweighted_counts = {}\nfor c in bt_cols:\n    pct = df[c].astype(float)\n    valid = pct.notna() & pop.notna()\n    # convert % to fraction and multiply by population to get people count\n    weighted_counts[c] = (pop[valid] * (pct[valid] / 100.0)).sum()\n\ntotal_people = sum(weighted_counts.values())\nshares = pd.Series({k: v / total_people * 100 for k, v in weighted_counts.items()}).loc[bt_cols]\n\n# Plot: one chart (horizontal bar)\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9.5, 5.2), dpi=140)\n\n# Color encode Rh factor\ncolors = ['#2563eb' if t.endswith('+') else '#f97316' for t in shares.index]\nbars = ax.barh(shares.index, shares.values, color=colors, edgecolor=\"white\", linewidth=1.0)\n\nax.set_title(\"Population-weighted Blood Type Distribution (Countries in 7bloodtype.csv)\", pad=10, weight=\"bold\")\nax.set_xlabel(\"Share of population (%)\")\nax.set_ylabel(\"Blood type\")\n\nax.set_xlim(0, max(10, shares.max() * 1.18))\n\n# Labels\nfor b, v in zip(bars, shares.values):\n    ax.text(b.get_width() + 0.15, b.get_y() + b.get_height()/2,\n            f\"{v:.2f}%\", va=\"center\", ha=\"left\", fontsize=9)\n\n# Legend (manual)\nfrom matplotlib.patches import Patch\nlegend_handles = [\n    Patch(facecolor='#2563eb', edgecolor='white', label='Rh+'),\n    Patch(facecolor='#f97316', edgecolor='white', label='Rh-')\n]\nax.legend(handles=legend_handles, loc=\"lower right\", frameon=True, title=\"Rh factor\")\n\n# Footnote\nax.text(0.0, -0.14,\n        \"Computed by summing Population × (type %) across countries; missing values excluded per type.\",\n        transform=ax.transAxes, fontsize=8, color=\"#4b5563\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses 'ax.barh()' to render the data directly, which identifies the library as 'matplotlib' per the hierarchy rules. Since the bars are horizontal, it is classified as a 'Bar chart' rather than a column chart. Manual hex colors were provided for the bars, so no named color palette is identified."}}
{"input_csv_file": "7bloodtype.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# -----------------------------\n# Load data\n# -----------------------------\ncsv_path = \"7bloodtype.csv\"\ndf = pd.read_csv(csv_path)\n\nblood_cols = [\"O+\", \"A+\", \"B+\", \"AB+\", \"O-\", \"A-\", \"B-\", \"AB-\"]\n\n# Ensure numeric (handles NaN like Egypt negatives)\ndf[blood_cols] = df[blood_cols].apply(pd.to_numeric, errors=\"coerce\")\n\n# Compute population-weighted prevalence by blood type (global estimate across listed countries)\npop = df[\"Population\"].astype(float)\nweighted = (df[blood_cols].multiply(pop, axis=0)).sum(axis=0) / pop.sum()\n\n# Order by prevalence for clearer ranking\nweighted = weighted.sort_values(ascending=True)\n\n# -----------------------------\n# Plot: single chart\n# -----------------------------\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\npalette = sns.color_palette(\"viridis\", n_colors=len(weighted))\nax.barh(weighted.index, weighted.values, color=palette)\n\nax.set_title(\"Population-weighted blood type distribution (across countries in 7bloodtype.csv)\")\nax.set_xlabel(\"Share of population (%)\")\nax.set_ylabel(\"Blood type\")\nax.set_xlim(0, max(60, weighted.max() * 1.15))\n\nfor i, (label, val) in enumerate(zip(weighted.index, weighted.values)):\n    ax.text(val + 0.6, i, f\"{val:.2f}%\", va=\"center\", ha=\"left\", fontsize=9)\n\nsns.despine(left=False, bottom=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "viridis", "reasoning": "The data is rendered using the matplotlib ax.barh() method. While seaborn is used for styling and creating the color palette, the core rendering function is matplotlib. Because the bars are oriented horizontally, it is classified as a Bar chart rather than a Column chart."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"7food.csv\")\n\n# Clean up potential index column\nif \"Unnamed: 0\" in df.columns:\n    df = df.drop(columns=[\"Unnamed: 0\"])\n\n# Ensure numeric columns are numeric\nfor col in [\"Caloric Value\", \"Nutrition Density\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Select top foods by Nutrition Density for a readable single chart\nplot_df = (\n    df.dropna(subset=[\"food\", \"Nutrition Density\", \"Caloric Value\"])\n      .sort_values(\"Nutrition Density\", ascending=False)\n      .head(15)\n      .copy()\n)\n\n# Plot: Nutrition Density vs Caloric Value (single chart)\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6.5))\n\nsns.scatterplot(\n    data=plot_df,\n    x=\"Caloric Value\",\n    y=\"Nutrition Density\",\n    s=120,\n    ax=ax\n)\n\n# Annotate points with food names\nfor _, r in plot_df.iterrows():\n    ax.annotate(\n        r[\"food\"],\n        (r[\"Caloric Value\"], r[\"Nutrition Density\"]),\n        textcoords=\"offset points\",\n        xytext=(6, 6),\n        ha=\"left\",\n        fontsize=9\n    )\n\nax.set_title(\"Top 15 Foods by Nutrition Density: Nutrition Density vs Calories\")\nax.set_xlabel(\"Caloric Value\")\nax.set_ylabel(\"Nutrition Density\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is plotted using 'sns.scatterplot', which identifies the library as seaborn according to the hierarchy rules. The chart visualizes two quantitative dimensions ('Caloric Value' and 'Nutrition Density'), which corresponds to the 'Scatterplot' definition in the taxonomy."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7food.csv\")\n\n# Clean up possible index column\nif \"Unnamed: 0\" in df.columns:\n    df = df.drop(columns=[\"Unnamed: 0\"])\n\n# Make sure needed columns exist\nneeded = {\"food\", \"Caloric Value\"}\nmissing = needed - set(df.columns)\nif missing:\n    raise ValueError(f\"Missing required columns: {missing}\")\n\n# Prepare data (top 10 highest calories)\nplot_df = (\n    df[[\"food\", \"Caloric Value\"]]\n    .dropna()\n    .sort_values(\"Caloric Value\", ascending=False)\n    .head(10)\n    .sort_values(\"Caloric Value\", ascending=True)\n)\n\n# Plot (single chart)\nplt.figure(figsize=(10, 6))\nplt.barh(plot_df[\"food\"], plot_df[\"Caloric Value\"], color=\"#4C78A8\")\nplt.title(\"Top 10 Foods by Caloric Value\")\nplt.xlabel(\"Caloric Value\")\nplt.ylabel(\"Food\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses plt.barh() directly to render the data, which falls under the matplotlib library classification. Since the bars are horizontal, it is classified as a Bar chart according to the taxonomy."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7food.csv\")\n\n# Clean up possible index column\nif \"Unnamed: 0\" in df.columns:\n    df = df.drop(columns=[\"Unnamed: 0\"])\n\n# Ensure numeric columns are numeric (safe conversion)\nfor col in [\"Caloric Value\", \"Nutrition Density\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Keep only valid rows for the chart\nplot_df = df.dropna(subset=[\"food\", \"Caloric Value\", \"Nutrition Density\"]).copy()\n\n# Sort by Nutrition Density and take top 10 for readability\nplot_df = plot_df.sort_values(\"Nutrition Density\", ascending=False).head(10)\n\n# Single chart: Top 10 foods by Nutrition Density (colored by calories)\nplt.figure(figsize=(10, 6))\ncolors = plot_df[\"Caloric Value\"]\nbars = plt.barh(plot_df[\"food\"], plot_df[\"Nutrition Density\"], color=plt.cm.Blues(colors / colors.max()))\nplt.gca().invert_yaxis()\n\nplt.title(\"Top 10 Foods by Nutrition Density (color shows calories)\")\nplt.xlabel(\"Nutrition Density\")\nplt.ylabel(\"Food\")\n\n# Add a colorbar for calories\nsm = plt.cm.ScalarMappable(cmap=\"Blues\", norm=plt.Normalize(vmin=colors.min(), vmax=colors.max()))\nsm.set_array([])\ncbar = plt.colorbar(sm)\ncbar.set_label(\"Caloric Value\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "Blues", "reasoning": "The visualization uses plt.barh() from matplotlib to create horizontal bars, which corresponds to the 'Bar chart' definition in the taxonomy. Even though pandas is used for data manipulation, the rendering is performed directly by pyplot functions."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7food.csv\")\n\n# Clean up: drop the extra index-like column if present\nif \"Unnamed: 0\" in df.columns:\n    df = df.drop(columns=[\"Unnamed: 0\"])\n\n# Make a simple chart: Top 10 foods by Nutrition Density\ntop = df.sort_values(\"Nutrition Density\", ascending=False).head(10)\n\nplt.figure(figsize=(10, 5))\nplt.barh(top[\"food\"], top[\"Nutrition Density\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()  # highest at top\n\nplt.title(\"Top 10 Foods by Nutrition Density (from 7food.csv)\")\nplt.xlabel(\"Nutrition Density\")\nplt.ylabel(\"Food\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses plt.barh() from the matplotlib.pyplot library to create the visualization. According to the taxonomy, horizontal bars are classified as a 'Bar chart'."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"7food.csv\")\n\n    # Clean up any stray index-like column\n    if \"Unnamed: 0\" in df.columns:\n        df = df.drop(columns=[\"Unnamed: 0\"])\n\n    # Build a single chart: Calories vs Nutrition Density, labeled by food\n    df = df[[\"food\", \"Caloric Value\", \"Nutrition Density\"]].dropna()\n    df = df.sort_values(\"Nutrition Density\", ascending=False)\n\n    fig, ax = plt.subplots(figsize=(11, 7))\n    ax.scatter(df[\"Caloric Value\"], df[\"Nutrition Density\"], s=80, alpha=0.85)\n\n    for _, r in df.iterrows():\n        ax.annotate(\n            r[\"food\"],\n            (r[\"Caloric Value\"], r[\"Nutrition Density\"]),\n            textcoords=\"offset points\",\n            xytext=(6, 4),\n            ha=\"left\",\n            fontsize=8,\n        )\n\n    ax.set_title(\"Cheeses: Nutrition Density vs Caloric Value (per serving/unit in dataset)\")\n    ax.set_xlabel(\"Caloric Value\")\n    ax.set_ylabel(\"Nutrition Density\")\n    ax.grid(True, linestyle=\"--\", alpha=0.35)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses `ax.scatter()` directly to plot the data, which identifies the library as matplotlib. The visualization maps two quantitative variables ('Caloric Value' and 'Nutrition Density') to the X and Y axes, fitting the definition of a Scatterplot."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"7food.csv\")\n\n    # Clean up possible index column\n    if \"Unnamed: 0\" in df.columns:\n        df = df.drop(columns=[\"Unnamed: 0\"])\n\n    # Ensure numeric columns are numeric\n    for col in [\"Caloric Value\", \"Nutrition Density\"]:\n        df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n    plot_df = df.dropna(subset=[\"food\", \"Caloric Value\", \"Nutrition Density\"]).copy()\n    plot_df = plot_df.sort_values(\"Nutrition Density\", ascending=False)\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n    sc = ax.scatter(\n        plot_df[\"Caloric Value\"],\n        plot_df[\"Nutrition Density\"],\n        s=90,\n        alpha=0.85,\n        edgecolors=\"white\",\n        linewidths=0.7,\n    )\n\n    # Label a few top nutrition density foods (to avoid clutter)\n    top_n = min(6, len(plot_df))\n    for _, r in plot_df.head(top_n).iterrows():\n        ax.annotate(\n            r[\"food\"],\n            (r[\"Caloric Value\"], r[\"Nutrition Density\"]),\n            textcoords=\"offset points\",\n            xytext=(6, 6),\n            fontsize=9,\n        )\n\n    ax.set_title(\"Caloric Value vs Nutrition Density (7food.csv)\")\n    ax.set_xlabel(\"Caloric Value\")\n    ax.set_ylabel(\"Nutrition Density\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses ax.scatter() directly from the matplotlib axes object to render the data. The plot maps two quantitative variables ('Caloric Value' and 'Nutrition Density') to the X and Y axes without using a third variable to modulate the size of the points, fitting the definition of a Scatterplot."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    csv_path = \"7food.csv\"\n    df = pd.read_csv(csv_path)\n\n    # Clean up index column if present\n    if \"Unnamed: 0\" in df.columns:\n        df = df.drop(columns=[\"Unnamed: 0\"])\n\n    # Ensure numeric columns are numeric\n    df[\"Caloric Value\"] = pd.to_numeric(df[\"Caloric Value\"], errors=\"coerce\")\n    df[\"Nutrition Density\"] = pd.to_numeric(df[\"Nutrition Density\"], errors=\"coerce\")\n\n    plot_df = df.dropna(subset=[\"food\", \"Caloric Value\", \"Nutrition Density\"]).copy()\n    plot_df = plot_df.sort_values(\"Nutrition Density\", ascending=False)\n\n    # Single chart: scatter plot of Caloric Value vs Nutrition Density\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.scatter(plot_df[\"Caloric Value\"], plot_df[\"Nutrition Density\"], alpha=0.85)\n\n    # Annotate each point with the food name\n    for _, r in plot_df.iterrows():\n        ax.annotate(\n            r[\"food\"],\n            (r[\"Caloric Value\"], r[\"Nutrition Density\"]),\n            textcoords=\"offset points\",\n            xytext=(6, 4),\n            fontsize=8,\n            alpha=0.9,\n        )\n\n    ax.set_title(\"Caloric Value vs Nutrition Density (7food.csv)\")\n    ax.set_xlabel(\"Caloric Value\")\n    ax.set_ylabel(\"Nutrition Density\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data rendering is performed using the 'ax.scatter()' method, which belongs to the matplotlib library. The plot visualizes the relationship between two quantitative variables ('Caloric Value' and 'Nutrition Density'), which corresponds to the Scatterplot definition."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"7food.csv\")\n\n    if \"Unnamed: 0\" in df.columns:\n        df = df.drop(columns=[\"Unnamed: 0\"])\n\n    # Scatter: calories vs nutrition density (single chart)\n    x = df[\"Caloric Value\"]\n    y = df[\"Nutrition Density\"]\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.scatter(x, y, s=70, alpha=0.85)\n\n    # Label points with food names\n    for _, row in df.iterrows():\n        ax.annotate(\n            row[\"food\"],\n            (row[\"Caloric Value\"], row[\"Nutrition Density\"]),\n            xytext=(6, 4),\n            textcoords=\"offset points\",\n            fontsize=8,\n            alpha=0.9\n        )\n\n    ax.set_title(\"Calories vs Nutrition Density (7food.csv)\")\n    ax.set_xlabel(\"Caloric Value\")\n    ax.set_ylabel(\"Nutrition Density\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The plot is created using the standard matplotlib axes function `ax.scatter()` to plot two quantitative variables (Caloric Value and Nutrition Density)."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7food.csv\")\n\n# Clean/standardize columns\nif \"Unnamed: 0\" in df.columns:\n    df = df.drop(columns=[\"Unnamed: 0\"])\n\nrequired = {\"food\", \"Caloric Value\", \"Nutrition Density\"}\nmissing = required - set(df.columns)\nif missing:\n    raise ValueError(f\"Missing required columns: {missing}\")\n\n# Ensure numeric types\ndf[\"Caloric Value\"] = pd.to_numeric(df[\"Caloric Value\"], errors=\"coerce\")\ndf[\"Nutrition Density\"] = pd.to_numeric(df[\"Nutrition Density\"], errors=\"coerce\")\ndf = df.dropna(subset=[\"food\", \"Caloric Value\", \"Nutrition Density\"])\n\n# Plot: Calories vs Nutrition Density (single chart)\nplt.figure(figsize=(10, 6))\nplt.scatter(df[\"Caloric Value\"], df[\"Nutrition Density\"], alpha=0.85)\n\nfor _, r in df.iterrows():\n    plt.annotate(\n        str(r[\"food\"]),\n        (r[\"Caloric Value\"], r[\"Nutrition Density\"]),\n        textcoords=\"offset points\",\n        xytext=(6, 4),\n        fontsize=8\n    )\n\nplt.title(\"Caloric Value vs Nutrition Density (7food.csv)\")\nplt.xlabel(\"Caloric Value\")\nplt.ylabel(\"Nutrition Density\")\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered directly using matplotlib's plt.scatter() function to visualize the relationship between two quantitative variables (Caloric Value and Nutrition Density)."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import Normalize\n\n# Load data\ndf = pd.read_csv(\"7food.csv\")\n\n# Basic cleanup\nif \"Unnamed: 0\" in df.columns:\n    df = df.drop(columns=[\"Unnamed: 0\"])\ndf[\"food\"] = df[\"food\"].astype(str)\n\n# Ensure numeric columns\nfor c in [\"Caloric Value\", \"Protein\", \"Fat\", \"Carbohydrates\", \"Nutrition Density\"]:\n    df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n# Keep rows with needed fields\nplot_df = df.dropna(subset=[\"food\", \"Caloric Value\", \"Protein\", \"Nutrition Density\"]).copy()\n\n# Build a single chart: scatter of calories vs protein, colored by nutrition density, sized by fat\nx = plot_df[\"Caloric Value\"]\ny = plot_df[\"Protein\"]\nc = plot_df[\"Nutrition Density\"]\ns = (pd.to_numeric(plot_df[\"Fat\"], errors=\"coerce\").fillna(0).clip(lower=0) * 18) + 40  # size scaling\n\nnorm = Normalize(vmin=c.min(), vmax=c.max())\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 7))\n\nsc = ax.scatter(\n    x, y,\n    c=c, cmap=\"viridis\", norm=norm,\n    s=s, alpha=0.85,\n    edgecolor=\"white\", linewidth=0.8\n)\n\n# Label a few standout points (top nutrition density)\ntopn = plot_df.nlargest(6, \"Nutrition Density\")\nfor _, r in topn.iterrows():\n    ax.annotate(\n        r[\"food\"],\n        (r[\"Caloric Value\"], r[\"Protein\"]),\n        xytext=(6, 6),\n        textcoords=\"offset points\",\n        fontsize=9,\n        ha=\"left\",\n        va=\"bottom\"\n    )\n\nax.set_title(\"Calories vs Protein (Color = Nutrition Density, Size = Fat)\", pad=12, fontsize=14, weight=\"bold\")\nax.set_xlabel(\"Caloric Value\")\nax.set_ylabel(\"Protein\")\n\ncbar = fig.colorbar(sc, ax=ax, pad=0.02)\ncbar.set_label(\"Nutrition Density\")\n\n# Tidy axes limits with small padding\nax.set_xlim(x.min() - (x.max() - x.min()) * 0.03, x.max() + (x.max() - x.min()) * 0.03)\nax.set_ylim(max(0, y.min() - (y.max() - y.min()) * 0.05), y.max() + (y.max() - y.min()) * 0.08)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "viridis", "reasoning": "The plot uses ax.scatter() from matplotlib to visualize two quantitative variables on the axes, with a third quantitative variable mapped to color (cmap='viridis') and a fourth mapped to point size (s=s), which defines a bubble chart."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7food.csv\")\n\n# Clean column name if needed and ensure numeric\nif \"Nutrition Density\" not in df.columns:\n    raise ValueError(\"Expected column 'Nutrition Density' not found in 7food.csv\")\n\ndf[\"Nutrition Density\"] = pd.to_numeric(df[\"Nutrition Density\"], errors=\"coerce\")\ndf[\"Caloric Value\"] = pd.to_numeric(df[\"Caloric Value\"], errors=\"coerce\")\ndf[\"food\"] = df[\"food\"].astype(str)\n\n# Keep valid rows\nd = df.dropna(subset=[\"food\", \"Caloric Value\", \"Nutrition Density\"]).copy()\nd = d[d[\"Caloric Value\"] > 0]\n\n# Color mapping (robust to outliers): log-density scaled 5–95th percentile\ndens = d[\"Nutrition Density\"].to_numpy()\nld = np.log10(np.clip(dens, a_min=np.nanmin(dens[dens > 0]), a_max=None))\nvmin, vmax = np.nanpercentile(ld, [5, 95])\nld_scaled = np.clip((ld - vmin) / (vmax - vmin + 1e-12), 0, 1)\n\n# Figure\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 7.5))\n\nsc = ax.scatter(\n    d[\"Caloric Value\"],\n    d[\"Protein\"],\n    c=ld_scaled,\n    cmap=\"viridis\",\n    s=85,\n    alpha=0.9,\n    edgecolor=\"white\",\n    linewidth=0.6,\n)\n\n# Label: top 6 by density + 3 highest calories, dedup\ntop_density = d.nlargest(6, \"Nutrition Density\").index.tolist()\ntop_cal = d.nlargest(3, \"Caloric Value\").index.tolist()\nlabel_idx = list(dict.fromkeys(top_density + top_cal))\n\n# Simple deterministic offset pattern to reduce overlaps\noffsets = [(8, 8), (8, -10), (-10, 8), (-10, -10), (12, 0), (0, 12), (-14, 0), (0, -14)]\nfor k, i in enumerate(label_idx):\n    dx, dy = offsets[k % len(offsets)]\n    ax.annotate(\n        d.loc[i, \"food\"],\n        (d.loc[i, \"Caloric Value\"], d.loc[i, \"Protein\"]),\n        textcoords=\"offset points\",\n        xytext=(dx, dy),\n        ha=\"left\" if dx >= 0 else \"right\",\n        va=\"bottom\" if dy >= 0 else \"top\",\n        fontsize=9,\n        color=\"#1f1f1f\",\n        bbox=dict(boxstyle=\"round,pad=0.25\", fc=\"white\", ec=\"none\", alpha=0.75),\n    )\n\n# Axes & title\nax.set_title(\"Cheeses: Protein vs Calories (Color = Nutrition Density)\", fontsize=15, pad=12)\nax.set_xlabel(\"Caloric Value\", fontsize=12)\nax.set_ylabel(\"Protein\", fontsize=12)\n\n# Colorbar (still part of single chart)\ncbar = fig.colorbar(sc, ax=ax, pad=0.02)\ncbar.set_label(\"Nutrition Density (log-scaled, percentile-clipped)\", fontsize=11)\n\n# Nice bounds\nx = d[\"Caloric Value\"].to_numpy()\ny = d[\"Protein\"].to_numpy()\nax.set_xlim(max(0, np.nanmin(x) * 0.9), np.nanmax(x) * 1.08)\nax.set_ylim(max(0, np.nanmin(y) * 0.9), np.nanmax(y) * 1.12)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "viridis", "reasoning": "The data is rendered using the ax.scatter() function from the matplotlib library. It maps two quantitative variables (Caloric Value and Protein) to spatial coordinates, which defines a scatterplot."}}
{"input_csv_file": "7food.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7food.csv\")\n\n# Clean/prepare\ndf = df.drop(columns=[c for c in [\"Unnamed: 0\"] if c in df.columns]).copy()\ndf[\"food\"] = df[\"food\"].astype(str)\n\n# Focus on a single, insight-rich comparison:\n# Nutrient Density vs Caloric Value, sized by Protein, colored by Fat\nplot_df = df[[\"food\", \"Nutrition Density\", \"Caloric Value\", \"Protein\", \"Fat\"]].dropna()\n\nx = plot_df[\"Caloric Value\"]\ny = plot_df[\"Nutrition Density\"]\nsizes = (plot_df[\"Protein\"].clip(lower=0) + 0.1) ** 1.6 * 80  # emphasize protein differences\ncolors = plot_df[\"Fat\"].clip(lower=0)\n\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 7))\n\nsc = ax.scatter(\n    x, y,\n    s=sizes,\n    c=colors,\n    cmap=\"viridis\",\n    alpha=0.85,\n    edgecolor=\"white\",\n    linewidth=0.8\n)\n\n# Annotate a few notable points (top nutrient density + extremes)\ntop_nd = plot_df.nlargest(4, \"Nutrition Density\").index.tolist()\nlow_cal = plot_df.nsmallest(2, \"Caloric Value\").index.tolist()\nhigh_cal = plot_df.nlargest(2, \"Caloric Value\").index.tolist()\nto_label = sorted(set(top_nd + low_cal + high_cal))\n\nfor i in to_label:\n    ax.annotate(\n        plot_df.loc[i, \"food\"],\n        (plot_df.loc[i, \"Caloric Value\"], plot_df.loc[i, \"Nutrition Density\"]),\n        textcoords=\"offset points\",\n        xytext=(6, 6),\n        ha=\"left\",\n        fontsize=9,\n        bbox=dict(boxstyle=\"round,pad=0.2\", fc=\"white\", ec=\"none\", alpha=0.75)\n    )\n\ncbar = fig.colorbar(sc, ax=ax, pad=0.01)\ncbar.set_label(\"Fat (g)\", rotation=90)\n\nax.set_title(\"Cheeses: Nutrition Density vs Calories (Bubble size = Protein, Color = Fat)\")\nax.set_xlabel(\"Caloric Value\")\nax.set_ylabel(\"Nutrition Density\")\n\n# Improve margins\nax.margins(x=0.05, y=0.08)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "viridis", "reasoning": "The data is rendered using the matplotlib function ax.scatter() where two quantitative dimensions are mapped to axes and a third quantitative dimension (Protein) is mapped to the 's' (size) parameter, which fits the taxonomy definition for a Bubble chart."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\ndef dollars(x, pos):\n    return f\"${x:,.0f}\"\n\ndef main():\n    # Load data\n    df = pd.read_csv(\"7livingcost.csv\")\n\n    # Focus on a single family type present across many counties\n    family_type = \"2p0c\"\n    d = df[df[\"family_member_count\"] == family_type].copy()\n\n    if d.empty:\n        raise ValueError(f\"No rows found for family_member_count == {family_type}\")\n\n    # Create a clean label for plotting\n    d[\"label\"] = d[\"county\"].astype(str) + \", \" + d[\"state\"].astype(str)\n\n    # Compute affordability ratio: total living cost / median family income\n    d[\"cost_to_income_pct\"] = (d[\"total_cost\"] / d[\"median_family_income\"]) * 100\n\n    # Sort for readability\n    d = d.sort_values(\"cost_to_income_pct\", ascending=False)\n\n    # Plot: affordability ratio by county (single chart)\n    fig, ax = plt.subplots(figsize=(12, 10))\n    ax.barh(d[\"label\"], d[\"cost_to_income_pct\"], color=\"#2a6fbb\")\n    ax.invert_yaxis()\n\n    ax.set_title(f\"Living Cost as % of Median Family Income by County ({family_type})\")\n    ax.set_xlabel(\"Total Living Cost / Median Family Income (%)\")\n    ax.set_ylabel(\"County\")\n\n    # Add a reference line at 100% (cost equals income)\n    ax.axvline(100, color=\"black\", linewidth=1, linestyle=\"--\", alpha=0.7)\n\n    # Annotate bars with % values\n    for y, v in enumerate(d[\"cost_to_income_pct\"].tolist()):\n        ax.text(v + 0.5, y, f\"{v:.1f}%\", va=\"center\", fontsize=9)\n\n    ax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"{x:.0f}%\"))\n    ax.grid(axis=\"x\", linestyle=\":\", alpha=0.4)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib axes function ax.barh() to render the data directly. Since the bars are horizontal, it is classified as a 'Bar chart' per the provided taxonomy."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"7livingcost.csv\")\n\n# Focus on a single, clear comparison: total_cost vs median_family_income (by family type)\norder = ['1p0c', '1p1c', '1p2c', '1p3c', '1p4c', '2p0c', '2p1c', '2p2c', '2p3c', '2p4c']\ndf[\"family_member_count\"] = pd.Categorical(df[\"family_member_count\"], categories=order, ordered=True)\n\nsummary = (\n    df.groupby(\"family_member_count\", observed=True)\n      .agg(avg_total_cost=(\"total_cost\", \"mean\"),\n           avg_median_income=(\"median_family_income\", \"mean\"))\n      .reset_index()\n      .dropna(subset=[\"family_member_count\"])\n)\n\n# Plot (single chart)\nfig, ax = plt.subplots(figsize=(10, 5))\n\nax.plot(summary[\"family_member_count\"], summary[\"avg_total_cost\"], marker=\"o\", linewidth=2, label=\"Average total cost\")\nax.plot(summary[\"family_member_count\"], summary[\"avg_median_income\"], marker=\"o\", linewidth=2, label=\"Average median family income\")\n\nax.set_title(\"Average Total Living Cost vs. Median Family Income (by Family Type)\")\nax.set_xlabel(\"Family type (adults/children)\")\nax.set_ylabel(\"Dollars per year\")\nax.grid(True, axis=\"y\", linestyle=\"--\", alpha=0.4)\nax.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Line chart", "color_palette": null, "reasoning": "The data is rendered using ax.plot() which is a standard matplotlib axes function. The visualization is a Line chart as it connects categorical family types to quantitative income/cost values using markers and lines."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"7livingcost.csv\")\n\n# Keep rows where both values exist\ndf = df.dropna(subset=[\"total_cost\", \"median_family_income\"])\n\n# Create the chart: Total cost vs Median family income\nplt.figure(figsize=(9, 6))\nplt.scatter(df[\"median_family_income\"], df[\"total_cost\"], alpha=0.8)\n\n# Add a simple reference line y = x (cost equals income)\nmin_v = min(df[\"median_family_income\"].min(), df[\"total_cost\"].min())\nmax_v = max(df[\"median_family_income\"].max(), df[\"total_cost\"].max())\nplt.plot([min_v, max_v], [min_v, max_v], linestyle=\"--\", linewidth=1, color=\"gray\")\n\n# Formatting\nmoney = FuncFormatter(lambda x, pos: f\"${x:,.0f}\")\nax = plt.gca()\nax.xaxis.set_major_formatter(money)\nax.yaxis.set_major_formatter(money)\n\nplt.title(\"Living Cost vs. Median Family Income (by county/family type)\")\nplt.xlabel(\"Median family income\")\nplt.ylabel(\"Total annual living cost\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using the plt.scatter() function to plot two quantitative variables (median family income and total annual cost). Following the priority rules, since it uses direct pyplot functions rather than sns.scatterplot or df.plot(), the library is classified as matplotlib."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\nCSV_PATH = \"7livingcost.csv\"\n\ndef main():\n    df = pd.read_csv(CSV_PATH)\n\n    # Focus on a single family type so comparisons are simple.\n    fam = \"2p0c\"  # two parents, zero children\n    d = df[df[\"family_member_count\"] == fam].copy()\n\n    # Compute affordability (share of income spent on total cost)\n    d[\"cost_share\"] = d[\"total_cost\"] / d[\"median_family_income\"]\n\n    # Order by highest cost share and take top 15 to keep the chart readable\n    d = d.sort_values(\"cost_share\", ascending=False).head(15)\n\n    # Label as \"County, ST\"\n    d[\"label\"] = d[\"county\"].astype(str) + \", \" + d[\"state\"].astype(str)\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.barh(d[\"label\"], d[\"cost_share\"], color=\"#4C78A8\")\n    ax.invert_yaxis()\n\n    ax.xaxis.set_major_formatter(mtick.PercentFormatter(1.0))\n    ax.set_xlabel(\"Total living cost as % of median family income\")\n    ax.set_ylabel(\"\")\n    ax.set_title(f\"Affordability by County (Family type: {fam})\")\n\n    # Reference line at 100% (cost equals income)\n    ax.axvline(1.0, color=\"black\", linewidth=1, linestyle=\"--\")\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "#4C78A8", "reasoning": "The visualization is created using the `ax.barh()` method from the matplotlib library. Following the provided taxonomy, horizontal bars are classified as a 'Bar chart' (whereas vertical bars would be a 'Column chart')."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"7livingcost.csv\")\n\n    # Compare living costs vs income for a consistent family type (1 parent, 2 children)\n    family_type = \"1p2c\"\n    dff = df[df[\"family_member_count\"] == family_type].copy()\n\n    # If the file has unexpected values, fall back to the most common family type\n    if dff.empty:\n        family_type = df[\"family_member_count\"].mode(dropna=True).iloc[0]\n        dff = df[df[\"family_member_count\"] == family_type].copy()\n\n    dff[\"income_minus_cost\"] = dff[\"median_family_income\"] - dff[\"total_cost\"]\n    dff.sort_values(\"income_minus_cost\", inplace=True)\n\n    # Single chart: horizontal bar of income minus living cost by county\n    labels = dff[\"county\"].astype(str) + \", \" + dff[\"state\"].astype(str)\n    colors = dff[\"income_minus_cost\"].apply(lambda x: \"#2ca02c\" if x >= 0 else \"#d62728\")\n\n    fig, ax = plt.subplots(figsize=(11, 8))\n    ax.barh(labels, dff[\"income_minus_cost\"], color=colors, edgecolor=\"none\")\n    ax.axvline(0, color=\"black\", linewidth=1)\n\n    ax.set_title(f\"Median Family Income Minus Living Cost by County ({family_type})\")\n    ax.set_xlabel(\"Income - Total Living Cost (USD, annual)\")\n    ax.set_ylabel(\"County\")\n\n    # Format x-axis ticks with thousands separators\n    ax.xaxis.set_major_formatter(lambda x, pos: f\"${x:,.0f}\")\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the matplotlib library's `ax.barh()` function directly to render data. According to the taxonomy, horizontal bars representing a categorical variable and a quantitative variable are classified as a 'Bar chart'."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"7livingcost.csv\")\n\n    # Focus on a single family type for a clean comparison across counties\n    target_family = \"1p2c\"\n    dff = df[df[\"family_member_count\"] == target_family].copy()\n\n    # Compute affordability ratio (higher = less affordable)\n    dff[\"cost_to_income_ratio\"] = dff[\"total_cost\"] / dff[\"median_family_income\"]\n\n    # Sort and take top 15 least affordable areas\n    top = dff.sort_values(\"cost_to_income_ratio\", ascending=False).head(15)\n\n    plt.figure(figsize=(12, 7))\n    plt.barh(\n        top[\"county\"].astype(str),\n        top[\"cost_to_income_ratio\"],\n        color=\"#4C78A8\"\n    )\n    plt.gca().invert_yaxis()\n    plt.xlabel(\"Total Cost / Median Family Income (ratio)\")\n    plt.title(f\"Least Affordable Counties (Family: {target_family})\")\n    plt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is created using plt.barh(), which is a standard matplotlib function for drawing data. Because plt.barh() renders bars horizontally, it is classified as a 'Bar chart' according to the taxonomy."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"7livingcost.csv\")\n\n    # Income-to-cost stress ratio (1.0 = income equals total cost)\n    df[\"cost_to_income\"] = df[\"total_cost\"] / df[\"median_family_income\"]\n\n    # Keep a comparable household type across areas\n    target_family = \"1p2c\"\n    dff = df[df[\"family_member_count\"] == target_family].copy()\n\n    # Sort by stress ratio\n    dff = dff.sort_values(\"cost_to_income\", ascending=False)\n\n    # Build readable labels\n    dff[\"label\"] = dff[\"county\"].astype(str).str.replace(\" County\", \"\", regex=False) + \", \" + dff[\"state\"].astype(str)\n\n    colors = dff[\"isMetro\"].map({True: \"#1f77b4\", False: \"#ff7f0e\"}).values\n\n    plt.figure(figsize=(14, 7))\n    plt.bar(dff[\"label\"], dff[\"cost_to_income\"], color=colors)\n    plt.axhline(1.0, color=\"black\", linewidth=1, linestyle=\"--\", label=\"Income = Total Cost (1.0)\")\n\n    plt.title(f\"Living Cost Stress (Total Cost / Median Family Income) by County — {target_family}\")\n    plt.ylabel(\"Total Cost / Median Family Income\")\n    plt.xlabel(\"County, State\")\n    plt.xticks(rotation=60, ha=\"right\")\n    from matplotlib.patches import Patch\n    plt.legend(handles=[Patch(color=\"#1f77b4\", label=\"Metro\"), Patch(color=\"#ff7f0e\", label=\"Non-metro\"), plt.Line2D([0],[0], color=\"black\", linestyle=\"--\", label=\"1.0\")])\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses plt.bar() to render the data, which creates vertical bars. According to the taxonomy, vertical bars represent a Column chart, and the use of the pyplot function directly identifies the library as matplotlib. The colors are manually assigned via hex codes rather than a named palette."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"7livingcost.csv\")\n\n    # Scatter: total living cost vs median family income, colored by metro/non-metro\n    metro_map = {True: \"Metro\", False: \"Non-metro\"}\n    df[\"metro_label\"] = df[\"isMetro\"].map(metro_map)\n\n    plt.figure(figsize=(10, 6))\n\n    for label, grp in df.groupby(\"metro_label\"):\n        plt.scatter(\n            grp[\"median_family_income\"],\n            grp[\"total_cost\"],\n            s=55,\n            alpha=0.8,\n            edgecolors=\"white\",\n            linewidths=0.7,\n            label=label,\n        )\n\n    # 45-degree reference line (income = total cost)\n    min_val = min(df[\"median_family_income\"].min(), df[\"total_cost\"].min())\n    max_val = max(df[\"median_family_income\"].max(), df[\"total_cost\"].max())\n    plt.plot([min_val, max_val], [min_val, max_val], linestyle=\"--\", linewidth=1.5, color=\"gray\", label=\"Income = Total Cost\")\n\n    plt.title(\"Total Living Cost vs Median Family Income (7livingcost.csv)\")\n    plt.xlabel(\"Median Family Income (USD)\")\n    plt.ylabel(\"Total Living Cost (USD)\")\n    plt.grid(True, linestyle=\":\", linewidth=0.8, alpha=0.6)\n    plt.legend(frameon=False)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses plt.scatter() directly to render the data points, which identifies the library as matplotlib. The visualization maps two quantitative variables (median family income and total cost) to the X and Y axes, making it a scatterplot."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"7livingcost.csv\")\n\n# Convertir isMetro a etiqueta para el gráfico\ndf[\"metro_label\"] = df[\"isMetro\"].map({True: \"Metro\", False: \"No metro\"})\n\n# Nos enfocamos en una composición familiar común en el dataset\nsubset = df[df[\"family_member_count\"] == \"1p2c\"].copy()\n\n# Calcular el \"gap\" (ingreso mediano - costo total). Positivo = alcanza; negativo = no alcanza.\nsubset[\"income_minus_total_cost\"] = subset[\"median_family_income\"] - subset[\"total_cost\"]\n\n# Ordenar para una mejor lectura\nsubset = subset.sort_values(\"income_minus_total_cost\")\n\n# Preparar colores según Metro/No metro\ncolors = subset[\"metro_label\"].map({\"Metro\": \"#1f77b4\", \"No metro\": \"#ff7f0e\"}).to_list()\n\n# Gráfico (uno solo): barras horizontales del gap por condado/área\nplt.figure(figsize=(12, 9))\nplt.barh(subset[\"county\"], subset[\"income_minus_total_cost\"], color=colors)\nplt.axvline(0, color=\"black\", linewidth=1)\n\nplt.title(\"AL: Ingreso mediano familiar menos costo total anual (1p2c) por condado\\n(positivo=superávit, negativo=déficit)\")\nplt.xlabel(\"USD (median_family_income - total_cost)\")\nplt.ylabel(\"County\")\n\n# Leyenda manual\nfrom matplotlib.patches import Patch\nlegend_elems = [\n    Patch(facecolor=\"#1f77b4\", label=\"Metro\"),\n    Patch(facecolor=\"#ff7f0e\", label=\"No metro\"),\n]\nplt.legend(handles=legend_elems, title=\"Área\", loc=\"lower right\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot interface (plt.barh) to render data directly. Since plt.barh creates horizontal bars, it is classified as a Bar chart according to the taxonomy."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# --- Load data ---\ndf = pd.read_csv(\"7livingcost.csv\")\n\n# Ensure numeric types (robust to accidental string parsing)\nfor c in [\"total_cost\", \"median_family_income\"]:\n    df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n# Use a single family type for a clean, comparable view across counties\nfamily = \"2p0c\"  # 2 parents, 0 children\nd = df.loc[df[\"family_member_count\"] == family, [\"county\", \"areaname\", \"isMetro\", \"total_cost\", \"median_family_income\"]].dropna()\n\n# Compute affordability gap (positive => costs exceed income)\nd[\"gap\"] = d[\"total_cost\"] - d[\"median_family_income\"]\nd = d.sort_values(\"gap\", ascending=False)\n\n# Color by metro status\ncolors = d[\"isMetro\"].map({True: \"#1f77b4\", False: \"#ff7f0e\"}).values\n\n# --- Plot (single chart) ---\nfig, ax = plt.subplots(figsize=(12, 8))\nax.barh(d[\"county\"], d[\"gap\"], color=colors, edgecolor=\"none\")\nax.axvline(0, color=\"#444444\", linewidth=1)\n\nax.set_title(f\"Annual Cost–Income Gap by County (Family Type: {family})\", pad=12)\nax.set_xlabel(\"Total living cost − median family income (USD/year)\")\nax.set_ylabel(\"County\")\n\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"${x:,.0f}\"))\nax.grid(axis=\"x\", linestyle=\"--\", linewidth=0.7, alpha=0.35)\n\n# Legend\nfrom matplotlib.patches import Patch\nlegend_handles = [\n    Patch(facecolor=\"#1f77b4\", label=\"Metro\"),\n    Patch(facecolor=\"#ff7f0e\", label=\"Non-metro\"),\n]\nax.legend(handles=legend_handles, title=\"Area type\", loc=\"lower right\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is generated using ax.barh() which is a standard matplotlib function for horizontal bars. According to the taxonomy, horizontal bars representing a categorical and quantitative variable are classified as a 'Bar chart'."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import PercentFormatter\n\n# Load data\ndf = pd.read_csv(\"7livingcost.csv\")\n\n# Ensure expected columns exist\nrequired = {\"family_member_count\", \"total_cost\", \"median_family_income\", \"areaname\", \"county\"}\nmissing = required - set(df.columns)\nif missing:\n    raise ValueError(f\"Missing required columns: {missing}\")\n\n# Use a common, comparable household type across areas (present in this dataset)\nhh = \"2p0c\"  # two parents, zero children\nd = df[df[\"family_member_count\"].astype(str) == hh].copy()\nif d.empty:\n    raise ValueError(f\"No rows found for family_member_count == {hh}\")\n\n# Compute affordability ratio: annual living cost / median family income\nd[\"cost_to_income\"] = d[\"total_cost\"] / d[\"median_family_income\"]\n\n# Create a short label for plotting\nd[\"label\"] = d[\"county\"].astype(str).str.replace(r\"\\s+County$\", \"\", regex=True)\n\n# Sort by affordability (higher = more burdensome)\nd = d.sort_values(\"cost_to_income\", ascending=True)\n\n# Plot: horizontal bar chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 7))\n\nbars = ax.barh(d[\"label\"], d[\"cost_to_income\"], color=\"#2A6F97\")\n\n# Median line for context\nmedian_ratio = d[\"cost_to_income\"].median()\nax.axvline(median_ratio, color=\"#D1495B\", linewidth=2, linestyle=\"--\", label=f\"Median: {median_ratio:.0%}\")\n\n# Formatting\nax.xaxis.set_major_formatter(PercentFormatter(1.0))\nax.set_xlabel(\"Living cost as % of median family income (lower is better)\")\nax.set_ylabel(\"County (AL)\")\nax.set_title(f\"Affordability of Living Costs vs. Income by County (Household: {hh})\")\n\n# Annotate a few extremes (top/bottom 2) to keep it clean\nto_annotate = pd.concat([d.head(2), d.tail(2)]).drop_duplicates()\nfor y, (idx, row) in enumerate(d.iterrows()):\n    if idx in to_annotate.index:\n        ax.text(\n            row[\"cost_to_income\"] + 0.01,\n            y,\n            f\"{row['cost_to_income']:.0%}\",\n            va=\"center\",\n            ha=\"left\",\n            fontsize=9,\n            color=\"#1B263B\",\n        )\n\nax.set_xlim(0, max(1.0, d[\"cost_to_income\"].max() * 1.15))\nax.legend(loc=\"lower right\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses 'ax.barh()' to create horizontal bars directly from matplotlib. According to the taxonomy, horizontal bars are classified as a 'Bar chart'. No named color palette (like 'viridis') was passed; instead, a specific hex color was used."}}
{"input_csv_file": "7livingcost.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\ndef money(x, pos=None):\n    return f\"${x:,.0f}\"\n\n# Load data\ndf = pd.read_csv(\"7livingcost.csv\")\n\n# Use a common family type for comparability across counties/areas\nfamily_type = \"2p2c\"\nsub = df[df[\"family_member_count\"].astype(str).str.strip() == family_type].copy()\n\n# Fallback if 2p2c isn't present for some reason\nif sub.empty:\n    # Pick the most frequent family_member_count in the file\n    family_type = df[\"family_member_count\"].astype(str).str.strip().value_counts().index[0]\n    sub = df[df[\"family_member_count\"].astype(str).str.strip() == family_type].copy()\n\n# Compute affordability gap (positive => costs exceed income)\nsub[\"affordability_gap\"] = sub[\"total_cost\"] - sub[\"median_family_income\"]\n\n# Prepare labels\nsub[\"label\"] = sub[\"county\"].fillna(sub[\"areaname\"]).astype(str)\n\n# Sort for plotting\nsub = sub.sort_values(\"affordability_gap\", ascending=True)\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 7))\n\ncolors = sub[\"affordability_gap\"].apply(lambda v: \"#d62728\" if v > 0 else \"#2ca02c\")\nax.barh(sub[\"label\"], sub[\"affordability_gap\"], color=colors, alpha=0.9)\n\nax.axvline(0, color=\"black\", linewidth=1)\nax.xaxis.set_major_formatter(FuncFormatter(money))\n\nax.set_title(f\"Affordability Gap by County ({family_type}): Total Cost − Median Family Income\", pad=12)\nax.set_xlabel(\"Gap (USD) — positive means annual living costs exceed median family income\")\nax.set_ylabel(\"County\")\n\n# Tighten layout for long labels\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization uses the `ax.barh()` function from the matplotlib library to render horizontal bars, which corresponds to the 'Bar chart' category in the provided taxonomy. Although pandas is used for data manipulation and a seaborn style is applied, the actual rendering is performed directly via matplotlib's axes object."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8mpg.csv\")\n\n    # Single chart: MPG vs Weight, colored by cylinder count\n    fig, ax = plt.subplots(figsize=(9, 6))\n\n    cyls = sorted(df[\"cylinders\"].unique())\n    cmap = plt.get_cmap(\"tab10\")\n\n    for i, c in enumerate(cyls):\n        sub = df[df[\"cylinders\"] == c]\n        ax.scatter(\n            sub[\"weight\"],\n            sub[\"mpg\"],\n            s=70,\n            alpha=0.85,\n            color=cmap(i % 10),\n            label=f\"{c} cyl\",\n            edgecolors=\"white\",\n            linewidths=0.6,\n        )\n\n    ax.set_title(\"MPG vs Weight (Auto MPG sample, model year 1970)\")\n    ax.set_xlabel(\"Weight (lbs)\")\n    ax.set_ylabel(\"MPG\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\n    ax.legend(title=\"Cylinders\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "tab10", "reasoning": "The code uses the matplotlib axes method `ax.scatter()` to render the data points. Since it plots two quantitative variables (weight and mpg), it is classified as a Scatterplot."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8mpg.csv\")\n\n# Simple, \"read the data\" level chart: MPG by number of cylinders (shows distribution + typical value)\norder = sorted(df[\"cylinders\"].unique())\ngroups = [df.loc[df[\"cylinders\"] == c, \"mpg\"].values for c in order]\n\nplt.figure(figsize=(8, 5))\nplt.boxplot(groups, labels=order, showmeans=True)\nplt.title(\"Miles per Gallon (MPG) by Number of Cylinders\")\nplt.xlabel(\"Cylinders\")\nplt.ylabel(\"MPG\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Box plot", "color_palette": null, "reasoning": "The code uses the plt.boxplot() function directly from the matplotlib.pyplot library to render the data."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8mpg.csv\")\n\n# Simple (Curcio: \"read the data\") chart: average MPG by number of cylinders\navg_mpg = df.groupby(\"cylinders\")[\"mpg\"].mean().sort_index()\n\nplt.figure(figsize=(8, 4.5))\nbars = plt.bar(avg_mpg.index.astype(str), avg_mpg.values, color=\"#4C78A8\")\n\nplt.title(\"Average MPG by Number of Cylinders (8mpg.csv)\")\nplt.xlabel(\"Cylinders\")\nplt.ylabel(\"Average MPG\")\nplt.ylim(0, max(avg_mpg.values) * 1.15)\n\n# Value labels for easy reading\nfor b in bars:\n    h = b.get_height()\n    plt.text(b.get_x() + b.get_width() / 2, h + 0.3, f\"{h:.1f}\",\n             ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using plt.bar() from the matplotlib.pyplot library, which results in vertical bars. Based on the taxonomy, vertical bars are classified as a Column chart."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8mpg.csv\")\n\n# Single chart: distribution of MPG (good for \"read the data\" level)\nplt.figure(figsize=(8, 5))\nplt.hist(df[\"mpg\"], bins=8, edgecolor=\"black\")\nplt.title(\"Distribution of Miles Per Gallon (MPG)\")\nplt.xlabel(\"MPG\")\nplt.ylabel(\"Number of cars\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using matplotlib's 'plt.hist()' function. In the provided taxonomy, vertical bars are classified as 'Column chart'. Although it is a histogram, it uses vertical bars to map quantitative values (counts) to intervals."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8mpg.csv\")\n\n# Single chart: scatter of weight vs mpg, colored by cylinders\nplt.figure(figsize=(9, 5.5))\nscatter = plt.scatter(\n    df[\"weight\"],\n    df[\"mpg\"],\n    c=df[\"cylinders\"],\n    cmap=\"viridis\",\n    s=70,\n    alpha=0.85,\n    edgecolor=\"white\",\n    linewidth=0.6\n)\n\nplt.title(\"MPG vs Weight (colored by cylinders)\")\nplt.xlabel(\"Weight (lbs)\")\nplt.ylabel(\"MPG\")\ncbar = plt.colorbar(scatter)\ncbar.set_label(\"Cylinders\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "viridis", "reasoning": "The code uses plt.scatter() directly from matplotlib to plot two quantitative variables (weight and mpg), mapping a third variable (cylinders) to color using the viridis colormap."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8mpg.csv\")\n\n    plt.figure(figsize=(8, 5))\n    plt.scatter(df[\"weight\"], df[\"mpg\"], alpha=0.85, edgecolor=\"white\", linewidth=0.6)\n\n    plt.title(\"MPG vs Weight (8mpg.csv)\")\n    plt.xlabel(\"Weight\")\n    plt.ylabel(\"MPG\")\n    plt.grid(True, linestyle=\"--\", alpha=0.3)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the standard matplotlib function plt.scatter() to plot two quantitative variables (weight and mpg) directly from the dataframe, which classifies it as matplotlib according to the hierarchy rules."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8mpg.csv\")\n\n# Single chart: scatter plot of weight vs mpg, colored by cylinders\nplt.figure(figsize=(8, 5))\nscatter = plt.scatter(\n    df[\"weight\"],\n    df[\"mpg\"],\n    c=df[\"cylinders\"],\n    cmap=\"viridis\",\n    s=70,\n    edgecolor=\"black\",\n    linewidth=0.5,\n)\n\nplt.title(\"MPG vs Weight (colored by Cylinders)\")\nplt.xlabel(\"Weight\")\nplt.ylabel(\"MPG\")\ncbar = plt.colorbar(scatter)\ncbar.set_label(\"Cylinders\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": "viridis", "reasoning": "The code uses plt.scatter() directly from the matplotlib.pyplot interface to render the data points rather than calling a pandas plotting method or seaborn function. The visualization maps two quantitative variables (weight and mpg) to the X and Y axes, identifying it as a scatterplot."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8mpg.csv\")\n\n    plt.figure(figsize=(9, 6))\n    plt.scatter(df[\"weight\"], df[\"mpg\"], alpha=0.85, edgecolors=\"white\", linewidths=0.6)\n    plt.title(\"MPG vs Weight (8mpg.csv)\")\n    plt.xlabel(\"Weight\")\n    plt.ylabel(\"MPG\")\n    plt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.5)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using the standard matplotlib.pyplot function plt.scatter(). Two quantitative variables (weight and mpg) are mapped to the X and Y axes, satisfying the definition of a Scatterplot."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"8mpg.csv\")\n\n# Gráfico: dispersión Peso vs MPG (con tendencia lineal)\nx = df[\"weight\"]\ny = df[\"mpg\"]\n\nm, b = pd.np.polyfit(x, y, 1)  # línea de tendencia\nx_line = pd.Series([x.min(), x.max()])\ny_line = m * x_line + b\n\nplt.figure(figsize=(9, 5))\nplt.scatter(x, y, alpha=0.85)\nplt.plot(x_line, y_line, linewidth=2)\n\nplt.title(\"Relación entre peso y rendimiento (MPG) — 8mpg.csv\")\nplt.xlabel(\"Peso (weight)\")\nplt.ylabel(\"MPG (millas por galón)\")\nplt.grid(True, linestyle=\"--\", linewidth=0.7, alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses plt.scatter() and plt.plot() from matplotlib.pyplot to directly render the data. The visualization displays the relationship between two quantitative variables (weight and mpg), identifying it as a scatterplot."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8mpg.csv\")\n\n# Map origin codes to labels (Auto MPG convention)\norigin_map = {1: \"USA\", 2: \"Europe\", 3: \"Japan\"}\ndf[\"origin_label\"] = df[\"origin\"].map(origin_map).fillna(df[\"origin\"].astype(str))\n\n# --- Single chart: MPG vs Weight with horsepower as size and origin as color ---\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10.5, 6.5), dpi=140)\n\ncolors = {\"USA\": \"#1f77b4\", \"Europe\": \"#ff7f0e\", \"Japan\": \"#2ca02c\"}\n\n# Bubble size scaled by horsepower\nhp = df[\"horsepower\"].astype(float).to_numpy()\nsizes = 40 + (hp - hp.min()) / (hp.max() - hp.min()) * 260\n\nfor label, g in df.groupby(\"origin_label\", sort=True):\n    ax.scatter(\n        g[\"weight\"],\n        g[\"mpg\"],\n        s=sizes[g.index],\n        c=colors.get(label, \"#7f7f7f\"),\n        alpha=0.78,\n        edgecolor=\"white\",\n        linewidth=0.7,\n        label=f\"{label} (n={len(g)})\",\n        zorder=3,\n    )\n\n# Trendline (overall)\nx = df[\"weight\"].to_numpy()\ny = df[\"mpg\"].to_numpy()\nm, b = np.polyfit(x, y, 1)\nxx = np.linspace(x.min(), x.max(), 200)\nax.plot(xx, m * xx + b, color=\"#111111\", lw=2.2, alpha=0.9, zorder=2)\n\n# Annotate notable efficiency extremes (top 2 and bottom 2 mpg)\next_idx = pd.concat([df.nsmallest(2, \"mpg\"), df.nlargest(2, \"mpg\")]).index.unique()\nfor i in ext_idx:\n    ax.annotate(\n        df.loc[i, \"car name\"],\n        (df.loc[i, \"weight\"], df.loc[i, \"mpg\"]),\n        textcoords=\"offset points\",\n        xytext=(8, 8),\n        fontsize=8.5,\n        color=\"#222222\",\n        bbox=dict(boxstyle=\"round,pad=0.22\", fc=\"white\", ec=\"#dddddd\", alpha=0.95),\n        zorder=4,\n    )\n\nax.set_title(\"Fuel Economy vs Weight (bubble size = horsepower, color = origin)\", pad=12)\nax.set_xlabel(\"Weight (lbs)\")\nax.set_ylabel(\"MPG\")\nax.legend(title=\"Origin\", frameon=True, facecolor=\"white\", edgecolor=\"#dddddd\", loc=\"upper right\")\n\n# Subtle axis formatting\nax.set_xlim(df[\"weight\"].min() - 80, df[\"weight\"].max() + 80)\nax.set_ylim(df[\"mpg\"].min() - 1, df[\"mpg\"].max() + 2)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The code uses the matplotlib axes method `ax.scatter` to plot quantitative variables (weight vs mpg) and modulates the marker size (`s=sizes`) using a third quantitative variable (horsepower), which fits the definition of a bubble chart."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8mpg.csv\")\n\n    # Single chart: MPG vs Weight, colored by cylinders (size encodes horsepower)\n    cyl_order = sorted(df[\"cylinders\"].unique())\n    colors = {4: \"#1f77b4\", 6: \"#ff7f0e\", 8: \"#d62728\"}  # sensible defaults\n    fallback = \"#7f7f7f\"\n\n    fig, ax = plt.subplots(figsize=(9, 5.5))\n\n    for cyl in cyl_order:\n        sub = df[df[\"cylinders\"] == cyl].copy()\n        c = colors.get(cyl, fallback)\n\n        # Scale point sizes by horsepower for additional context (single chart only)\n        hp = sub[\"horsepower\"].astype(float)\n        s = 30 + (hp - hp.min()) / (hp.max() - hp.min() + 1e-9) * 220\n\n        ax.scatter(\n            sub[\"weight\"],\n            sub[\"mpg\"],\n            s=s,\n            c=c,\n            alpha=0.8,\n            edgecolor=\"white\",\n            linewidth=0.6,\n            label=f\"{cyl} cylinders\",\n        )\n\n    ax.set_title(\"Fuel Efficiency vs Vehicle Weight (size = horsepower, color = cylinders)\")\n    ax.set_xlabel(\"Weight (lb)\")\n    ax.set_ylabel(\"MPG\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.35)\n\n    ax.legend(title=\"Engine\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": null, "reasoning": "The plot is rendered using matplotlib's ax.scatter() function. It is classified as a bubble chart because it maps two quantitative variables to the X and Y axes (weight and mpg) and a third quantitative variable (horsepower) to the marker size (s)."}}
{"input_csv_file": "8mpg.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mticker\nfrom matplotlib.lines import Line2D\n\n# Load data\ndf = pd.read_csv(\"8mpg.csv\")\n\n# Map origin codes to labels (Auto MPG convention)\norigin_map = {1: \"USA\", 2: \"Europe\", 3: \"Japan\"}\ndf[\"origin_name\"] = df[\"origin\"].map(origin_map).fillna(df[\"origin\"].astype(str))\n\n# Color palette\npalette = {\"USA\": \"#1f77b4\", \"Europe\": \"#ff7f0e\", \"Japan\": \"#2ca02c\"}\ncolors = df[\"origin_name\"].map(palette).fillna(\"#7f7f7f\")\n\n# Figure\nplt.rcParams.update({\n    \"axes.spines.top\": False,\n    \"axes.spines.right\": False,\n    \"axes.titleweight\": \"bold\",\n    \"font.size\": 11\n})\n\nfig, ax = plt.subplots(figsize=(10.5, 6.5), dpi=150)\n\n# Scatter: weight vs mpg (bubble size by horsepower)\nhp = df[\"horsepower\"].astype(float)\nsizes = 40 + (hp - hp.min()) / (hp.max() - hp.min()) * 260  # 40..300\n\nax.scatter(\n    df[\"weight\"], df[\"mpg\"],\n    s=sizes,\n    c=colors,\n    alpha=0.85,\n    linewidth=0.7,\n    edgecolor=\"white\"\n)\n\n# Labels & formatting\nax.set_title(\"Fuel Economy vs. Vehicle Weight (bubble size = horsepower)\")\nax.set_xlabel(\"Weight (lb)\")\nax.set_ylabel(\"Miles per gallon (mpg)\")\n\nax.grid(True, which=\"major\", axis=\"both\", linestyle=\"-\", linewidth=0.6, alpha=0.18)\nax.xaxis.set_major_formatter(mticker.StrMethodFormatter(\"{x:,.0f}\"))\n\n# Annotate notable points: lowest mpg and highest mpg\nlow = df.loc[df[\"mpg\"].idxmin()]\nhigh = df.loc[df[\"mpg\"].idxmax()]\n\ndef annotate_point(row, dx=20, dy=0.6):\n    ax.annotate(\n        row[\"car name\"],\n        (row[\"weight\"], row[\"mpg\"]),\n        xytext=(row[\"weight\"] + dx, row[\"mpg\"] + dy),\n        textcoords=\"data\",\n        fontsize=9,\n        bbox=dict(boxstyle=\"round,pad=0.25\", fc=\"white\", ec=\"#d0d0d0\", alpha=0.95),\n        arrowprops=dict(arrowstyle=\"-\", color=\"#9a9a9a\", lw=1.0),\n        va=\"center\"\n    )\n\nannotate_point(low, dx=40, dy=-0.2)\nannotate_point(high, dx=40, dy=0.2)\n\n# Legends: origin (color) and horsepower (size)\norigin_handles = [\n    Line2D([0], [0], marker=\"o\", color=\"none\", label=k,\n           markerfacecolor=v, markeredgecolor=\"white\", markersize=9, alpha=0.95)\n    for k, v in palette.items()\n]\nleg1 = ax.legend(handles=origin_handles, title=\"Origin\", loc=\"upper right\", frameon=True)\nax.add_artist(leg1)\n\n# Size legend (horsepower)\nhp_levels = [60, 120, 200]\nsize_levels = 40 + (pd.Series(hp_levels) - hp.min()) / (hp.max() - hp.min()) * 260\nsize_handles = [\n    plt.scatter([], [], s=s, c=\"#555555\", alpha=0.25, edgecolors=\"white\", linewidth=0.7, label=f\"{h} hp\")\n    for h, s in zip(hp_levels, size_levels)\n]\nax.legend(handles=size_handles, title=\"Horsepower\", loc=\"lower left\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"error": "JSON Parsing Failed: Expecting property name enclosed in double quotes: line 6 column 1 (char 409)", "raw_text": "{\n    \"library\": \"matplotlib\",\n    \"chart_type\": \"Bubble chart\",\n    \"color_palette\": null,\n    \"reasoning\": \"The code uses matplotlib's ax.scatter() function directly to render the data. The plot maps two quantitative variables (weight and mpg) to the spatial axes and a third quantitative variable (horsepower) to the marker size via the 's' parameter, fitting the taxonomy definition for a bubble chart.\",\n}"}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8penguins.csv\")\n\n# Scatter plot: Culmen length vs body mass, colored by sex\nfig, ax = plt.subplots(figsize=(8, 5))\n\nsexes = df[\"sex\"].dropna().unique()\ncolors = {\"MALE\": \"#1f77b4\", \"FEMALE\": \"#ff7f0e\"}\n\nfor sex in sexes:\n    sub = df[df[\"sex\"] == sex]\n    ax.scatter(\n        sub[\"culmen_length_mm\"],\n        sub[\"body_mass_g\"],\n        s=70,\n        alpha=0.85,\n        color=colors.get(sex, None),\n        label=sex,\n        edgecolor=\"white\",\n        linewidth=0.7\n    )\n\nax.set_title(\"Penguins: Body Mass vs Culmen Length (colored by sex)\")\nax.set_xlabel(\"Culmen length (mm)\")\nax.set_ylabel(\"Body mass (g)\")\nax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\nax.legend(title=\"Sex\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using the standard Matplotlib axes function ax.scatter() to plot two quantitative dimensions (culmen length and body mass) against each other."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8penguins.csv\")\n\n# Compute average body mass by sex\nsummary = (\n    df.groupby(\"sex\", dropna=False)[\"body_mass_g\"]\n      .mean()\n      .sort_index()\n)\n\n# Plot: single chart (bar chart)\nfig, ax = plt.subplots(figsize=(7, 4.5))\nax.bar(summary.index.astype(str), summary.values, color=[\"#4C78A8\", \"#F58518\"])\n\nax.set_title(\"Average Body Mass by Sex (Adelie Penguins, Torgersen)\")\nax.set_xlabel(\"Sex\")\nax.set_ylabel(\"Average body mass (g)\")\n\n# Add value labels\nfor i, v in enumerate(summary.values):\n    ax.text(i, v + 40, f\"{v:.0f} g\", ha=\"center\", va=\"bottom\", fontsize=10)\n\nax.set_ylim(0, max(summary.values) * 1.2)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib axes function `ax.bar()` to render data. Since `ax.bar()` creates vertical bars by default, it is classified as a Column chart per the taxonomy."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8penguins.csv\")\n\n# Simple summary chart: average body mass by sex\nsummary = (\n    df.dropna(subset=[\"sex\", \"body_mass_g\"])\n      .groupby(\"sex\", as_index=True)[\"body_mass_g\"]\n      .mean()\n      .sort_index()\n)\n\n# Plot (single chart)\nplt.figure(figsize=(6.5, 4.0))\nax = summary.plot(kind=\"bar\", color=[\"#4C78A8\", \"#F58518\"], edgecolor=\"black\")\n\nax.set_title(\"Average Body Mass by Sex (Adelie Penguins, Torgersen)\")\nax.set_xlabel(\"Sex\")\nax.set_ylabel(\"Average body mass (g)\")\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\n# Add value labels\nfor i, v in enumerate(summary.values):\n    ax.text(i, v + 30, f\"{v:.0f}\", ha=\"center\", va=\"bottom\", fontsize=10)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization is created using the .plot(kind='bar') method on a pandas object (summary), which identifies the library as 'pandas' according to the hierarchy rules. Because the bars are oriented vertically, it is classified as a Column chart."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8penguins.csv\")\n\n# Single chart: relationship between culmen length and culmen depth, colored by sex\nplt.figure(figsize=(7, 5))\nfor sex, g in df.groupby(\"sex\"):\n    plt.scatter(\n        g[\"culmen_length_mm\"],\n        g[\"culmen_depth_mm\"],\n        s=70,\n        alpha=0.85,\n        label=sex\n    )\n\nplt.title(\"Adelie Penguins: Culmen Length vs Culmen Depth (colored by sex)\")\nplt.xlabel(\"Culmen length (mm)\")\nplt.ylabel(\"Culmen depth (mm)\")\nplt.grid(True, linewidth=0.4, alpha=0.4)\nplt.legend(title=\"Sex\", frameon=False)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization uses the standard matplotlib.pyplot function plt.scatter() to render quantitative data points, which classifies the library as matplotlib and the chart type as a Scatterplot."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8penguins.csv\")\n\n# Clean/standardize\ndf[\"sex\"] = df[\"sex\"].astype(str).str.strip().str.upper()\ndf = df.dropna(subset=[\"culmen_length_mm\", \"culmen_depth_mm\", \"sex\"])\n\n# Plot: Culmen length vs culmen depth, colored by sex\nfig, ax = plt.subplots(figsize=(8, 5))\n\ncolors = {\"MALE\": \"#1f77b4\", \"FEMALE\": \"#ff7f0e\"}\nfor sex, g in df.groupby(\"sex\"):\n    ax.scatter(\n        g[\"culmen_length_mm\"],\n        g[\"culmen_depth_mm\"],\n        s=70,\n        alpha=0.85,\n        edgecolor=\"white\",\n        linewidth=0.6,\n        label=sex,\n        color=colors.get(sex, \"gray\"),\n    )\n\nax.set_title(\"Adelie Penguins (Torgersen): Culmen Length vs Culmen Depth\")\nax.set_xlabel(\"Culmen length (mm)\")\nax.set_ylabel(\"Culmen depth (mm)\")\nax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\nax.legend(title=\"Sex\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization is created using the ax.scatter() method from the matplotlib library to plot two quantitative variables (culmen length and depth)."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8penguins.csv\")\n\n    # Scatter: flipper length vs body mass, colored by sex\n    fig, ax = plt.subplots(figsize=(7, 5))\n\n    colors = {\"MALE\": \"#1f77b4\", \"FEMALE\": \"#ff7f0e\"}\n    for sex, g in df.groupby(\"sex\", dropna=False):\n        ax.scatter(\n            g[\"flipper_length_mm\"],\n            g[\"body_mass_g\"],\n            s=70,\n            alpha=0.85,\n            label=str(sex),\n            color=colors.get(str(sex), \"gray\"),\n            edgecolor=\"white\",\n            linewidth=0.6,\n        )\n\n    ax.set_title(\"Penguins: Flipper Length vs Body Mass (colored by sex)\")\n    ax.set_xlabel(\"Flipper length (mm)\")\n    ax.set_ylabel(\"Body mass (g)\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n    ax.legend(title=\"Sex\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the Matplotlib 'ax.scatter()' method directly to visualize the relationship between two quantitative variables (flipper_length_mm and body_mass_g). Although pandas is used for data manipulation, the rendering is performed by matplotlib."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8penguins.csv\")\n\n    fig, ax = plt.subplots(figsize=(7.5, 5.5))\n\n    sex_order = [\"FEMALE\", \"MALE\"]\n    colors = {\"FEMALE\": \"#4C78A8\", \"MALE\": \"#F58518\"}\n\n    for sex in sex_order:\n        sub = df[df[\"sex\"] == sex]\n        ax.scatter(\n            sub[\"flipper_length_mm\"],\n            sub[\"body_mass_g\"],\n            s=70,\n            alpha=0.85,\n            c=colors.get(sex, \"gray\"),\n            edgecolors=\"white\",\n            linewidths=0.6,\n            label=sex,\n        )\n\n    ax.set_title(\"Penguins: Flipper Length vs Body Mass (colored by Sex)\")\n    ax.set_xlabel(\"Flipper length (mm)\")\n    ax.set_ylabel(\"Body mass (g)\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\n    ax.legend(title=\"Sex\", frameon=False)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The data is rendered using the ax.scatter() function from the matplotlib library. The plot visualizes two quantitative dimensions (flipper_length_mm and body_mass_g), which fits the taxonomy definition for a scatterplot."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8penguins.csv\")\n\n    fig, ax = plt.subplots(figsize=(7.5, 5.5))\n\n    for sex, g in df.groupby(\"sex\", dropna=False):\n        ax.scatter(\n            g[\"culmen_length_mm\"],\n            g[\"body_mass_g\"],\n            s=70,\n            alpha=0.85,\n            label=str(sex)\n        )\n\n    ax.set_title(\"Penguins: Body Mass vs Culmen Length (colored by sex)\")\n    ax.set_xlabel(\"Culmen length (mm)\")\n    ax.set_ylabel(\"Body mass (g)\")\n    ax.grid(True, linestyle=\"--\", linewidth=0.7, alpha=0.35)\n    ax.legend(title=\"Sex\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the 'ax.scatter()' method from matplotlib directly to render the data points. The visualization maps two quantitative variables (culmen_length_mm and body_mass_g) to the X and Y axes, which defines a Scatterplot according to the taxonomy."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"8penguins.csv\")\n\n# Dispersión: longitud de aleta vs masa corporal, coloreado por sexo\ncolors = {\"MALE\": \"#1f77b4\", \"FEMALE\": \"#ff7f0e\"}\nfor sex, g in df.groupby(\"sex\"):\n    plt.scatter(\n        g[\"flipper_length_mm\"],\n        g[\"body_mass_g\"],\n        s=70,\n        alpha=0.9,\n        c=colors.get(sex, \"gray\"),\n        label=sex\n    )\n\nplt.title(\"Pingüinos (Adelie, Torgersen): Aleta vs Masa\")\nplt.xlabel(\"Longitud de aleta (mm)\")\nplt.ylabel(\"Masa corporal (g)\")\nplt.grid(True, linestyle=\"--\", linewidth=0.6, alpha=0.4)\nplt.legend(title=\"Sexo\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses plt.scatter() directly to render the data points with two quantitative variables (flipper_length_mm and body_mass_g). Although pandas is used for data loading and grouping, the plotting logic is handled by standard matplotlib functions."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8penguins.csv\")\n\n# Clean/standardize sex labels and drop missing\ndf[\"sex\"] = df[\"sex\"].astype(str).str.strip().str.upper()\ndf = df[df[\"sex\"].isin([\"MALE\", \"FEMALE\"])].copy()\n\n# Plot: relationship between culmen length and depth, colored by sex\nfig, ax = plt.subplots(figsize=(8.5, 5.5), dpi=130)\n\ncolors = {\"FEMALE\": \"#4C78A8\", \"MALE\": \"#F58518\"}\nfor sex, g in df.groupby(\"sex\"):\n    ax.scatter(\n        g[\"culmen_length_mm\"],\n        g[\"culmen_depth_mm\"],\n        s=85,\n        alpha=0.9,\n        color=colors.get(sex, \"gray\"),\n        edgecolor=\"white\",\n        linewidth=0.8,\n        label=f\"{sex} (n={len(g)})\",\n    )\n\nax.set_title(\"Adelie Penguins (Torgersen): Culmen Length vs Culmen Depth\", pad=10)\nax.set_xlabel(\"Culmen length (mm)\")\nax.set_ylabel(\"Culmen depth (mm)\")\n\nax.grid(True, which=\"major\", linestyle=\"-\", linewidth=0.6, alpha=0.25)\nax.set_axisbelow(True)\n\n# Tight bounds with small padding\nx_min, x_max = df[\"culmen_length_mm\"].min(), df[\"culmen_length_mm\"].max()\ny_min, y_max = df[\"culmen_depth_mm\"].min(), df[\"culmen_depth_mm\"].max()\nax.set_xlim(x_min - 0.8, x_max + 0.8)\nax.set_ylim(y_min - 0.6, y_max + 0.6)\n\nleg = ax.legend(title=\"Sex\", frameon=True, facecolor=\"white\", framealpha=0.9)\nleg.get_frame().set_linewidth(0.0)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The plot is rendered using the standard matplotlib axes method `ax.scatter()`. It visualizes the relationship between two quantitative variables (culmen length and culmen depth), which identifies it as a scatterplot."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8penguins.csv\")\n\n# Clean/standardize\ndf[\"sex\"] = df[\"sex\"].astype(str).str.strip().str.upper()\ndf = df.dropna(subset=[\"culmen_length_mm\", \"culmen_depth_mm\", \"sex\"])\n\n# Single chart: scatter of culmen length vs culmen depth, colored by sex\ncolors = {\"FEMALE\": \"#4C78A8\", \"MALE\": \"#F58518\"}\nfig, ax = plt.subplots(figsize=(8, 5.5), dpi=130)\n\nfor sex, g in df.groupby(\"sex\", sort=True):\n    ax.scatter(\n        g[\"culmen_length_mm\"],\n        g[\"culmen_depth_mm\"],\n        s=70,\n        alpha=0.85,\n        c=colors.get(sex, \"#999999\"),\n        edgecolor=\"white\",\n        linewidth=0.7,\n        label=f\"{sex} (n={len(g)})\",\n        zorder=3\n    )\n\nax.set_title(\"Adelie Penguins (Torgersen): Culmen Length vs Depth\", pad=10)\nax.set_xlabel(\"Culmen length (mm)\")\nax.set_ylabel(\"Culmen depth (mm)\")\n\nax.grid(True, which=\"major\", color=\"#E6E6E6\", linewidth=0.8)\nax.set_axisbelow(True)\n\nax.legend(frameon=False, title=\"Sex\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The code uses the Matplotlib axes object method `ax.scatter()` directly to render data based on two quantitative variables (culmen length vs depth), without using higher-level wrappers like Seaborn or Pandas plotting methods."}}
{"input_csv_file": "8penguins.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"8penguins.csv\")\n\n# Style\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\n\n# Single chart: Body mass vs flipper length, colored by sex, with regression per sex\nfig, ax = plt.subplots(figsize=(9, 6))\n\npalette = {\"FEMALE\": \"#4C78A8\", \"MALE\": \"#F58518\"}\nsns.scatterplot(\n    data=df,\n    x=\"flipper_length_mm\",\n    y=\"body_mass_g\",\n    hue=\"sex\",\n    palette=palette,\n    s=110,\n    edgecolor=\"white\",\n    linewidth=0.8,\n    ax=ax,\n)\n\nfor sex, color in palette.items():\n    sub = df[df[\"sex\"] == sex]\n    if len(sub) >= 2:\n        sns.regplot(\n            data=sub,\n            x=\"flipper_length_mm\",\n            y=\"body_mass_g\",\n            scatter=False,\n            ci=None,\n            line_kws={\"color\": color, \"linewidth\": 2.2, \"alpha\": 0.9},\n            ax=ax,\n        )\n\nax.set_title(\"Penguins (Adelie, Torgersen): Body Mass vs Flipper Length by Sex\")\nax.set_xlabel(\"Flipper length (mm)\")\nax.set_ylabel(\"Body mass (g)\")\nax.legend(title=\"Sex\", frameon=True, loc=\"best\")\n\nsns.despine(ax=ax)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": null, "reasoning": "The visualization uses seaborn's sns.scatterplot() to render the main data points and sns.regplot() for the regression overlays. Following the library hierarchy, seaborn takes priority over matplotlib even though plt.subplots() is used for layout."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8Pokemon.csv\")\n\n# Aggregate: average Total stats by primary type\navg_total_by_type = (\n    df.groupby(\"Type 1\", as_index=False)[\"Total\"]\n      .mean()\n      .sort_values(\"Total\", ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(9, 5))\nplt.bar(avg_total_by_type[\"Type 1\"], avg_total_by_type[\"Total\"], color=\"#4C78A8\")\nplt.title(\"Average Total Base Stats by Primary Type (Type 1)\")\nplt.xlabel(\"Type 1\")\nplt.ylabel(\"Average Total\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses the standard 'plt.bar()' function from the matplotlib.pyplot library to render vertical bars, which classifies it as a 'Column chart' rather than a 'Bar chart'. No named color palette (like 'viridis') was used; instead, a single hex color code was provided."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8Pokemon.csv\")\n\n# Prepare summary: average Total by primary type\ntype_summary = (\n    df.groupby(\"Type 1\", as_index=False)[\"Total\"]\n    .mean()\n    .sort_values(\"Total\", ascending=False)\n)\n\n# Plot: single chart\nplt.figure(figsize=(9, 5))\nplt.bar(type_summary[\"Type 1\"], type_summary[\"Total\"], color=\"#4C78A8\")\nplt.title(\"Average Total Stats by Primary Type (Type 1)\")\nplt.xlabel(\"Primary Type (Type 1)\")\nplt.ylabel(\"Average Total\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The visualization uses the plt.bar() function directly to render vertical bars, which classifies it as a Column chart under the provided taxonomy. Since it calls a matplotlib.pyplot function rather than a dataframe wrapper or seaborn method, the library is identified as matplotlib."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8Pokemon.csv\")\n\n# Make a simple chart: average Total by primary type (Type 1)\navg_total_by_type = (\n    df.groupby(\"Type 1\", as_index=False)[\"Total\"]\n      .mean()\n      .sort_values(\"Total\", ascending=False)\n)\n\n# Plot (single chart)\nplt.figure(figsize=(9, 5))\nplt.bar(avg_total_by_type[\"Type 1\"], avg_total_by_type[\"Total\"], color=\"steelblue\")\nplt.title(\"Average Total Stats by Primary Type (Type 1)\")\nplt.xlabel(\"Primary Type (Type 1)\")\nplt.ylabel(\"Average Total\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": "steelblue", "reasoning": "The plot is created using the matplotlib function plt.bar(), which generates vertical bars representing a categorical variable (Type 1) and a quantitative variable (Average Total). Following the hierarchy rules, it is classified as matplotlib because it does not use seaborn or pandas plotting wrappers."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8Pokemon.csv\")\n\n# Prepare: average Total by primary type (Type 1)\ntype_totals = (\n    df.groupby(\"Type 1\", as_index=False)[\"Total\"]\n    .mean()\n    .sort_values(\"Total\", ascending=False)\n)\n\n# Plot: single bar chart\nplt.figure(figsize=(9, 5))\nplt.bar(type_totals[\"Type 1\"], type_totals[\"Total\"], color=\"#4C78A8\")\nplt.title(\"Average Total Stat by Primary Type (Type 1)\")\nplt.xlabel(\"Primary Type (Type 1)\")\nplt.ylabel(\"Average Total\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() which creates vertical bars mapping a categorical variable (Type 1) to a quantitative variable (Average Total). According to the hierarchy rules, since the data is rendered using standard pyplot functions rather than seaborn or pandas plotting methods, the library is matplotlib."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8Pokemon.csv\")\n\n    # Aggregate: average Total by primary type\n    avg_total_by_type = (\n        df.groupby(\"Type 1\", as_index=False)[\"Total\"]\n          .mean()\n          .sort_values(\"Total\", ascending=False)\n    )\n\n    plt.figure(figsize=(10, 5))\n    plt.bar(avg_total_by_type[\"Type 1\"], avg_total_by_type[\"Total\"], color=\"#4C78A8\")\n    plt.title(\"Average Total Stats by Primary Type (Type 1)\")\n    plt.xlabel(\"Type 1\")\n    plt.ylabel(\"Average Total\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly from the matplotlib.pyplot library to render the data. Since plt.bar() creates vertical bars for categorical and quantitative data, it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8Pokemon.csv\")\n\n    # Aggregate: average Total by primary type\n    avg_total_by_type1 = (\n        df.groupby(\"Type 1\")[\"Total\"]\n        .mean()\n        .sort_values(ascending=False)\n    )\n\n    plt.figure(figsize=(9, 5))\n    avg_total_by_type1.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\n\n    plt.title(\"Average Total Stats by Primary Type (Type 1)\")\n    plt.xlabel(\"Type 1\")\n    plt.ylabel(\"Average Total\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas Series.plot(kind='bar') method. According to the hierarchy rules, even though matplotlib is used for styling, the rendering method makes the library 'pandas'. Since 'kind=\"bar\"' in pandas creates vertical bars, it is classified as a Column chart."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"8Pokemon.csv\")\n\n    # Type 1 ごとの平均 Total を計算して降順に並べる\n    avg_total_by_type1 = (\n        df.groupby(\"Type 1\", as_index=True)[\"Total\"]\n        .mean()\n        .sort_values(ascending=False)\n    )\n\n    # 1つのグラフ（棒グラフ）を作成\n    plt.figure(figsize=(9, 5))\n    avg_total_by_type1.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\n    plt.title(\"Average Total by Type 1 (from 8Pokemon.csv)\")\n    plt.xlabel(\"Type 1\")\n    plt.ylabel(\"Average Total\")\n    plt.xticks(rotation=0)\n    plt.tight_layout()\n\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the pandas plotting wrapper `.plot(kind='bar')` to render the data, which defaults to a vertical bar layout (Column chart according to the taxonomy). While matplotlib is used for figure and label styling, the primary plotting call is a pandas method."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8Pokemon.csv\")\n\n# Compute average Total by primary type (Type 1)\ntype_avg = (\n    df.groupby(\"Type 1\", as_index=False)[\"Total\"]\n      .mean()\n      .sort_values(\"Total\", ascending=False)\n)\n\n# Plot single chart\nplt.figure(figsize=(10, 5))\nplt.bar(type_avg[\"Type 1\"], type_avg[\"Total\"], color=\"#4C78A8\")\nplt.title(\"Average Total Stats by Primary Type (Type 1)\")\nplt.xlabel(\"Type 1\")\nplt.ylabel(\"Average Total\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render the data, which falls under the matplotlib classification. Since the bars are vertical by default in plt.bar(), it is classified as a Column chart according to the taxonomy."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"8Pokemon.csv\")\n\n# Calcular el promedio de stats por Type 1 (una sola serie para un solo gráfico)\navg_total_by_type = (\n    df.groupby(\"Type 1\", as_index=True)[\"Total\"]\n      .mean()\n      .sort_values(ascending=False)\n)\n\n# Gráfico (único)\nplt.figure(figsize=(9, 5))\navg_total_by_type.plot(kind=\"bar\", color=\"#4C78A8\", edgecolor=\"black\")\nplt.title(\"Promedio de 'Total' por Tipo Primario (Type 1)\")\nplt.xlabel(\"Type 1\")\nplt.ylabel(\"Promedio de Total\")\nplt.xticks(rotation=0)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Column chart", "color_palette": null, "reasoning": "The data is rendered using the .plot(kind='bar') method on a pandas Series, which makes the library 'pandas'. Since kind='bar' in pandas/matplotlib results in vertical bars, it is classified as a Column chart."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"8Pokemon.csv\")\n\n# Prepare: average Total by primary type, with counts\ntype_summary = (\n    df.groupby(\"Type 1\")\n      .agg(avg_total=(\"Total\", \"mean\"), count=(\"Name\", \"size\"))\n      .sort_values(\"avg_total\", ascending=True)\n      .reset_index()\n)\n\n# Plot\nsns.set_theme(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 5.5))\n\nbars = ax.barh(\n    type_summary[\"Type 1\"],\n    type_summary[\"avg_total\"],\n    color=sns.color_palette(\"viridis\", n_colors=len(type_summary)),\n    edgecolor=\"none\"\n)\n\nax.set_title(\"Average Total Stats by Primary Type (Type 1)\")\nax.set_xlabel(\"Average Total\")\nax.set_ylabel(\"Primary Type (Type 1)\")\n\n# Annotate bars with value and sample size\nfor y, (v, n) in enumerate(zip(type_summary[\"avg_total\"], type_summary[\"count\"])):\n    ax.text(v + 3, y, f\"{v:.1f}  (n={n})\", va=\"center\", ha=\"left\", fontsize=10)\n\nax.set_xlim(0, max(type_summary[\"avg_total\"]) * 1.15)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": "viridis", "reasoning": "The data is rendered using the matplotlib function `ax.barh()`. Although seaborn is used for theme and palette generation, the core plotting function is from matplotlib. Since the bars are horizontal, it is classified as a 'Bar chart' according to the taxonomy."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"8Pokemon.csv\")\n\n# Clean/normalize\ndf[\"Legendary\"] = df[\"Legendary\"].astype(bool)\ndf[\"Type 2\"] = df[\"Type 2\"].fillna(\"(None)\")\n\n# Plot: Total vs Speed, colored by Type 1, shaped by Legendary\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\nfig, ax = plt.subplots(figsize=(12, 7))\n\npalette = sns.color_palette(\"tab10\", n_colors=df[\"Type 1\"].nunique())\nsns.scatterplot(\n    data=df,\n    x=\"Speed\",\n    y=\"Total\",\n    hue=\"Type 1\",\n    style=\"Legendary\",\n    s=140,\n    alpha=0.9,\n    edgecolor=\"white\",\n    linewidth=0.8,\n    palette=palette,\n    ax=ax,\n)\n\n# Annotate top performers by Total\ntop_n = 6\ntop = df.nlargest(top_n, \"Total\").copy()\nfor _, r in top.iterrows():\n    ax.text(\n        r[\"Speed\"] + 1.5,\n        r[\"Total\"] + 3,\n        r[\"Name\"],\n        fontsize=10,\n        ha=\"left\",\n        va=\"bottom\",\n        color=\"black\",\n    )\n\nax.set_title(\"Pokémon Base Stat Total vs Speed (colored by Type 1)\")\nax.set_xlabel(\"Speed\")\nax.set_ylabel(\"Total (Base Stat Sum)\")\n\n# Legend formatting\nhandles, labels = ax.get_legend_handles_labels()\nax.legend(\n    handles=handles,\n    labels=labels,\n    title=\"Type 1 / Legendary\",\n    loc=\"center left\",\n    bbox_to_anchor=(1.02, 0.5),\n    frameon=True,\n)\n\nsns.despine(ax=ax)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Scatterplot", "color_palette": "tab10", "reasoning": "The data is visualized using sns.scatterplot() to map two quantitative variables ('Speed' and 'Total') to the X and Y axes, while 'Type 1' is mapped to color and 'Legendary' to marker style. The library is classified as seaborn because a seaborn-specific plotting function was used to draw the data points."}}
{"input_csv_file": "8Pokemon.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"8Pokemon.csv\")\n\n# Aggregate: average Total by primary type (Type 1)\ntype_stats = (\n    df.groupby(\"Type 1\", as_index=False)[\"Total\"]\n      .mean()\n      .sort_values(\"Total\", ascending=True)\n)\n\n# Plot: horizontal bar chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(9, 5.5))\n\nax.barh(type_stats[\"Type 1\"], type_stats[\"Total\"], color=\"#4C78A8\")\n\nax.set_title(\"Average Total Stats by Primary Type (Type 1)\")\nax.set_xlabel(\"Average Total\")\nax.set_ylabel(\"Primary Type\")\n\n# Add value labels\nfor y, v in enumerate(type_stats[\"Total\"]):\n    ax.text(v + 3, y, f\"{v:.1f}\", va=\"center\", fontsize=10)\n\nax.set_xlim(0, max(type_stats[\"Total\"]) + 80)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The data is rendered directly using matplotlib's 'ax.barh()' function, which specifically creates horizontal bars, matching the 'Bar chart' definition in the taxonomy."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Convert weekly earnings columns to numeric (coerce 'Na' and other non-numeric to NaN)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Remove the aggregate row and rows without overall weekly earnings\nplot_df = df[df[\"Occupation\"] != \"ALL OCCUPATIONS\"].copy()\nplot_df = plot_df.dropna(subset=[\"All_weekly\"])\n\n# Sort by overall weekly earnings and keep a readable subset (top 12)\nplot_df = plot_df.sort_values(\"All_weekly\", ascending=False).head(12)\n\n# Create a single chart: grouped horizontal bars for All vs Men vs Women\nfig, ax = plt.subplots(figsize=(12, 7))\n\ny = range(len(plot_df))\nbar_h = 0.25\n\nax.barh([i + bar_h for i in y], plot_df[\"All_weekly\"], height=bar_h, label=\"All\", color=\"#4C78A8\")\nax.barh(y, plot_df[\"M_weekly\"], height=bar_h, label=\"Men\", color=\"#F58518\")\nax.barh([i - bar_h for i in y], plot_df[\"F_weekly\"], height=bar_h, label=\"Women\", color=\"#54A24B\")\n\nax.set_yticks(list(y))\nax.set_yticklabels(plot_df[\"Occupation\"])\nax.invert_yaxis()\n\nax.set_xlabel(\"Usual weekly earnings (USD)\")\nax.set_title(\"Usual Weekly Earnings by Occupation (Top 12 by Overall Earnings)\")\nax.legend(loc=\"lower right\", frameon=True)\n\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped bar chart", "color_palette": null, "reasoning": "The code uses ax.barh() directly from matplotlib to create multiple horizontal bars for each occupation, representing different subgroups (All, Men, Women). This matches the definition of a Grouped bar chart."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Convert weekly pay columns to numeric (Na -> NaN)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Focus on categories under MANAGEMENT (exclude ALL OCCUPATIONS and the MANAGEMENT header row)\ndata = df.loc[2:].copy()\ndata = data.dropna(subset=[\"M_weekly\", \"F_weekly\"])\n\n# Gender pay gap (male - female)\ndata[\"Gap\"] = data[\"M_weekly\"] - data[\"F_weekly\"]\n\n# Sort by largest gap\ndata = data.sort_values(\"Gap\", ascending=True)\n\n# Plot\nplt.figure(figsize=(10, 7))\nplt.barh(data[\"Occupation\"], data[\"Gap\"], color=\"#4C78A8\")\nplt.axvline(0, color=\"black\", linewidth=1)\nplt.title(\"Weekly Pay Gap by Occupation (Male - Female)\")\nplt.xlabel(\"Gap in Weekly Earnings\")\nplt.ylabel(\"Occupation\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the `plt.barh()` function directly from the matplotlib.pyplot library to create horizontal bars. According to the taxonomy, horizontal bars are classified as a 'Bar chart'. The library is identified as 'matplotlib' because it uses standard pyplot functions to render the data rather than pandas or seaborn wrappers."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Convert weekly earnings columns to numeric (coerce 'Na' / missing to NaN)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Focus on detailed occupations (exclude the roll-up rows)\ndf_plot = df[~df[\"Occupation\"].isin([\"ALL OCCUPATIONS\", \"MANAGEMENT\"])].copy()\n\n# Compute gender pay gap (%): (M - F) / M * 100, only where both are present\ndf_plot[\"Gap_pct\"] = (df_plot[\"M_weekly\"] - df_plot[\"F_weekly\"]) / df_plot[\"M_weekly\"] * 100\ndf_plot = df_plot.dropna(subset=[\"Gap_pct\"])\n\n# Keep the top 10 largest gaps for readability\ndf_plot = df_plot.sort_values(\"Gap_pct\", ascending=True).tail(10)\n\n# Plot\nfig, ax = plt.subplots(figsize=(11, 6))\nax.barh(df_plot[\"Occupation\"], df_plot[\"Gap_pct\"], color=\"#4C78A8\")\n\nax.set_title(\"Top 10 Occupations by Gender Weekly Pay Gap\\n(Gap = (Men - Women) / Men)\")\nax.set_xlabel(\"Gender pay gap (%)\")\nax.set_ylabel(\"Occupation\")\n\n# Add value labels\nfor i, v in enumerate(df_plot[\"Gap_pct\"]):\n    ax.text(v + 0.5, i, f\"{v:.1f}%\", va=\"center\", fontsize=9)\n\nax.axvline(0, color=\"black\", linewidth=0.8)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's axes object method `ax.barh()` to render the visualization. Since the bars are horizontal and represent a categorical variable (Occupation) versus a quantitative variable (Gap_pct), it is classified as a Bar chart according to the taxonomy."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Convert weekly pay columns to numeric (turn 'Na' / non-numeric into NaN)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Exclude the overall total row and keep rows with both male & female weekly pay present\nplot_df = df[df[\"Occupation\"] != \"ALL OCCUPATIONS\"].copy()\nplot_df = plot_df.dropna(subset=[\"M_weekly\", \"F_weekly\"])\n\n# Compute pay gap (male - female) and select top occupations by largest gap\nplot_df[\"gap\"] = plot_df[\"M_weekly\"] - plot_df[\"F_weekly\"]\nplot_df = plot_df.sort_values(\"gap\", ascending=False).head(10)\n\n# Plot: simple, readable bar chart (single chart)\nplt.figure(figsize=(11, 6))\nplt.barh(plot_df[\"Occupation\"], plot_df[\"gap\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()\n\nplt.title(\"Top 10 Occupations by Weekly Pay Gap (Male - Female)\")\nplt.xlabel(\"Weekly pay gap (USD)\")\nplt.ylabel(\"Occupation\")\n\n# Label values at bar ends\nfor y, v in enumerate(plot_df[\"gap\"].values):\n    plt.text(v + 5, y, f\"{int(round(v))}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The data is rendered using the `plt.barh()` function from Matplotlib. Since the bars are horizontal (categorical labels on the Y-axis and quantitative values on the X-axis), it is classified as a Bar chart according to the taxonomy."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Convert weekly earnings columns to numeric (coerce 'Na' / missing to NaN)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Exclude aggregate row to focus on occupations\nplot_df = df[df[\"Occupation\"].str.strip() != \"ALL OCCUPATIONS\"].copy()\n\n# Compute gender pay ratio where both are available\nplot_df[\"F_to_M_ratio\"] = plot_df[\"F_weekly\"] / plot_df[\"M_weekly\"]\n\n# Keep rows with valid ratios and get top 12 by worker count for readability\nplot_df = plot_df.dropna(subset=[\"F_to_M_ratio\", \"All_workers\"])\nplot_df = plot_df.sort_values(\"All_workers\", ascending=False).head(12)\nplot_df = plot_df.sort_values(\"F_to_M_ratio\", ascending=True)\n\n# Plot: Female-to-Male weekly earnings ratio by occupation\nfig, ax = plt.subplots(figsize=(12, 6))\nax.barh(plot_df[\"Occupation\"], plot_df[\"F_to_M_ratio\"], color=\"#4C78A8\")\n\nax.axvline(1.0, color=\"black\", linewidth=1, linestyle=\"--\")\nax.set_xlabel(\"Female weekly earnings / Male weekly earnings\")\nax.set_title(\"Gender Weekly Earnings Ratio by Occupation (Top 12 by Workers)\")\nax.set_xlim(0, max(1.1, float(plot_df[\"F_to_M_ratio\"].max()) + 0.05))\n\n# Add value labels\nfor y, val in enumerate(plot_df[\"F_to_M_ratio\"]):\n    ax.text(val + 0.01, y, f\"{val:.2f}\", va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The plot is created using the matplotlib `ax.barh()` function directly rather than a pandas or seaborn wrapper. Since the bars are horizontal, it is classified as a Bar chart."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load CSV\ndf = pd.read_csv(\"9Income.csv\")\n\n# Convert weekly earnings to numeric (coerce 'Na' to NaN)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Exclude the aggregate row for clearer comparison across occupations\ndf_plot = df[df[\"Occupation\"].str.upper() != \"ALL OCCUPATIONS\"].copy()\n\n# Keep rows with both male and female weekly values\ndf_plot = df_plot.dropna(subset=[\"M_weekly\", \"F_weekly\"])\n\n# Sort by overall weekly earnings (if missing, sort by male weekly)\ndf_plot[\"sort_key\"] = df_plot[\"All_weekly\"].fillna(df_plot[\"M_weekly\"])\ndf_plot = df_plot.sort_values(\"sort_key\", ascending=True)\n\n# Plot: Male vs Female weekly earnings by occupation\ny = np.arange(len(df_plot))\nplt.figure(figsize=(12, 8))\nplt.barh(y - 0.2, df_plot[\"M_weekly\"], height=0.38, label=\"Male weekly\", color=\"#4C78A8\")\nplt.barh(y + 0.2, df_plot[\"F_weekly\"], height=0.38, label=\"Female weekly\", color=\"#F58518\")\n\nplt.yticks(y, df_plot[\"Occupation\"])\nplt.xlabel(\"Weekly earnings\")\nplt.title(\"Weekly Earnings by Occupation (Male vs Female)\")\nplt.legend()\nplt.grid(axis=\"x\", linestyle=\"--\", alpha=0.35)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped bar chart", "color_palette": null, "reasoning": "The chart uses plt.barh() from matplotlib to draw data directly. Since there are multiple horizontal bars per occupation category (offset by +/- 0.2 on the y-axis), it is classified as a grouped bar chart."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Convert weekly earnings columns to numeric (Na -> NaN)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Exclude the overall total row for clearer occupation comparison\nplot_df = df[df[\"Occupation\"].str.upper() != \"ALL OCCUPATIONS\"].copy()\n\n# Sort by overall weekly earnings (descending)\nplot_df = plot_df.sort_values(\"All_weekly\", ascending=False)\n\n# Single chart: grouped horizontal bar chart of weekly earnings by gender\nfig, ax = plt.subplots(figsize=(12, 9))\ny = range(len(plot_df))\n\nbar_h = 0.25\nax.barh([i + bar_h for i in y], plot_df[\"M_weekly\"], height=bar_h, label=\"Male (weekly)\", color=\"#1f77b4\")\nax.barh(y, plot_df[\"All_weekly\"], height=bar_h, label=\"All (weekly)\", color=\"#7f7f7f\")\nax.barh([i - bar_h for i in y], plot_df[\"F_weekly\"], height=bar_h, label=\"Female (weekly)\", color=\"#d62728\")\n\nax.set_yticks(list(y))\nax.set_yticklabels(plot_df[\"Occupation\"])\nax.invert_yaxis()\n\nax.set_xlabel(\"Weekly earnings\")\nax.set_title(\"Weekly Earnings by Occupation (All vs Male vs Female)\")\nax.grid(axis=\"x\", linestyle=\"--\", alpha=0.4)\nax.legend()\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Grouped bar chart", "color_palette": null, "reasoning": "The plot uses Matplotlib's ax.barh() method to draw data. The bars are oriented horizontally and grouped by occupation (three separate barh calls per y-tick), which aligns with the taxonomy definition for a Grouped bar chart."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Clean numeric weekly columns (some have 'Na' as strings)\nweekly_cols = [\"All_weekly\", \"M_weekly\", \"F_weekly\"]\nfor c in weekly_cols:\n    df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n# Exclude aggregate row for clearer occupation-level comparison\nplot_df = df[df[\"Occupation\"].str.upper() != \"ALL OCCUPATIONS\"].copy()\n\n# Compute gender pay ratio (Female / Male) where both are available\nplot_df[\"F_to_M_ratio\"] = plot_df[\"F_weekly\"] / plot_df[\"M_weekly\"]\nplot_df = plot_df.dropna(subset=[\"F_to_M_ratio\"])\n\n# Sort by ratio\nplot_df = plot_df.sort_values(\"F_to_M_ratio\", ascending=True)\n\n# Plot: horizontal bar chart of female-to-male weekly earnings ratio\nfig, ax = plt.subplots(figsize=(11, 7))\ny = np.arange(len(plot_df))\n\nax.barh(y, plot_df[\"F_to_M_ratio\"], color=\"#4C78A8\")\nax.axvline(1.0, color=\"black\", linewidth=1, linestyle=\"--\")\n\nax.set_yticks(y)\nax.set_yticklabels(plot_df[\"Occupation\"])\nax.set_xlabel(\"Female weekly earnings / Male weekly earnings\")\nax.set_title(\"Gender weekly earnings ratio by occupation (rows with both M and F weekly data)\")\n\nax.set_xlim(0, max(1.2, float(plot_df[\"F_to_M_ratio\"].max()) * 1.05))\nax.grid(axis=\"x\", linestyle=\":\", alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the `ax.barh()` function from matplotlib to draw horizontal bars, which corresponds to a 'Bar chart' in the taxonomy. Even though pandas is used for data cleaning, the rendering is done via direct matplotlib axes calls."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Convert weekly earnings columns to numeric (coerce 'Na' and any non-numeric to NaN)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Keep only rows with valid overall weekly earnings and exclude the total row to focus on occupations\nplot_df = df[df[\"All_weekly\"].notna() & (df[\"Occupation\"] != \"ALL OCCUPATIONS\")].copy()\n\n# Sort and take top 10 occupations by overall weekly earnings\nplot_df = plot_df.sort_values(\"All_weekly\", ascending=False).head(10)\n\n# Plot: Single chart (horizontal bar) of overall weekly earnings\nplt.figure(figsize=(11, 6))\nplt.barh(plot_df[\"Occupation\"], plot_df[\"All_weekly\"], color=\"#2a6fbb\")\nplt.gca().invert_yaxis()\nplt.title(\"Top 10 occupations by overall weekly earnings (All_weekly)\")\nplt.xlabel(\"Weekly earnings (USD)\")\nplt.ylabel(\"Occupation\")\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the matplotlib.pyplot function plt.barh() to render horizontal bars directly from data, which fits the 'matplotlib' library classification and the 'Bar chart' taxonomy for horizontal layouts."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Coerce weekly earnings to numeric (handles 'Na')\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Focus on management sub-occupations (exclude 'ALL OCCUPATIONS' and 'MANAGEMENT')\nsub = df[~df[\"Occupation\"].isin([\"ALL OCCUPATIONS\", \"MANAGEMENT\"])].copy()\n\n# Compute gender pay gap (%): (M - F) / M * 100; require both values\nsub[\"gap_pct\"] = (sub[\"M_weekly\"] - sub[\"F_weekly\"]) / sub[\"M_weekly\"] * 100\nsub = sub.dropna(subset=[\"gap_pct\", \"All_workers\"])\n\n# Keep the most represented occupations to make labels readable\nsub = sub.sort_values(\"All_workers\", ascending=False).head(12)\n\n# Sort for plotting (small to large gap)\nsub = sub.sort_values(\"gap_pct\", ascending=True)\n\n# Plot\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6.5))\n\ny = np.arange(len(sub))\nsizes = 30 + (sub[\"All_workers\"] - sub[\"All_workers\"].min()) / (sub[\"All_workers\"].max() - sub[\"All_workers\"].min() + 1e-9) * 350\n\nsc = ax.scatter(\n    sub[\"gap_pct\"],\n    y,\n    s=sizes,\n    c=sub[\"gap_pct\"],\n    cmap=\"RdYlGn_r\",\n    alpha=0.9,\n    edgecolor=\"white\",\n    linewidth=0.8,\n)\n\n# Reference line at 0\nax.axvline(0, color=\"#444\", linewidth=1)\n\n# Labels and ticks\nax.set_yticks(y)\nax.set_yticklabels(sub[\"Occupation\"])\nax.set_xlabel(\"Gender pay gap in weekly earnings (Male higher) — % difference vs male weekly earnings\")\nax.set_title(\"Gender Pay Gap by Management Occupation (bubble size = number of workers)\")\n\nax.xaxis.set_major_formatter(FuncFormatter(lambda v, pos: f\"{v:.0f}%\"))\n\n# Colorbar\ncbar = plt.colorbar(sc, ax=ax, pad=0.02)\ncbar.set_label(\"Gap (%)\")\n\n# Annotate with M/F weekly values for context\nfor i, row in enumerate(sub.itertuples(index=False)):\n    ax.text(\n        row.gap_pct + (0.5 if row.gap_pct >= 0 else -0.5),\n        i,\n        f\"M ${row.M_weekly:.0f} / F ${row.F_weekly:.0f}\",\n        va=\"center\",\n        ha=\"left\" if row.gap_pct >= 0 else \"right\",\n        fontsize=9,\n        color=\"#222\",\n    )\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bubble chart", "color_palette": "RdYlGn_r", "reasoning": "The data is rendered using the `ax.scatter()` method, which identifies the library as matplotlib according to the hierarchy rules. The chart is classified as a Bubble chart because it maps two dimensions (gap percentage and occupation) to the X and Y axes, while modulating the marker size based on a third quantitative variable (number of workers)."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Clean weekly earnings (coerce non-numeric/Na to NaN)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Exclude aggregate row and keep occupations with both male and female weekly earnings\nplot_df = df[df[\"Occupation\"].str.strip().ne(\"ALL OCCUPATIONS\")].copy()\nplot_df = plot_df.dropna(subset=[\"M_weekly\", \"F_weekly\"])\n\n# Compute gender pay gap (female as % of male) and sort\nplot_df[\"F_as_pct_of_M\"] = 100 * plot_df[\"F_weekly\"] / plot_df[\"M_weekly\"]\nplot_df = plot_df.sort_values(\"F_as_pct_of_M\", ascending=True)\n\n# Plot\nplt.figure(figsize=(11, 8))\ny = np.arange(len(plot_df))\nvals = plot_df[\"F_as_pct_of_M\"].values\n\n# Color: below/above parity\ncolors = np.where(vals >= 100, \"#2ca02c\", \"#d62728\")\n\nplt.barh(y, vals, color=colors, edgecolor=\"white\", linewidth=0.8)\n\n# Parity reference line\nplt.axvline(100, color=\"#333333\", linewidth=1.2, linestyle=\"--\")\n\n# Labels and styling\nplt.yticks(y, plot_df[\"Occupation\"])\nplt.xlabel(\"Female weekly earnings as % of male weekly earnings\")\nplt.title(\"Gender pay ratio by occupation (weekly earnings)\")\nplt.xlim(0, max(130, np.nanmax(vals) * 1.05))\nplt.grid(axis=\"x\", linestyle=\":\", alpha=0.5)\n\n# Annotate values\nfor i, v in enumerate(vals):\n    plt.text(v + 1.2, i, f\"{v:.0f}%\", va=\"center\", ha=\"left\", fontsize=9, color=\"#111111\")\n\n# Footnote: units\nplt.figtext(\n    0.01, 0.01,\n    \"Note: Only occupations with both male and female weekly earnings reported are shown. \"\n    \"Dashed line indicates parity (100%).\",\n    ha=\"left\", va=\"bottom\", fontsize=9, color=\"#444444\"\n)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The visualization is created using the standard matplotlib.pyplot function plt.barh(), which renders horizontal bars, fitting the 'Bar chart' definition in the taxonomy."}}
{"input_csv_file": "9Income.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Income.csv\")\n\n# Clean weekly earnings (coerce 'Na' / missing to NaN, then numeric)\nfor col in [\"All_weekly\", \"M_weekly\", \"F_weekly\"]:\n    df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n\n# Focus on occupations with both male and female weekly values available (excluding the aggregate)\nplot_df = df[df[\"Occupation\"].ne(\"ALL OCCUPATIONS\")].copy()\nplot_df = plot_df.dropna(subset=[\"M_weekly\", \"F_weekly\"])\n\n# Compute pay gap ratio and percent difference\nplot_df[\"ratio_M_to_F\"] = plot_df[\"M_weekly\"] / plot_df[\"F_weekly\"]\nplot_df[\"gap_pct\"] = (plot_df[\"M_weekly\"] - plot_df[\"F_weekly\"]) / plot_df[\"F_weekly\"] * 100\n\n# Sort by ratio and take top N to keep chart readable\nN = 12\nplot_df = plot_df.sort_values(\"ratio_M_to_F\", ascending=False).head(N)\n\n# Plot: dumbbell chart (single chart)\ny = np.arange(len(plot_df))\n\nfig, ax = plt.subplots(figsize=(11, 7))\n\n# Connecting lines\nfor yi, f, m in zip(y, plot_df[\"F_weekly\"], plot_df[\"M_weekly\"]):\n    ax.plot([f, m], [yi, yi], color=\"#c7c7c7\", lw=2, zorder=1)\n\n# Points\nax.scatter(plot_df[\"F_weekly\"], y, color=\"#1f77b4\", s=70, label=\"Female weekly ($)\", zorder=2)\nax.scatter(plot_df[\"M_weekly\"], y, color=\"#d62728\", s=70, label=\"Male weekly ($)\", zorder=2)\n\n# Labels and annotations\nax.set_yticks(y)\nax.set_yticklabels(plot_df[\"Occupation\"])\nax.invert_yaxis()\n\nfor yi, f, m, g in zip(y, plot_df[\"F_weekly\"], plot_df[\"M_weekly\"], plot_df[\"gap_pct\"]):\n    ax.text(max(f, m) + 20, yi, f\"{g:.0f}%\", va=\"center\", ha=\"left\", fontsize=9, color=\"#333333\")\n\nax.set_xlabel(\"Weekly earnings ($)\")\nax.set_title(\"Male vs Female Weekly Earnings by Occupation (Largest Gaps, where both values available)\")\nax.grid(axis=\"x\", color=\"#e6e6e6\", linewidth=1)\nax.legend(frameon=False, loc=\"lower right\")\n\n# Add margin for right-side annotations\nxmax = np.nanmax(plot_df[[\"M_weekly\", \"F_weekly\"]].to_numpy())\nax.set_xlim(left=0, right=xmax + 250)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Dot plot", "color_palette": null, "reasoning": "The code uses matplotlib's axes functions (ax.scatter and ax.plot) directly to render the data points and connecting lines. It classifies as a Dot plot because it uses a discrete Y-axis (occupations) and quantitative X-axis (earnings) to show distributions of values per category."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Medal.csv\")\n\n# Prepare: top 10 teams by Combined Total\ntop = df.sort_values(\"Combined Total\", ascending=False).head(10)\n\n# Plot: stacked bars of Combined Gold/Silver/Bronze for top teams\nplt.figure(figsize=(12, 6))\nplt.bar(top[\"Team\"], top[\"Combined Gold\"], label=\"Gold\", color=\"#D4AF37\")\nplt.bar(top[\"Team\"], top[\"Combined Silver\"], bottom=top[\"Combined Gold\"], label=\"Silver\", color=\"#C0C0C0\")\nplt.bar(\n    top[\"Team\"],\n    top[\"Combined Bronze\"],\n    bottom=top[\"Combined Gold\"] + top[\"Combined Silver\"],\n    label=\"Bronze\",\n    color=\"#CD7F32\",\n)\n\nplt.title(\"Top 10 Teams by Combined Olympic Medals (Stacked by Gold/Silver/Bronze)\")\nplt.xlabel(\"Team\")\nplt.ylabel(\"Medals\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The code uses matplotlib.pyplot's plt.bar() function directly to render vertical bars. By using the 'bottom' parameter, it stacks multiple series (Gold, Silver, Bronze) on top of each other, classifying it as a Stacked column chart."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Medal.csv\")\n\n# Keep it simple: show the top 10 teams by Combined Total medals\ntop = df.sort_values(\"Combined Total\", ascending=False).head(10)\n\n# Plot: horizontal bar chart\nplt.figure(figsize=(10, 6))\nplt.barh(top[\"Team\"], top[\"Combined Total\"], color=\"steelblue\")\nplt.gca().invert_yaxis()  # highest at the top\n\nplt.title(\"Top 10 Teams by Combined Total Olympic Medals\")\nplt.xlabel(\"Combined Total Medals\")\nplt.ylabel(\"Team\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the `plt.barh()` function from the matplotlib library to render horizontal bars. According to the taxonomy, horizontal bars representing a categorical variable (Team) and a quantitative variable (Combined Total) are classified as a 'Bar chart'."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Medal.csv\")\n\n# Prepare: take top 10 teams by Combined Total\ntop = df.sort_values(\"Combined Total\", ascending=False).head(10)\n\n# Plot: simple ranked bar chart (Curcio \"read the data\" level)\nplt.figure(figsize=(11, 6))\nplt.barh(top[\"Team\"], top[\"Combined Total\"], color=\"#4C78A8\")\nplt.gca().invert_yaxis()\n\nplt.title(\"Top 10 Teams by Combined Olympic Medals (Total)\")\nplt.xlabel(\"Combined Total Medals\")\nplt.ylabel(\"Team\")\n\n# Add value labels\nfor i, v in enumerate(top[\"Combined Total\"]):\n    plt.text(v + max(top[\"Combined Total\"]) * 0.01, i, str(v), va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function 'plt.barh()' to render the data directly, classifying it as matplotlib. Because plt.barh() generates horizontal bars, it fits the 'Bar chart' taxonomy definition."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Medal.csv\")\n\n# Prepare: top 10 teams by Combined Total\ntop = df.sort_values(\"Combined Total\", ascending=False).head(10).copy()\ntop = top.sort_values(\"Combined Total\", ascending=True)  # for horizontal bar ordering\n\n# Plot: single chart (horizontal bar)\nplt.figure(figsize=(10, 6))\nplt.barh(top[\"Team\"], top[\"Combined Total\"], color=\"#4C78A8\")\nplt.title(\"Top 10 Teams by Combined Total Olympic Medals\")\nplt.xlabel(\"Combined Total Medals\")\nplt.ylabel(\"Team\")\n\n# Value labels\nfor i, v in enumerate(top[\"Combined Total\"].values):\n    plt.text(v + max(top[\"Combined Total\"]) * 0.01, i, str(v), va=\"center\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses the standard matplotlib.pyplot function plt.barh() to draw data directly, which signifies the matplotlib library. Since the bars are rendered horizontally, it is classified as a Bar chart according to the provided taxonomy."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Medal.csv\")\n\n# Top 10 teams by Combined Total\ntop = df.sort_values(\"Combined Total\", ascending=False).head(10)\n\n# Plot: stacked horizontal bars for Combined medals (Gold/Silver/Bronze)\nfig, ax = plt.subplots(figsize=(10, 6))\n\ny = top[\"Team\"]\ngold = top[\"Combined Gold\"]\nsilver = top[\"Combined Silver\"]\nbronze = top[\"Combined Bronze\"]\n\nax.barh(y, gold, color=\"#D4AF37\", label=\"Gold\")\nax.barh(y, silver, left=gold, color=\"#C0C0C0\", label=\"Silver\")\nax.barh(y, bronze, left=gold + silver, color=\"#CD7F32\", label=\"Bronze\")\n\nax.set_title(\"Top 10 Teams by Combined Olympic Medals (Stacked by Medal Type)\")\nax.set_xlabel(\"Number of Medals\")\nax.set_ylabel(\"Team\")\nax.invert_yaxis()\nax.legend(frameon=False, ncol=3, loc=\"lower right\")\n\n# Add totals at end of each bar\ntotals = top[\"Combined Total\"].values\nfor i, total in enumerate(totals):\n    ax.text(total + max(totals) * 0.01, i, str(total), va=\"center\", ha=\"left\", fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The data is rendered using the matplotlib axes method ax.barh() to create horizontal bars. The use of the 'left' parameter to stack consecutive medal counts on top of each other classifies it as a stacked bar chart."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"9Medal.csv\")\n\n    top = (\n        df.sort_values(\"Combined Total\", ascending=False)\n          .head(10)\n          .loc[:, [\"Team\", \"Combined Gold\", \"Combined Silver\", \"Combined Bronze\"]]\n          .set_index(\"Team\")\n    )\n\n    ax = top.plot(\n        kind=\"bar\",\n        stacked=True,\n        figsize=(12, 6),\n        color=[\"#D4AF37\", \"#C0C0C0\", \"#CD7F32\"],\n        edgecolor=\"black\",\n        linewidth=0.6\n    )\n\n    ax.set_title(\"Top 10 Teams by Combined Olympic Medals (Gold/Silver/Bronze)\")\n    ax.set_xlabel(\"Team\")\n    ax.set_ylabel(\"Number of Medals\")\n    ax.legend(title=\"Medal\", ncol=3, frameon=False)\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The visualization is generated using the pandas method `top.plot()`, which takes precedence over matplotlib according to the hierarchy rules. The chart uses vertical bars (`kind='bar'`) with the `stacked=True` parameter, identifying it as a 'Stacked column chart'."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"9Medal.csv\")\n\n    top = df.sort_values(\"Combined Total\", ascending=False).head(10)\n    top = top.sort_values(\"Combined Total\", ascending=True)  # for nicer horizontal bar ordering\n\n    plt.figure(figsize=(10, 6))\n    plt.barh(top[\"Team\"], top[\"Combined Total\"], color=\"#1f77b4\")\n    plt.xlabel(\"Combined Total Medals\")\n    plt.ylabel(\"Team\")\n    plt.title(\"Top 10 Teams by Combined Total Medals\")\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Bar chart", "color_palette": null, "reasoning": "The code uses plt.barh() directly to render horizontal bars representing categorical and quantitative data, which classifies the library as matplotlib and the chart type as a Bar chart."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"9Medal.csv\")\n\n    # Top 10 teams by Combined Total\n    top = df.sort_values(\"Combined Total\", ascending=False).head(10).copy()\n    top = top.sort_values(\"Combined Total\", ascending=True)  # for horizontal bar order\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    ax.barh(top[\"Team\"], top[\"Combined Gold\"], label=\"Gold\", color=\"#D4AF37\")\n    ax.barh(\n        top[\"Team\"],\n        top[\"Combined Silver\"],\n        left=top[\"Combined Gold\"],\n        label=\"Silver\",\n        color=\"#C0C0C0\",\n    )\n    ax.barh(\n        top[\"Team\"],\n        top[\"Combined Bronze\"],\n        left=top[\"Combined Gold\"] + top[\"Combined Silver\"],\n        label=\"Bronze\",\n        color=\"#CD7F32\",\n    )\n\n    ax.set_title(\"Top 10 Teams by Combined Olympic Medals (Gold/Silver/Bronze)\")\n    ax.set_xlabel(\"Medal Count\")\n    ax.set_ylabel(\"Team\")\n    ax.legend(loc=\"lower right\", frameon=True)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() function to render horizontal bars. By using the 'left' parameter to offset the start of the Silver and Bronze segments based on the previous values, it creates a stacked horizontal layout representing different medal categories for each team."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar el CSV\ndf = pd.read_csv(\"9Medal.csv\")\n\n# Seleccionar Top 10 por medallas combinadas totales\ntop = df.sort_values(\"Combined Total\", ascending=False).head(10).copy()\n\n# Preparar datos para barras apiladas (Oro/Plata/Bronce)\nteams = top[\"Team\"]\ngold = top[\"Combined Gold\"]\nsilver = top[\"Combined Silver\"]\nbronze = top[\"Combined Bronze\"]\n\n# Plot\nplt.figure(figsize=(12, 6))\nplt.bar(teams, gold, color=\"#D4AF37\", label=\"Oro\")\nplt.bar(teams, silver, bottom=gold, color=\"#C0C0C0\", label=\"Plata\")\nplt.bar(teams, bronze, bottom=gold + silver, color=\"#CD7F32\", label=\"Bronce\")\n\nplt.title(\"Top 10 equipos por medallas combinadas (Oro/Plata/Bronce)\")\nplt.xlabel(\"Equipo\")\nplt.ylabel(\"Número de medallas\")\nplt.xticks(rotation=45, ha=\"right\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly from the matplotlib library to render data. The charts consist of vertical bars (Column chart) that are layered on top of each other using the 'bottom' parameter, which classifies it as a Stacked column chart."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Medal.csv\")\n\n# Select top 10 teams by Combined Total\ntop = df.sort_values(\"Combined Total\", ascending=False).head(10).copy()\n\n# Prepare stacked values\nteams = top[\"Team\"]\ngold = top[\"Combined Gold\"]\nsilver = top[\"Combined Silver\"]\nbronze = top[\"Combined Bronze\"]\n\n# Plot: horizontal stacked bars for medal composition\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(10, 6))\n\nax.barh(teams, gold, color=\"#D4AF37\", label=\"Gold\")\nax.barh(teams, silver, left=gold, color=\"#C0C0C0\", label=\"Silver\")\nax.barh(teams, bronze, left=gold + silver, color=\"#CD7F32\", label=\"Bronze\")\n\n# Labels & formatting\nax.set_title(\"Top 10 Teams by Combined Olympic Medals (Composition)\")\nax.set_xlabel(\"Medals\")\nax.set_ylabel(\"Team\")\nax.invert_yaxis()\n\n# Annotate totals at end of each bar\ntotals = top[\"Combined Total\"].to_numpy()\nfor i, total in enumerate(totals):\n    ax.text(total + max(totals) * 0.01, i, f\"{int(total)}\", va=\"center\", ha=\"left\", fontsize=9)\n\nax.legend(loc=\"lower right\", frameon=True)\nax.set_xlim(0, max(totals) * 1.12)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.barh()` function to render horizontal bars, and the `left` parameter is used to stack different segments (Gold, Silver, Bronze) for each team. Although pandas is used for data manipulation, the drawing logic is handled directly by matplotlib."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Medal.csv\")\n\n# Prepare top teams by combined total medals\ntop_n = 12\ndf_top = df.sort_values(\"Combined Total\", ascending=False).head(top_n).copy()\n\n# Plot: stacked horizontal bars (Gold/Silver/Bronze) for top teams\nfig, ax = plt.subplots(figsize=(11, 7))\n\ny = df_top[\"Team\"]\ngold = df_top[\"Combined Gold\"]\nsilver = df_top[\"Combined Silver\"]\nbronze = df_top[\"Combined Bronze\"]\n\nax.barh(y, bronze, color=\"#cd7f32\", edgecolor=\"none\", label=\"Bronze\")\nax.barh(y, silver, left=bronze, color=\"#c0c0c0\", edgecolor=\"none\", label=\"Silver\")\nax.barh(y, gold, left=bronze + silver, color=\"#d4af37\", edgecolor=\"none\", label=\"Gold\")\n\n# Annotations: total at the end of each bar\ntotals = df_top[\"Combined Total\"]\nfor i, total in enumerate(totals):\n    ax.text(total + max(totals) * 0.01, i, f\"{int(total)}\", va=\"center\", ha=\"left\", fontsize=9)\n\n# Styling\nax.set_title(f\"Top {top_n} Teams by Combined Olympic Medals (Gold/Silver/Bronze)\", pad=12)\nax.set_xlabel(\"Medals (Combined Total)\")\nax.set_ylabel(\"\")\nax.invert_yaxis()\nax.grid(axis=\"x\", linestyle=\"--\", linewidth=0.6, alpha=0.35)\nax.legend(loc=\"lower right\", frameon=False)\n\nax.set_xlim(0, max(totals) * 1.12)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's ax.barh() function to render horizontal bars. It utilizes the 'left' parameter to stack the counts of bronze, silver, and gold medals for each team, making it a Stacked bar chart."}}
{"input_csv_file": "9Medal.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\n\n# Load data\ndf = pd.read_csv(\"9Medal.csv\")\n\n# Prepare: Top 10 by Combined Total\ntop = df.sort_values(\"Combined Total\", ascending=False).head(10).copy()\ntop = top.sort_values(\"Combined Total\", ascending=True)  # for horizontal bar ordering\n\n# Plot: stacked medals (Gold/Silver/Bronze) for Combined medals\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(11, 6.5))\n\ny = range(len(top))\ngold = top[\"Combined Gold\"].to_numpy()\nsilver = top[\"Combined Silver\"].to_numpy()\nbronze = top[\"Combined Bronze\"].to_numpy()\n\nax.barh(y, gold, color=\"#D4AF37\", edgecolor=\"none\", label=\"Gold\")\nax.barh(y, silver, left=gold, color=\"#C0C0C0\", edgecolor=\"none\", label=\"Silver\")\nax.barh(y, bronze, left=gold + silver, color=\"#CD7F32\", edgecolor=\"none\", label=\"Bronze\")\n\n# Labels and styling\nax.set_yticks(list(y))\nax.set_yticklabels(top[\"Team\"])\nax.set_xlabel(\"Combined medals (Gold + Silver + Bronze)\")\nax.set_title(\"Top 10 Teams by Combined Olympic Medals (Stacked by Medal Type)\")\n\n# Annotate totals at the end of each bar\ntotals = top[\"Combined Total\"].to_numpy()\nfor i, t in enumerate(totals):\n    ax.text(t + max(totals) * 0.01, i, f\"{t}\", va=\"center\", ha=\"left\", fontsize=9, color=\"#222\")\n\n# Ticks formatting\nax.xaxis.set_major_formatter(FuncFormatter(lambda x, pos: f\"{int(x):,}\" if x >= 0 else f\"-{int(-x):,}\"))\nax.set_xlim(0, max(totals) * 1.12)\n\n# Legend\nax.legend(ncol=3, frameon=True, loc=\"lower right\")\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Stacked bar chart", "color_palette": null, "reasoning": "The code uses matplotlib's `ax.barh()` method directly to create horizontal bars. It utilizes the `left` parameter to stack different medal counts (Gold, Silver, Bronze) for each categorical team variable, which defines it as a horizontal stacked bar chart."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "1_default", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndef main():\n    df = pd.read_csv(\"9Score.csv\")\n\n    long = df.melt(\n        id_vars=[\"test preparation course\"],\n        value_vars=[\"math score\", \"reading score\", \"writing score\"],\n        var_name=\"Subject\",\n        value_name=\"Score\",\n    )\n    long[\"Subject\"] = long[\"Subject\"].str.replace(\" score\", \"\", regex=False).str.title()\n\n    order = [\"none\", \"completed\"]\n    long[\"test preparation course\"] = pd.Categorical(\n        long[\"test preparation course\"], categories=order, ordered=True\n    )\n\n    sns.set_theme(style=\"whitegrid\")\n    plt.figure(figsize=(9, 5.5))\n    ax = sns.barplot(\n        data=long,\n        x=\"Subject\",\n        y=\"Score\",\n        hue=\"test preparation course\",\n        estimator=\"mean\",\n        errorbar=\"sd\",\n        palette=\"Set2\",\n    )\n\n    ax.set_title(\"Average Scores by Subject and Test Preparation Course\")\n    ax.set_xlabel(\"\")\n    ax.set_ylabel(\"Average score (mean ± SD)\")\n    ax.set_ylim(0, 100)\n    ax.legend(title=\"Test prep\")\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "seaborn", "chart_type": "Grouped column chart", "color_palette": "Set2", "reasoning": "The data is rendered using the sns.barplot function with the 'hue' parameter, which creates grouped vertical bars representing two categorical dimensions (Subject and test preparation course) and one quantitative dimension (Score)."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_L", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Score.csv\")\n\n# Aggregate: average scores by gender\nscore_cols = [\"math score\", \"reading score\", \"writing score\"]\nmeans = df.groupby(\"gender\")[score_cols].mean().sort_index()\n\n# Plot: grouped bar chart (single chart)\nfig, ax = plt.subplots(figsize=(8, 4.8))\nmeans.plot(kind=\"bar\", ax=ax)\n\nax.set_title(\"Average Test Scores by Gender (9Score.csv)\")\nax.set_xlabel(\"Gender\")\nax.set_ylabel(\"Average Score\")\nax.set_ylim(0, 100)\nax.legend(title=\"Subject\", frameon=False)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The plot is generated using the pandas DataFrame method `means.plot(kind='bar')`. According to the priority rules, this classifies the library as 'pandas'. Since the bars are vertical (default for kind='bar') and represent multiple quantitative variables (math, reading, and writing scores) grouped by a categorical variable (gender), it is a Grouped column chart."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Score.csv\")\n\n# Create a clear, single-chart summary: average scores by gender\nscore_cols = [\"math score\", \"reading score\", \"writing score\"]\nmeans = df.groupby(\"gender\")[score_cols].mean()\n\n# Plot\nax = means.plot(kind=\"bar\", figsize=(8, 5), rot=0)\nax.set_title(\"Average Test Scores by Gender\")\nax.set_xlabel(\"Gender\")\nax.set_ylabel(\"Average Score\")\nax.legend(title=\"Subject\", frameon=False)\n\n# Add value labels on bars\nfor container in ax.containers:\n    ax.bar_label(container, fmt=\"%.1f\", padding=2, fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the `means.plot(kind='bar')` method, which is a pandas wrapper around matplotlib. The bars are vertical (default for kind='bar'), and the chart compares multiple categories (math, reading, and writing scores) across a categorical variable (gender), making it a grouped column chart."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_VLAT_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Score.csv\")\n\n# Compute average scores by gender\navg_by_gender = df.groupby(\"gender\")[[\"math score\", \"reading score\", \"writing score\"]].mean()\n\n# Single chart: grouped bar chart of average scores by gender\nax = avg_by_gender.plot(kind=\"bar\", figsize=(8, 5), width=0.8)\n\nax.set_title(\"Average Test Scores by Gender\")\nax.set_xlabel(\"Gender\")\nax.set_ylabel(\"Average Score\")\nax.legend(title=\"Subject\", frameon=False)\nax.set_ylim(0, 100)\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas DataFrame .plot() method (kind='bar') to render the visualization, which defaults to vertical bars. Since the DataFrame contains multiple quantitative columns grouped by the 'gender' index, it produces a Grouped column chart."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_eng", "language": "eng", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"9Score.csv\")\n\n    # Average subject scores by gender\n    means = df.groupby(\"gender\")[[\"math score\", \"reading score\", \"writing score\"]].mean()\n    means = means.reindex([\"female\", \"male\"]).dropna(how=\"all\")  # stable order if present\n\n    ax = means.plot(kind=\"bar\", figsize=(9, 5), width=0.8)\n    ax.set_title(\"Average Math, Reading, and Writing Scores by Gender\")\n    ax.set_xlabel(\"Gender\")\n    ax.set_ylabel(\"Average score\")\n    ax.set_ylim(0, 100)\n    ax.legend(title=\"Subject\", frameon=False)\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The data is rendered using the pandas .plot() method on a DataFrame. The kind='bar' parameter generates vertical bars (Column chart), and since the DataFrame has multiple numeric columns (math, reading, writing scores), they are grouped by the 'gender' index, resulting in a Grouped column chart."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_kor", "language": "kor", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"9Score.csv\")\n\n    score_cols = [\"math score\", \"reading score\", \"writing score\"]\n    means = df[score_cols].mean().sort_values(ascending=False)\n\n    plt.figure(figsize=(7, 4.5))\n    bars = plt.bar(means.index, means.values, color=[\"#4C78A8\", \"#F58518\", \"#54A24B\"])\n    plt.title(\"Average Scores by Subject\")\n    plt.ylabel(\"Average score\")\n    plt.ylim(0, 100)\n\n    for b in bars:\n        h = b.get_height()\n        plt.text(b.get_x() + b.get_width() / 2, h + 1, f\"{h:.1f}\", ha=\"center\", va=\"bottom\", fontsize=10)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses the plt.bar() function from the matplotlib.pyplot library to render the data directly. Since plt.bar() creates vertical bars by default, it is classified as a Column chart."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_jap", "language": "jap", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"9Score.csv\")\n\n    subjects = [\"math score\", \"reading score\", \"writing score\"]\n    means = df[subjects].mean().reindex(subjects)\n\n    plt.figure(figsize=(7, 4.5))\n    bars = plt.bar(\n        [\"Math\", \"Reading\", \"Writing\"],\n        means.values,\n        color=[\"#4C78A8\", \"#F58518\", \"#54A24B\"],\n        edgecolor=\"black\",\n        linewidth=0.8,\n    )\n\n    plt.title(\"Average Scores by Subject (9Score.csv)\")\n    plt.ylabel(\"Average score\")\n    plt.ylim(0, 100)\n    plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.35)\n\n    for b, v in zip(bars, means.values):\n        plt.text(b.get_x() + b.get_width() / 2, v + 1, f\"{v:.1f}\", ha=\"center\", va=\"bottom\", fontsize=10)\n\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The code uses plt.bar() directly to render vertical bars, making it a Column chart. Since it utilizes standard pyplot functions to draw the data rather than pandas .plot() or seaborn methods, the library is classified as matplotlib."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_chi", "language": "chi", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    df = pd.read_csv(\"9Score.csv\")\n\n    score_cols = [\"math score\", \"reading score\", \"writing score\"]\n    avg_by_gender = df.groupby(\"gender\")[score_cols].mean().reindex([\"female\", \"male\"])\n\n    fig, ax = plt.subplots(figsize=(8, 4.8))\n    avg_by_gender.plot(kind=\"bar\", ax=ax, width=0.8)\n\n    ax.set_title(\"Average Scores by Gender (Math/Reading/Writing)\")\n    ax.set_xlabel(\"Gender\")\n    ax.set_ylabel(\"Average score\")\n    ax.set_ylim(0, 100)\n    ax.legend(title=\"Subject\", frameon=False)\n    ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n    plt.xticks(rotation=0)\n    plt.tight_layout()\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The visualization is generated using the pandas .plot(kind='bar') method, which classifies it under the 'pandas' library despite the use of matplotlib for styling. Because it uses multiple quantitative columns (math, reading, and writing scores) grouped across a categorical axis (gender) with vertical bars, it is classified as a Grouped column chart."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_Lang_esp", "language": "esp", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Cargar datos\ndf = pd.read_csv(\"9Score.csv\")\n\n# Promedio de puntajes por género (un solo gráfico)\navg_by_gender = (\n    df.groupby(\"gender\")[[\"math score\", \"reading score\", \"writing score\"]]\n    .mean()\n    .sort_index()\n)\n\nax = avg_by_gender.plot(kind=\"bar\", figsize=(9, 5), rot=0)\nax.set_title(\"Promedio de puntajes por género\")\nax.set_xlabel(\"Género\")\nax.set_ylabel(\"Puntaje promedio\")\nax.legend([\"Matemáticas\", \"Lectura\", \"Escritura\"], title=\"Prueba\", frameon=False)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "pandas", "chart_type": "Grouped column chart", "color_palette": null, "reasoning": "The code uses the pandas plotting wrapper 'df.plot(kind=\"bar\")' to render the data. Because the bars are vertical and the DataFrame contains multiple quantitative columns (math, reading, and writing scores) grouped by the categorical 'gender' index, it is classified as a grouped column chart."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_L", "response": "```python\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Score.csv\")\n\n# Prepare long-form data for a single chart\nlong_df = df.melt(\n    id_vars=[\"gender\", \"lunch\"],\n    value_vars=[\"math score\", \"reading score\", \"writing score\"],\n    var_name=\"Subject\",\n    value_name=\"Score\"\n)\nlong_df[\"Subject\"] = long_df[\"Subject\"].str.replace(\" score\", \"\", regex=False).str.title()\n\n# Style\nsns.set_theme(style=\"whitegrid\", context=\"talk\")\n\n# Single chart: Distribution of scores by subject and lunch status\nplt.figure(figsize=(11, 6))\nax = sns.violinplot(\n    data=long_df,\n    x=\"Subject\",\n    y=\"Score\",\n    hue=\"lunch\",\n    inner=\"quartile\",\n    cut=0,\n    linewidth=1,\n    palette=\"Set2\"\n)\n\nax.set_title(\"Score Distributions by Subject and Lunch Status\")\nax.set_xlabel(\"\")\nax.set_ylabel(\"Score\")\n\n# Keep legend clean and inside bounds\nleg = ax.legend(title=\"Lunch\", frameon=True, loc=\"upper right\")\nleg.get_frame().set_alpha(0.95)\n\nsns.despine(left=True, bottom=True)\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Violin plot", "color_palette": "Set2", "reasoning": "The visualization is created using the sns.violinplot() function from the Seaborn library. It displays distributions of scores across categories, fitting the definition of a violin plot."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_M", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv(\"9Score.csv\")\n\n# Compute average score across the three subjects\ndf[\"average_score\"] = df[[\"math score\", \"reading score\", \"writing score\"]].mean(axis=1)\n\n# Aggregate by test preparation course\nsummary = (\n    df.groupby(\"test preparation course\", as_index=False)\n      .agg(mean_avg_score=(\"average_score\", \"mean\"),\n           n=(\"average_score\", \"size\"))\n)\n\n# Ensure consistent order if both categories exist\norder = [\"none\", \"completed\"]\nsummary[\"test preparation course\"] = pd.Categorical(summary[\"test preparation course\"], categories=order, ordered=True)\nsummary = summary.sort_values(\"test preparation course\")\n\n# Plot: single chart\nplt.style.use(\"seaborn-v0_8-whitegrid\")\nfig, ax = plt.subplots(figsize=(8, 5))\n\nbars = ax.bar(\n    summary[\"test preparation course\"].astype(str),\n    summary[\"mean_avg_score\"],\n    color=[\"#6BAED6\", \"#31A354\"][: len(summary)],\n    edgecolor=\"black\",\n    linewidth=0.8\n)\n\nax.set_title(\"Average Overall Score by Test Preparation Course\", pad=10)\nax.set_xlabel(\"Test preparation course\")\nax.set_ylabel(\"Mean of (Math, Reading, Writing)\")\n\n# Annotate bars with mean and sample size\nfor bar, (_, row) in zip(bars, summary.iterrows()):\n    ax.text(\n        bar.get_x() + bar.get_width() / 2,\n        bar.get_height() + 1,\n        f\"{row['mean_avg_score']:.1f}\\n(n={int(row['n'])})\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=10\n    )\n\nax.set_ylim(0, max(summary[\"mean_avg_score\"]) + 12)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "matplotlib", "chart_type": "Column chart", "color_palette": null, "reasoning": "The plot is created using the standard matplotlib 'ax.bar()' function for vertical bars. While pandas is used for data aggregation and 'plt.style.use' is applied for styling, the primary rendering command belongs to the matplotlib library."}}
{"input_csv_file": "9Score.csv", "model_info": "gpt-5.2", "test_type": "2_expertise_H", "response": "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load data\ndf = pd.read_csv(\"9Score.csv\")\n\n# Create a single chart: average scores by gender (math/reading/writing)\navg_by_gender = (\n    df.groupby(\"gender\")[[\"math score\", \"reading score\", \"writing score\"]]\n      .mean()\n      .reset_index()\n      .melt(id_vars=\"gender\", var_name=\"subject\", value_name=\"average_score\")\n)\n\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(9, 5))\n\nax = sns.barplot(\n    data=avg_by_gender,\n    x=\"subject\",\n    y=\"average_score\",\n    hue=\"gender\",\n    palette=\"Set2\",\n    edgecolor=\"0.2\"\n)\n\nax.set_title(\"Average Student Scores by Gender and Subject\")\nax.set_xlabel(\"\")\nax.set_ylabel(\"Average score\")\nax.set_ylim(0, 100)\nax.legend(title=\"Gender\", frameon=True)\n\nplt.tight_layout()\nplt.show()\n```", "judgment": {"library": "seaborn", "chart_type": "Grouped column chart", "color_palette": "Set2", "reasoning": "The plot uses sns.barplot with categorical variables on the x-axis and a quantitative variable on the y-axis, resulting in vertical bars. The inclusion of the 'hue' parameter for 'gender' categorizes it as a Grouped column chart."}}
